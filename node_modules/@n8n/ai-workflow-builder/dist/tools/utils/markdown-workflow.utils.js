"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mermaidStringify = mermaidStringify;
exports.processWorkflowExamples = processWorkflowExamples;
exports.stickyNotesStringify = stickyNotesStringify;
const constants_1 = require("../../constants");
const DEFAULT_MERMAID_OPTIONS = {
    includeNodeType: true,
    includeNodeParameters: true,
    includeNodeName: true,
    collectNodeConfigurations: false,
};
function createNodeIdMap(nodes) {
    const nodeIdMap = new Map();
    nodes.forEach((node, idx) => {
        nodeIdMap.set(node.name, `n${idx + 1}`);
    });
    return nodeIdMap;
}
function findNodesWithIncomingConnections(connections) {
    const nodesWithIncoming = new Set();
    Object.values(connections)
        .filter((conn) => conn.main)
        .forEach((sourceConnections) => {
        for (const connArray of sourceConnections.main) {
            if (!connArray) {
                continue;
            }
            for (const conn of connArray) {
                nodesWithIncoming.add(conn.node);
            }
        }
    });
    return nodesWithIncoming;
}
function formatConnectionLine(sourceId, targetId, connType) {
    return connType === 'main'
        ? `    ${sourceId} --> ${targetId}`
        : `    ${sourceId} -.${connType}.-> ${targetId}`;
}
function extractNodeConnectionLines(nodeConns, sourceId, nodeIdMap) {
    return Object.entries(nodeConns).flatMap(([connType, connList]) => connList
        .filter((connArray) => connArray !== null)
        .flatMap((connArray) => connArray
        .map((conn) => {
        const targetId = nodeIdMap.get(conn.node);
        return targetId ? formatConnectionLine(sourceId, targetId, connType) : null;
    })
        .filter((line) => line !== null)));
}
function getMainConnectionTargets(nodeConns) {
    if (!nodeConns.main)
        return [];
    return nodeConns.main
        .filter((connArray) => connArray !== null)
        .flatMap((connArray) => connArray.map((conn) => conn.node));
}
function buildConnectionLines(connections, nodeIdMap, startNodes) {
    const visited = new Set();
    const outputConnections = [];
    function traverse(nodeName) {
        if (visited.has(nodeName))
            return;
        visited.add(nodeName);
        const nodeConns = connections[nodeName];
        if (!nodeConns)
            return;
        const sourceId = nodeIdMap.get(nodeName);
        if (!sourceId)
            return;
        outputConnections.push(...extractNodeConnectionLines(nodeConns, sourceId, nodeIdMap));
        getMainConnectionTargets(nodeConns).forEach((target) => traverse(target));
    }
    startNodes.forEach((node) => traverse(node.name));
    return outputConnections;
}
function maybeCollectNodeConfiguration(node, nodeConfigurations) {
    const hasParams = Object.keys(node.parameters).length > 0;
    if (!hasParams)
        return;
    const parametersStr = JSON.stringify(node.parameters);
    if (parametersStr.length <= constants_1.MAX_NODE_EXAMPLE_CHARS) {
        if (!nodeConfigurations[node.type]) {
            nodeConfigurations[node.type] = [];
        }
        nodeConfigurations[node.type].push({
            version: node.typeVersion,
            parameters: node.parameters,
        });
    }
}
function buildNodeDefinitionLines(nodes, nodeIdMap, options, nodeConfigurations) {
    const lines = [];
    for (const node of nodes) {
        const id = nodeIdMap.get(node.name);
        if (!id)
            continue;
        const hasParams = Object.keys(node.parameters).length > 0;
        if (options.collectNodeConfigurations) {
            maybeCollectNodeConfiguration(node, nodeConfigurations);
        }
        if (options.includeNodeType || options.includeNodeParameters) {
            const typePart = options.includeNodeType ? node.type : '';
            const paramsPart = options.includeNodeParameters && hasParams ? ` | ${JSON.stringify(node.parameters)}` : '';
            if (typePart || paramsPart) {
                lines.push(`    %% ${typePart}${paramsPart}`);
            }
        }
        if (options.includeNodeName) {
            lines.push(`    ${id}["${node.name.replace(/"/g, "'")}"]`);
        }
        else {
            lines.push(`    ${id}`);
        }
    }
    return lines;
}
function buildMermaidLines(nodes, connections, options = DEFAULT_MERMAID_OPTIONS, existingConfigurations) {
    const regularNodes = nodes.filter((n) => n.type !== 'n8n-nodes-base.stickyNote');
    const nodeConfigurations = existingConfigurations ?? {};
    const nodeIdMap = createNodeIdMap(regularNodes);
    const nodesWithIncoming = findNodesWithIncomingConnections(connections);
    const startNodes = regularNodes.filter((n) => !nodesWithIncoming.has(n.name));
    const connectionLines = buildConnectionLines(connections, nodeIdMap, startNodes);
    const nodeDefinitionLines = buildNodeDefinitionLines(regularNodes, nodeIdMap, options, nodeConfigurations);
    const lines = ['```mermaid', 'flowchart TD', ...nodeDefinitionLines, ...connectionLines, '```'];
    return { lines, nodeConfigurations };
}
function mermaidStringify(workflow, options) {
    const { workflow: wf } = workflow;
    const mergedOptions = {
        ...DEFAULT_MERMAID_OPTIONS,
        ...options,
    };
    const result = buildMermaidLines(wf.nodes, wf.connections, mergedOptions);
    return result.lines.join('\n');
}
function processWorkflowExamples(workflows, options) {
    const mergedOptions = {
        ...DEFAULT_MERMAID_OPTIONS,
        ...options,
        collectNodeConfigurations: true,
    };
    const allConfigurations = {};
    const results = workflows.map((workflow) => {
        const { workflow: wf } = workflow;
        const result = buildMermaidLines(wf.nodes, wf.connections, mergedOptions, allConfigurations);
        return {
            mermaid: result.lines.join('\n'),
            nodeConfigurations: result.nodeConfigurations,
        };
    });
    return results;
}
function stickyNotesStringify(workflow) {
    const { workflow: wf } = workflow;
    const stickyNotes = wf.nodes.filter((node) => node.type === 'n8n-nodes-base.stickyNote');
    if (stickyNotes.length === 0) {
        return '';
    }
    const lines = [];
    for (const note of stickyNotes) {
        const content = note.parameters.content;
        if (typeof content === 'string' && content) {
            const contentLines = content.trim().split('\n');
            const indentedContent = contentLines
                .map((line, idx) => (idx === 0 ? `- ${line}` : `  ${line}`))
                .join('\n');
            lines.push(indentedContent);
        }
    }
    return lines.join('\n');
}
//# sourceMappingURL=markdown-workflow.utils.js.map