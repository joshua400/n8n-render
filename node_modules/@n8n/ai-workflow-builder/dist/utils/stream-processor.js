"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_WORKFLOW_UPDATE_TOOLS = void 0;
exports.cleanContextTags = cleanContextTags;
exports.processStreamChunk = processStreamChunk;
exports.createStreamProcessor = createStreamProcessor;
exports.formatMessages = formatMessages;
const messages_1 = require("@langchain/core/messages");
exports.DEFAULT_WORKFLOW_UPDATE_TOOLS = [
    'add_nodes',
    'connect_nodes',
    'update_node_parameters',
    'remove_node',
];
const EMITTING_NODES = ['agent', 'responder'];
const SKIPPED_NODES = [
    'supervisor',
    'tools',
    'cleanup_dangling_tool_calls',
    'create_workflow_name',
    'auto_compact_messages',
    'configurator_subgraph',
    'discovery_subgraph',
    'builder_subgraph',
];
const SKIPPED_SUBGRAPH_PREFIXES = [
    'discovery_subgraph',
    'builder_subgraph',
    'configurator_subgraph',
];
function isFromSkippedSubgraph(namespace) {
    return namespace.some((ns) => SKIPPED_SUBGRAPH_PREFIXES.some((prefix) => ns.startsWith(prefix)));
}
function shouldSkipNode(nodeName) {
    return SKIPPED_NODES.includes(nodeName);
}
function shouldEmitFromNode(nodeName) {
    return EMITTING_NODES.includes(nodeName);
}
function hasMessageInUpdate(update) {
    const typed = update;
    return Array.isArray(typed?.messages) && typed.messages.length > 0;
}
function shouldFilterSubgraphUpdate(namespace, data) {
    if (!isFromSkippedSubgraph(namespace))
        return false;
    return Object.entries(data).some(([nodeName, update]) => {
        if (shouldSkipNode(nodeName))
            return false;
        return hasMessageInUpdate(update);
    });
}
function isSubgraphEvent(event) {
    return Array.isArray(event) && event.length === 3 && Array.isArray(event[0]);
}
function isParentEvent(event) {
    return Array.isArray(event) && event.length === 2 && typeof event[0] === 'string';
}
function extractMessageContent(messages) {
    if (messages.length === 0)
        return null;
    const lastMessage = messages[messages.length - 1];
    if (!lastMessage.content)
        return null;
    if (Array.isArray(lastMessage.content)) {
        const textContent = lastMessage.content
            .filter((c) => c.type === 'text')
            .map((c) => c.text)
            .join('\n');
        return textContent || null;
    }
    return lastMessage.content;
}
function cleanContextTags(text) {
    return text.replace(/\n*<current_workflow_json>[\s\S]*?<\/current_execution_nodes_schemas>/, '');
}
function processDeleteMessages(update) {
    const typed = update;
    if (!typed?.messages?.length)
        return null;
    const messageChunk = {
        role: 'assistant',
        type: 'message',
        text: 'Deleted, refresh?',
    };
    return { messages: [messageChunk] };
}
function processCompactMessages(update) {
    const typed = update;
    if (!typed?.messages?.length)
        return null;
    const content = extractMessageContent(typed.messages);
    if (!content)
        return null;
    const messageChunk = {
        role: 'assistant',
        type: 'message',
        text: content,
    };
    return { messages: [messageChunk] };
}
function processOperationsUpdate(update) {
    const typed = update;
    if (!typed?.workflowJSON || typed.workflowOperations === undefined)
        return null;
    const workflowUpdateChunk = {
        role: 'assistant',
        type: 'workflow-updated',
        codeSnippet: JSON.stringify(typed.workflowJSON, null, 2),
    };
    return { messages: [workflowUpdateChunk] };
}
function processAgentNodeUpdate(nodeName, update) {
    if (!shouldEmitFromNode(nodeName))
        return null;
    const typed = update;
    if (!typed?.messages?.length)
        return null;
    const content = extractMessageContent(typed.messages);
    if (!content?.trim() || content.includes('<current_workflow_json>'))
        return null;
    const messageChunk = {
        role: 'assistant',
        type: 'message',
        text: content,
    };
    return { messages: [messageChunk] };
}
function processToolChunk(chunk) {
    const typed = chunk;
    if (typed?.type !== 'tool')
        return null;
    return { messages: [typed] };
}
function processUpdatesChunk(nodeUpdate) {
    if (!nodeUpdate || typeof nodeUpdate !== 'object')
        return null;
    if (nodeUpdate.delete_messages) {
        return processDeleteMessages(nodeUpdate.delete_messages);
    }
    if (nodeUpdate.compact_messages) {
        return processCompactMessages(nodeUpdate.compact_messages);
    }
    if (nodeUpdate.process_operations) {
        return processOperationsUpdate(nodeUpdate.process_operations);
    }
    for (const [nodeName, update] of Object.entries(nodeUpdate)) {
        if (shouldSkipNode(nodeName))
            continue;
        const result = processAgentNodeUpdate(nodeName, update);
        if (result)
            return result;
    }
    return null;
}
function processStreamChunk(streamMode, chunk) {
    if (streamMode === 'updates') {
        return processUpdatesChunk(chunk);
    }
    if (streamMode === 'custom') {
        return processToolChunk(chunk);
    }
    return null;
}
function processSubgraphEvent(event) {
    const [namespace, streamMode, data] = event;
    if (streamMode === 'updates' &&
        shouldFilterSubgraphUpdate(namespace, data)) {
        return null;
    }
    return processStreamChunk(streamMode, data);
}
function processParentEvent(event) {
    const [streamMode, chunk] = event;
    if (!streamMode || typeof streamMode !== 'string')
        return null;
    return processStreamChunk(streamMode, chunk);
}
function processEvent(event) {
    if (isSubgraphEvent(event)) {
        return processSubgraphEvent(event);
    }
    if (isParentEvent(event)) {
        return processParentEvent(event);
    }
    return null;
}
async function* createStreamProcessor(stream) {
    for await (const event of stream) {
        const result = processEvent(event);
        if (result) {
            yield result;
        }
    }
}
function extractHumanMessageText(content) {
    if (typeof content === 'string') {
        return content;
    }
    if (Array.isArray(content)) {
        return content
            .filter((c) => typeof c === 'object' && c !== null && 'type' in c && c.type === 'text' && 'text' in c)
            .map((c) => c.text)
            .join('\n');
    }
    return '';
}
function formatHumanMessage(msg) {
    const rawText = extractHumanMessageText(msg.content);
    const cleanedText = cleanContextTags(rawText);
    return {
        role: 'user',
        type: 'message',
        text: cleanedText,
    };
}
function processArrayContent(content) {
    const textMessages = content.filter((c) => typeof c === 'object' && c !== null && 'type' in c && c.type === 'text' && 'text' in c);
    return textMessages.map((textMessage) => ({
        role: 'assistant',
        type: 'message',
        text: textMessage.text,
    }));
}
function processAIMessageContent(msg) {
    if (!msg.content) {
        return [];
    }
    if (Array.isArray(msg.content)) {
        return processArrayContent(msg.content);
    }
    return [
        {
            role: 'assistant',
            type: 'message',
            text: msg.content,
        },
    ];
}
function createToolCallMessage(toolCall, builderTool) {
    return {
        id: toolCall.id,
        toolCallId: toolCall.id,
        role: 'assistant',
        type: 'tool',
        toolName: toolCall.name,
        displayTitle: builderTool?.displayTitle,
        customDisplayTitle: toolCall.args && builderTool?.getCustomDisplayTitle?.(toolCall.args),
        status: 'completed',
        updates: [
            {
                type: 'input',
                data: toolCall.args || {},
            },
        ],
    };
}
function processToolCalls(toolCalls, builderTools) {
    return toolCalls.map((toolCall) => {
        const builderTool = builderTools?.find((bt) => bt.toolName === toolCall.name);
        return createToolCallMessage(toolCall, builderTool);
    });
}
function processToolMessage(msg, formattedMessages) {
    const toolCallId = msg.tool_call_id;
    for (let i = formattedMessages.length - 1; i >= 0; i--) {
        const m = formattedMessages[i];
        if (m.type === 'tool' && m.id === toolCallId) {
            m.updates ??= [];
            m.updates.push({
                type: 'output',
                data: typeof msg.content === 'string' ? { result: msg.content } : msg.content,
            });
            break;
        }
    }
}
function formatMessages(messages, builderTools) {
    const formattedMessages = [];
    for (const msg of messages) {
        if (msg instanceof messages_1.HumanMessage) {
            formattedMessages.push(formatHumanMessage(msg));
        }
        else if (msg instanceof messages_1.AIMessage) {
            formattedMessages.push(...processAIMessageContent(msg));
            if (msg.tool_calls?.length) {
                formattedMessages.push(...processToolCalls(msg.tool_calls, builderTools));
            }
        }
        else if (msg instanceof messages_1.ToolMessage) {
            processToolMessage(msg, formattedMessages);
        }
    }
    return formattedMessages;
}
//# sourceMappingURL=stream-processor.js.map