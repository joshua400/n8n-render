"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeSubgraphTools = executeSubgraphTools;
exports.extractUserRequest = extractUserRequest;
exports.createStandardShouldContinue = createStandardShouldContinue;
const messages_1 = require("@langchain/core/messages");
const langgraph_1 = require("@langchain/langgraph");
const langchain_1 = require("../types/langchain");
function isCommandUpdate(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    const obj = value;
    if ('messages' in obj && obj.messages !== undefined && !Array.isArray(obj.messages)) {
        return false;
    }
    if ('workflowOperations' in obj &&
        obj.workflowOperations !== undefined &&
        !Array.isArray(obj.workflowOperations)) {
        return false;
    }
    return true;
}
async function executeSubgraphTools(state, toolMap) {
    const lastMessage = state.messages[state.messages.length - 1];
    if (!lastMessage || !(0, messages_1.isAIMessage)(lastMessage) || !lastMessage.tool_calls?.length) {
        return {};
    }
    const toolResults = await Promise.all(lastMessage.tool_calls.map(async (toolCall) => {
        const tool = toolMap.get(toolCall.name);
        if (!tool) {
            return new messages_1.ToolMessage({
                content: `Tool ${toolCall.name} not found`,
                tool_call_id: toolCall.id ?? '',
            });
        }
        try {
            const result = await tool.invoke(toolCall.args ?? {}, {
                toolCall: {
                    id: toolCall.id,
                    name: toolCall.name,
                    args: toolCall.args ?? {},
                },
            });
            return result;
        }
        catch (error) {
            return new messages_1.ToolMessage({
                content: `Tool failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
                tool_call_id: toolCall.id ?? '',
            });
        }
    }));
    const messages = [];
    const operations = [];
    for (const result of toolResults) {
        if ((0, langgraph_1.isCommand)(result)) {
            if (isCommandUpdate(result.update)) {
                if (result.update.messages) {
                    messages.push(...result.update.messages);
                }
                if (result.update.workflowOperations) {
                    operations.push(...result.update.workflowOperations);
                }
            }
        }
        else if ((0, langchain_1.isBaseMessage)(result)) {
            messages.push(result);
        }
    }
    const stateUpdate = {};
    if (messages.length > 0) {
        stateUpdate.messages = messages;
    }
    if (operations.length > 0) {
        stateUpdate.workflowOperations = operations;
    }
    return stateUpdate;
}
function extractUserRequest(messages, defaultValue = '') {
    const humanMessages = messages.filter((m) => m instanceof messages_1.HumanMessage);
    const lastUserMessage = humanMessages[humanMessages.length - 1];
    return typeof lastUserMessage?.content === 'string' ? lastUserMessage.content : defaultValue;
}
function createStandardShouldContinue() {
    return (state) => {
        const lastMessage = state.messages[state.messages.length - 1];
        const hasToolCalls = lastMessage &&
            'tool_calls' in lastMessage &&
            Array.isArray(lastMessage.tool_calls) &&
            lastMessage.tool_calls.length > 0;
        return hasToolCalls ? 'tools' : langgraph_1.END;
    };
}
//# sourceMappingURL=subgraph-helpers.js.map