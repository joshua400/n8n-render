"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponderAgent = void 0;
const messages_1 = require("@langchain/core/messages");
const prompts_1 = require("@langchain/core/prompts");
const coordination_log_1 = require("../utils/coordination-log");
const RESPONDER_PROMPT = `You are a helpful AI assistant for n8n workflow automation.

You have access to context about what has been built, including:
- Discovery results (nodes found)
- Builder output (workflow structure)
- Configuration summary (setup instructions)

FOR WORKFLOW COMPLETION RESPONSES:
When you receive [Internal Context], synthesize a clean user-facing response:
1. Summarize what was built in a friendly way
2. Explain the workflow structure briefly
3. Include setup instructions if provided
4. Ask if user wants adjustments

Example response structure:
"I've created your [workflow type] workflow! Here's what it does:
[Brief explanation of the flow]

**Setup Required:**
[List any configuration steps from the context]

Let me know if you'd like to adjust anything."

FOR QUESTIONS/CONVERSATIONS:
- Be friendly and concise
- Explain n8n capabilities when asked
- Provide practical examples when helpful

RESPONSE STYLE:
- Keep responses focused and not overly long
- Use markdown formatting for readability
- Be conversational and helpful`;
const systemPrompt = prompts_1.ChatPromptTemplate.fromMessages([
    [
        'system',
        [
            {
                type: 'text',
                text: RESPONDER_PROMPT,
                cache_control: { type: 'ephemeral' },
            },
        ],
    ],
    ['placeholder', '{messages}'],
]);
class ResponderAgent {
    llm;
    constructor(config) {
        this.llm = config.llm;
    }
    buildContextMessage(context) {
        const contextParts = [];
        const errorEntry = (0, coordination_log_1.getErrorEntry)(context.coordinationLog);
        if (errorEntry) {
            contextParts.push(`**Error:** An error occurred in the ${errorEntry.phase} phase: ${errorEntry.summary}`);
            contextParts.push('Please apologize to the user and explain that something went wrong while building their workflow.');
        }
        if (context.discoveryContext?.nodesFound.length) {
            contextParts.push(`**Discovery:** Found ${context.discoveryContext.nodesFound.length} relevant nodes`);
        }
        const builderOutput = (0, coordination_log_1.getBuilderOutput)(context.coordinationLog);
        if (builderOutput) {
            contextParts.push(`**Builder:** ${builderOutput}`);
        }
        else if (context.workflowJSON.nodes.length) {
            contextParts.push(`**Workflow:** ${context.workflowJSON.nodes.length} nodes created`);
        }
        const configuratorOutput = (0, coordination_log_1.getConfiguratorOutput)(context.coordinationLog);
        if (configuratorOutput) {
            contextParts.push(`**Configuration:**\n${configuratorOutput}`);
        }
        if (contextParts.length === 0) {
            return null;
        }
        return new messages_1.HumanMessage({
            content: `[Internal Context - Use this to craft your response]\n${contextParts.join('\n\n')}`,
        });
    }
    async invoke(context) {
        const agent = systemPrompt.pipe(this.llm);
        const contextMessage = this.buildContextMessage(context);
        const messagesToSend = contextMessage
            ? [...context.messages, contextMessage]
            : context.messages;
        return (await agent.invoke({ messages: messagesToSend }));
    }
}
exports.ResponderAgent = ResponderAgent;
//# sourceMappingURL=responder.agent.js.map