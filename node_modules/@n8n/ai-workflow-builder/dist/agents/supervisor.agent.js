"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SupervisorAgent = exports.supervisorRoutingSchema = void 0;
const messages_1 = require("@langchain/core/messages");
const prompts_1 = require("@langchain/core/prompts");
const zod_1 = require("zod");
const context_builders_1 = require("../utils/context-builders");
const coordination_log_1 = require("../utils/coordination-log");
const SUPERVISOR_PROMPT = `You are a Supervisor that routes user requests to specialist agents.

AVAILABLE AGENTS:
- discovery: Find n8n nodes for building/modifying workflows
- builder: Create nodes and connections (requires discovery first for new node types)
- configurator: Set parameters on EXISTING nodes (no structural changes)
- responder: Answer questions, confirm completion (TERMINAL)

ROUTING DECISION TREE:

1. Is user asking a question or chatting? → responder
   Examples: "what does this do?", "explain the workflow", "thanks"

2. Does the request involve NEW or DIFFERENT node types? → discovery
   Examples:
   - "Build a workflow that..." (new workflow)
   - "Use [ServiceB] instead of [ServiceA]" (replacing node type)
   - "Add [some integration]" (new integration)
   - "Switch from [ServiceA] to [ServiceB]" (swapping services)

3. Is the request about connecting/disconnecting existing nodes? → builder
   Examples: "Connect node A to node B", "Remove the connection to X"

4. Is the request about changing VALUES in existing nodes? → configurator
   Examples:
   - "Change the URL to https://..."
   - "Set the timeout to 30 seconds"
   - "Update the email subject to..."

KEY DISTINCTION:
- "Use [ServiceB] instead of [ServiceA]" = REPLACEMENT = discovery (new node type needed)
- "Change the [ServiceA] API key" = CONFIGURATION = configurator (same node, different value)

OUTPUT:
- reasoning: One sentence explaining your routing decision
- next: Agent name`;
const systemPrompt = prompts_1.ChatPromptTemplate.fromMessages([
    [
        'system',
        [
            {
                type: 'text',
                text: SUPERVISOR_PROMPT +
                    '\n\nGiven the conversation above, which agent should act next? Provide your reasoning and selection.',
                cache_control: { type: 'ephemeral' },
            },
        ],
    ],
    ['placeholder', '{messages}'],
]);
exports.supervisorRoutingSchema = zod_1.z.object({
    reasoning: zod_1.z.string().describe('One sentence explaining why this agent should act next'),
    next: zod_1.z
        .enum(['responder', 'discovery', 'builder', 'configurator'])
        .describe('The next agent to call'),
});
class SupervisorAgent {
    llm;
    constructor(config) {
        this.llm = config.llm;
    }
    buildContextMessage(context) {
        const contextParts = [];
        if (context.workflowJSON.nodes.length > 0) {
            contextParts.push('<workflow_summary>');
            contextParts.push((0, context_builders_1.buildWorkflowSummary)(context.workflowJSON));
            contextParts.push('</workflow_summary>');
        }
        if (context.coordinationLog.length > 0) {
            contextParts.push('<completed_phases>');
            contextParts.push((0, coordination_log_1.summarizeCoordinationLog)(context.coordinationLog));
            contextParts.push('</completed_phases>');
        }
        if (contextParts.length === 0) {
            return null;
        }
        return new messages_1.HumanMessage({ content: contextParts.join('\n\n') });
    }
    async invoke(context) {
        const agent = systemPrompt.pipe(this.llm.withStructuredOutput(exports.supervisorRoutingSchema, {
            name: 'routing_decision',
        }));
        const contextMessage = this.buildContextMessage(context);
        const messagesToSend = contextMessage
            ? [...context.messages, contextMessage]
            : context.messages;
        return await agent.invoke({ messages: messagesToSend });
    }
}
exports.SupervisorAgent = SupervisorAgent;
//# sourceMappingURL=supervisor.agent.js.map