"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMultiAgentWorkflowWithSubgraphs = createMultiAgentWorkflowWithSubgraphs;
const messages_1 = require("@langchain/core/messages");
const langgraph_1 = require("@langchain/langgraph");
const responder_agent_1 = require("./agents/responder.agent");
const supervisor_agent_1 = require("./agents/supervisor.agent");
const constants_1 = require("./constants");
const parent_graph_state_1 = require("./parent-graph-state");
const builder_subgraph_1 = require("./subgraphs/builder.subgraph");
const configurator_subgraph_1 = require("./subgraphs/configurator.subgraph");
const discovery_subgraph_1 = require("./subgraphs/discovery.subgraph");
const coordination_1 = require("./types/coordination");
const coordination_log_1 = require("./utils/coordination-log");
const operations_processor_1 = require("./utils/operations-processor");
function routeToNode(next) {
    const nodeMapping = {
        responder: 'responder',
        discovery: 'discovery_subgraph',
        builder: 'builder_subgraph',
        configurator: 'configurator_subgraph',
    };
    return nodeMapping[next] ?? 'responder';
}
function createSubgraphNodeHandler(subgraph, compiledGraph, name, logger, recursionLimit) {
    return async (state) => {
        try {
            const input = subgraph.transformInput(state);
            const result = await compiledGraph.invoke(input, { recursionLimit });
            const output = subgraph.transformOutput(result, state);
            return output;
        }
        catch (error) {
            logger?.error(`[${name}] ERROR:`, { error });
            const errorMessage = error instanceof Error ? error.message : `An error occurred in ${name}: ${String(error)}`;
            const phase = name.replace('_subgraph', '');
            return {
                nextPhase: 'responder',
                messages: [
                    new messages_1.HumanMessage({
                        content: `Error in ${name}: ${errorMessage}`,
                        name: 'system_error',
                    }),
                ],
                coordinationLog: [
                    {
                        phase,
                        status: 'error',
                        timestamp: Date.now(),
                        summary: `Error: ${errorMessage}`,
                        metadata: (0, coordination_1.createErrorMetadata)({
                            failedSubgraph: phase,
                            errorMessage,
                        }),
                    },
                ],
            };
        }
    };
}
function createMultiAgentWorkflowWithSubgraphs(config) {
    const { parsedNodeTypes, llmComplexTask, logger, instanceUrl, checkpointer } = config;
    const supervisorAgent = new supervisor_agent_1.SupervisorAgent({ llm: llmComplexTask });
    const responderAgent = new responder_agent_1.ResponderAgent({ llm: llmComplexTask });
    const discoverySubgraph = new discovery_subgraph_1.DiscoverySubgraph();
    const builderSubgraph = new builder_subgraph_1.BuilderSubgraph();
    const configuratorSubgraph = new configurator_subgraph_1.ConfiguratorSubgraph();
    const compiledDiscovery = discoverySubgraph.create({
        parsedNodeTypes,
        llm: llmComplexTask,
        logger,
    });
    const compiledBuilder = builderSubgraph.create({ parsedNodeTypes, llm: llmComplexTask, logger });
    const compiledConfigurator = configuratorSubgraph.create({
        parsedNodeTypes,
        llm: llmComplexTask,
        logger,
        instanceUrl,
    });
    return (new langgraph_1.StateGraph(parent_graph_state_1.ParentGraphState)
        .addNode('supervisor', async (state) => {
        const routing = await supervisorAgent.invoke({
            messages: state.messages,
            workflowJSON: state.workflowJSON,
            coordinationLog: state.coordinationLog,
        });
        return {
            nextPhase: routing.next,
        };
    })
        .addNode('responder', async (state) => {
        const response = await responderAgent.invoke({
            messages: state.messages,
            coordinationLog: state.coordinationLog,
            discoveryContext: state.discoveryContext,
            workflowJSON: state.workflowJSON,
        });
        return {
            messages: [response],
        };
    })
        .addNode('process_operations', (state) => {
        const result = (0, operations_processor_1.processOperations)(state);
        return {
            ...result,
            workflowOperations: [],
        };
    })
        .addNode('discovery_subgraph', createSubgraphNodeHandler(discoverySubgraph, compiledDiscovery, 'discovery_subgraph', logger, constants_1.MAX_DISCOVERY_ITERATIONS))
        .addNode('builder_subgraph', createSubgraphNodeHandler(builderSubgraph, compiledBuilder, 'builder_subgraph', logger, constants_1.MAX_BUILDER_ITERATIONS))
        .addNode('configurator_subgraph', createSubgraphNodeHandler(configuratorSubgraph, compiledConfigurator, 'configurator_subgraph', logger, constants_1.MAX_CONFIGURATOR_ITERATIONS))
        .addEdge('discovery_subgraph', 'process_operations')
        .addEdge('builder_subgraph', 'process_operations')
        .addEdge('configurator_subgraph', 'process_operations')
        .addEdge(langgraph_1.START, 'supervisor')
        .addConditionalEdges('supervisor', (state) => routeToNode(state.nextPhase))
        .addConditionalEdges('process_operations', (state) => routeToNode((0, coordination_log_1.getNextPhaseFromLog)(state.coordinationLog)))
        .addEdge('responder', langgraph_1.END)
        .compile({ checkpointer }));
}
//# sourceMappingURL=multi-agent-workflow-subgraphs.js.map