"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiscoverySubgraph = exports.DiscoverySubgraphState = void 0;
const messages_1 = require("@langchain/core/messages");
const prompts_1 = require("@langchain/core/prompts");
const tools_1 = require("@langchain/core/tools");
const langgraph_1 = require("@langchain/langgraph");
const zod_1 = require("zod");
const errors_1 = require("../errors");
const categorization_1 = require("../types/categorization");
const subgraph_interface_1 = require("./subgraph-interface");
const get_best_practices_tool_1 = require("../tools/get-best-practices.tool");
const node_details_tool_1 = require("../tools/node-details.tool");
const node_search_tool_1 = require("../tools/node-search.tool");
const coordination_1 = require("../types/coordination");
const cache_control_1 = require("../utils/cache-control");
const context_builders_1 = require("../utils/context-builders");
const subgraph_helpers_1 = require("../utils/subgraph-helpers");
const exampleCategorizations = [
    {
        prompt: 'Monitor social channels for product mentions and auto-respond with campaign messages',
        techniques: [
            categorization_1.WorkflowTechnique.MONITORING,
            categorization_1.WorkflowTechnique.CHATBOT,
            categorization_1.WorkflowTechnique.CONTENT_GENERATION,
        ],
    },
    {
        prompt: 'Collect partner referral submissions and verify client instances via BigQuery',
        techniques: [
            categorization_1.WorkflowTechnique.FORM_INPUT,
            categorization_1.WorkflowTechnique.HUMAN_IN_THE_LOOP,
            categorization_1.WorkflowTechnique.NOTIFICATION,
        ],
    },
    {
        prompt: 'Scrape competitor pricing pages weekly and generate a summary report of changes',
        techniques: [
            categorization_1.WorkflowTechnique.SCHEDULING,
            categorization_1.WorkflowTechnique.SCRAPING_AND_RESEARCH,
            categorization_1.WorkflowTechnique.DATA_EXTRACTION,
            categorization_1.WorkflowTechnique.DATA_ANALYSIS,
        ],
    },
    {
        prompt: 'Process uploaded PDF contracts to extract client details and update CRM records',
        techniques: [
            categorization_1.WorkflowTechnique.DOCUMENT_PROCESSING,
            categorization_1.WorkflowTechnique.DATA_EXTRACTION,
            categorization_1.WorkflowTechnique.DATA_TRANSFORMATION,
            categorization_1.WorkflowTechnique.ENRICHMENT,
        ],
    },
    {
        prompt: 'Build a searchable internal knowledge base from past support tickets',
        techniques: [
            categorization_1.WorkflowTechnique.DATA_TRANSFORMATION,
            categorization_1.WorkflowTechnique.DATA_ANALYSIS,
            categorization_1.WorkflowTechnique.KNOWLEDGE_BASE,
        ],
    },
    {
        prompt: 'Create an AI agent that writes and sends personalized emails to leads',
        techniques: [categorization_1.WorkflowTechnique.CONTENT_GENERATION, categorization_1.WorkflowTechnique.NOTIFICATION],
    },
    {
        prompt: 'Fetch trending topics from Google Trends and Reddit, select the best ones, and create social posts',
        techniques: [
            categorization_1.WorkflowTechnique.SCRAPING_AND_RESEARCH,
            categorization_1.WorkflowTechnique.TRIAGE,
            categorization_1.WorkflowTechnique.CONTENT_GENERATION,
        ],
    },
    {
        prompt: 'Trigger when a new contact is created in HubSpot and enrich their profile with LinkedIn data',
        techniques: [categorization_1.WorkflowTechnique.MONITORING, categorization_1.WorkflowTechnique.ENRICHMENT],
    },
    {
        prompt: 'Get stock prices from financial APIs and analyze volatility patterns',
        techniques: [categorization_1.WorkflowTechnique.SCRAPING_AND_RESEARCH, categorization_1.WorkflowTechnique.DATA_ANALYSIS],
    },
    {
        prompt: 'Generate video reels from templates and auto-post to social media on schedule',
        techniques: [
            categorization_1.WorkflowTechnique.SCHEDULING,
            categorization_1.WorkflowTechnique.DOCUMENT_PROCESSING,
            categorization_1.WorkflowTechnique.CONTENT_GENERATION,
        ],
    },
    {
        prompt: 'Receive news from Telegram channels, filter relevant ones, and forward to my channel',
        techniques: [
            categorization_1.WorkflowTechnique.MONITORING,
            categorization_1.WorkflowTechnique.TRIAGE,
            categorization_1.WorkflowTechnique.NOTIFICATION,
        ],
    },
    {
        prompt: 'Analyze YouTube video performance data and generate a weekly report',
        techniques: [
            categorization_1.WorkflowTechnique.SCRAPING_AND_RESEARCH,
            categorization_1.WorkflowTechnique.DATA_ANALYSIS,
            categorization_1.WorkflowTechnique.DATA_TRANSFORMATION,
        ],
    },
    {
        prompt: 'Create a chatbot that answers questions using data from a Google Sheet as knowledge base',
        techniques: [categorization_1.WorkflowTechnique.CHATBOT, categorization_1.WorkflowTechnique.KNOWLEDGE_BASE],
    },
    {
        prompt: 'Form submission with file upload triggers document extraction and approval workflow',
        techniques: [
            categorization_1.WorkflowTechnique.FORM_INPUT,
            categorization_1.WorkflowTechnique.DOCUMENT_PROCESSING,
            categorization_1.WorkflowTechnique.HUMAN_IN_THE_LOOP,
        ],
    },
];
function formatTechniqueList() {
    return Object.entries(categorization_1.TechniqueDescription)
        .map(([key, description]) => `- **${key}**: ${description}`)
        .join('\n');
}
function formatExampleCategorizations() {
    return exampleCategorizations
        .map((example) => `- ${example.prompt} → ${example.techniques.join(', ')}`)
        .join('\n');
}
const discoveryOutputSchema = zod_1.z.object({
    nodesFound: zod_1.z
        .array(zod_1.z.object({
        nodeName: zod_1.z.string().describe('The internal name of the node (e.g., n8n-nodes-base.gmail)'),
        version: zod_1.z
            .number()
            .describe('The version number of the node (e.g., 1, 1.1, 2, 3, 3.2, etc.)'),
        reasoning: zod_1.z.string().describe('Why this node is relevant for the workflow'),
        connectionChangingParameters: zod_1.z
            .array(zod_1.z.object({
            name: zod_1.z
                .string()
                .describe('Parameter name (e.g., "mode", "operation", "hasOutputParser")'),
            possibleValues: zod_1.z
                .array(zod_1.z.union([zod_1.z.string(), zod_1.z.boolean(), zod_1.z.number()]))
                .describe('Possible values this parameter can take'),
        }))
            .describe('Parameters that affect node connections (inputs/outputs). ONLY include if parameter appears in <input> or <output> expressions'),
    }))
        .describe('List of n8n nodes identified as necessary for the workflow'),
});
const DISCOVERY_PROMPT = `You are a Discovery Agent for n8n AI Workflow Builder.

YOUR ROLE: Identify relevant n8n nodes and their connection-changing parameters.

AVAILABLE TOOLS:
- get_best_practices: Retrieve best practices (internal context)
- search_nodes: Find n8n nodes by keyword
- get_node_details: Get complete node information including <connections>
- submit_discovery_results: Submit final results

PROCESS:
1. **Call get_best_practices** with identified techniques (internal context)
2. **Identify workflow components** from user request and best practices
3. **Call search_nodes IN PARALLEL** for all components (e.g., "Gmail", "OpenAI", "Schedule")
4. **Call get_node_details IN PARALLEL** for ALL promising nodes (batch multiple calls)
5. **Extract node information** from each node_details response:
   - Node name from <name> tag
   - Version number from <version> tag (required - extract the number)
   - Connection-changing parameters from <connections> section
6. **Call submit_discovery_results** with complete nodesFound array

TECHNIQUE CATEGORIZATION:
When calling get_best_practices, select techniques that match the user's workflow intent.

<available_techniques>
{techniques}
</available_techniques>

<example_categorizations>
{exampleCategorizations}
</example_categorizations>

<technique_clarifications>
Common distinctions to get right:
- **NOTIFICATION vs CHATBOT**: Use NOTIFICATION when SENDING emails/messages/alerts (including to Telegram CHANNELS which are broadcast-only). Use CHATBOT only when RECEIVING and REPLYING to direct messages in a conversation.
- **MONITORING**: Use when workflow TRIGGERS on external events (new record created, status changed, incoming webhook, new message in channel). NOT just scheduled runs.
- **SCRAPING_AND_RESEARCH vs DATA_EXTRACTION**: Use SCRAPING when fetching from EXTERNAL sources (APIs, websites, social media). Use DATA_EXTRACTION for parsing INTERNAL data you already have.
- **TRIAGE**: Use when SELECTING, PRIORITIZING, ROUTING, or QUALIFYING items (e.g., "pick the best", "route to correct team", "qualify leads").
- **DOCUMENT_PROCESSING**: Use for ANY file handling - PDFs, images, videos, Excel, Google Sheets, audio files, file uploads in forms.
- **HUMAN_IN_THE_LOOP**: Use when workflow PAUSES for human approval, review, signing documents, responding to polls, or any manual input before continuing.
- **DATA_ANALYSIS**: Use when ANALYZING, CLASSIFYING, IDENTIFYING PATTERNS, or UNDERSTANDING data (e.g., "analyze outcomes", "learn from previous", "classify by type", "identify trends").
- **KNOWLEDGE_BASE**: Use when storing/retrieving from a DATA SOURCE for Q&A - includes vector DBs, spreadsheets used as databases, document collections.
- **DATA_TRANSFORMATION**: Use when CONVERTING data format, creating REPORTS/SUMMARIES from analyzed data, or restructuring output.
</technique_clarifications>

Technique selection rules:
- Select ALL techniques that apply (most workflows use 2-4)
- Maximum 5 techniques
- Only select techniques you're confident apply

CONNECTION-CHANGING PARAMETERS - CRITICAL RULES:

A parameter is connection-changing ONLY IF it appears in <input> or <output> expressions within <node_details>.

**How to identify:**
1. Look at the <connections> section in node details
2. Check if <input> or <output> uses expressions like: ={{...parameterName...}}
3. If a parameter is referenced in these expressions, it IS connection-changing
4. If a parameter is NOT in <input>/<output> expressions, it is NOT connection-changing

**Example from AI Agent:**
\`\`\`xml
<input>={{...hasOutputParser, needsFallback...}}</input>
\`\`\`
→ hasOutputParser and needsFallback ARE connection-changing (they control which inputs appear)

**Counter-example:**
\`\`\`xml
<properties>
  <property name="promptType">...</property>  <!-- NOT in <input>/<output> -->
  <property name="systemMessage">...</property>  <!-- NOT in <input>/<output> -->
</properties>
\`\`\`
→ promptType and systemMessage are NOT connection-changing (they don't affect connections)

**Common connection-changing parameters:**
- Vector Store: mode (appears in <input>/<output> expressions)
- AI Agent: hasOutputParser, needsFallback (appears in <input> expression)
- Merge: numberInputs (appears in <input> expression)
- Webhook: responseMode (appears in <output> expression)

SUB-NODES SEARCHES:
When searching for AI nodes, ALSO search for their required sub-nodes:
- "AI Agent" → also search for "Chat Model", "Memory", "Output Parser"
- "Basic LLM Chain" → also search for "Chat Model", "Output Parser"
- "Vector Store" → also search for "Embeddings", "Document Loader"
- Always use search_nodes to find the exact node names and versions - NEVER guess versions

CRITICAL RULES:
- NEVER ask clarifying questions
- ALWAYS call get_best_practices first
- THEN Call search_nodes to learn about available nodes and their inputs and outputs
- FINALLY call get_node_details IN PARALLEL for speed to get more details about RELVANT node
- ALWAYS extract version number from <version> tag in node details
- NEVER guess node versions - always use search_nodes to find exact versions
- ONLY flag connectionChangingParameters if they appear in <input> or <output> expressions
- If no parameters appear in connection expressions, return empty array []
- Output ONLY: nodesFound with {{ nodeName, version, reasoning, connectionChangingParameters }}

DO NOT:
- Output text commentary between tool calls
- Include bestPractices or categorization in submit_discovery_results
- Flag parameters that don't affect connections
- Stop without calling submit_discovery_results
`;
exports.DiscoverySubgraphState = langgraph_1.Annotation.Root({
    userRequest: (0, langgraph_1.Annotation)({
        reducer: (x, y) => y ?? x,
        default: () => '',
    }),
    messages: (0, langgraph_1.Annotation)({
        reducer: (x, y) => x.concat(y),
        default: () => [],
    }),
    nodesFound: (0, langgraph_1.Annotation)({
        reducer: (x, y) => y ?? x,
        default: () => [],
    }),
    bestPractices: (0, langgraph_1.Annotation)({
        reducer: (x, y) => y ?? x,
    }),
});
class DiscoverySubgraph extends subgraph_interface_1.BaseSubgraph {
    name = 'discovery_subgraph';
    description = 'Discovers nodes and context for the workflow';
    agent;
    toolMap;
    logger;
    create(config) {
        this.logger = config.logger;
        const tools = [
            (0, get_best_practices_tool_1.createGetBestPracticesTool)(),
            (0, node_search_tool_1.createNodeSearchTool)(config.parsedNodeTypes),
            (0, node_details_tool_1.createNodeDetailsTool)(config.parsedNodeTypes),
        ];
        this.toolMap = new Map(tools.map((bt) => [bt.tool.name, bt.tool]));
        const submitTool = (0, tools_1.tool)(() => { }, {
            name: 'submit_discovery_results',
            description: 'Submit the final discovery results',
            schema: discoveryOutputSchema,
        });
        const systemPrompt = prompts_1.ChatPromptTemplate.fromMessages([
            [
                'system',
                [
                    {
                        type: 'text',
                        text: DISCOVERY_PROMPT,
                        cache_control: { type: 'ephemeral' },
                    },
                ],
            ],
            ['human', '{prompt}'],
            ['placeholder', '{messages}'],
        ]);
        if (typeof config.llm.bindTools !== 'function') {
            throw new errors_1.LLMServiceError('LLM does not support tools', {
                llmModel: config.llm._llmType(),
            });
        }
        const allTools = [...tools.map((bt) => bt.tool), submitTool];
        this.agent = systemPrompt.pipe(config.llm.bindTools(allTools));
        const subgraph = new langgraph_1.StateGraph(exports.DiscoverySubgraphState)
            .addNode('agent', this.callAgent.bind(this))
            .addNode('tools', async (state) => await (0, subgraph_helpers_1.executeSubgraphTools)(state, this.toolMap))
            .addNode('format_output', this.formatOutput.bind(this))
            .addEdge('__start__', 'agent')
            .addConditionalEdges('agent', this.shouldContinue.bind(this), {
            tools: 'tools',
            format_output: 'format_output',
            end: langgraph_1.END,
        })
            .addEdge('tools', 'agent')
            .addEdge('format_output', langgraph_1.END);
        return subgraph.compile();
    }
    async callAgent(state) {
        if (state.messages.length > 0) {
            (0, cache_control_1.applySubgraphCacheMarkers)(state.messages);
        }
        const response = (await this.agent.invoke({
            messages: state.messages,
            prompt: state.userRequest,
            techniques: formatTechniqueList(),
            exampleCategorizations: formatExampleCategorizations(),
        }));
        return { messages: [response] };
    }
    formatOutput(state) {
        const lastMessage = state.messages.at(-1);
        let output;
        if (lastMessage && (0, messages_1.isAIMessage)(lastMessage) && lastMessage.tool_calls) {
            const submitCall = lastMessage.tool_calls.find((tc) => tc.name === 'submit_discovery_results');
            if (submitCall) {
                output = submitCall.args;
            }
        }
        if (!output) {
            this.logger?.error('[Discovery] No submit tool call found in last message');
            return {
                nodesFound: [],
            };
        }
        const bestPracticesTool = state.messages.find((m) => m.getType() === 'tool' && m?.text?.startsWith('<best_practices>'));
        return {
            nodesFound: output.nodesFound,
            bestPractices: bestPracticesTool?.text,
        };
    }
    shouldContinue(state) {
        const lastMessage = state.messages[state.messages.length - 1];
        if (lastMessage &&
            (0, messages_1.isAIMessage)(lastMessage) &&
            lastMessage.tool_calls &&
            lastMessage.tool_calls.length > 0) {
            const submitCall = lastMessage.tool_calls.find((tc) => tc.name === 'submit_discovery_results');
            if (submitCall) {
                return 'format_output';
            }
            return 'tools';
        }
        this.logger?.warn('[Discovery Subgraph] Agent stopped without submitting results');
        return 'end';
    }
    transformInput(parentState) {
        const userRequest = (0, subgraph_helpers_1.extractUserRequest)(parentState.messages, 'Build a workflow');
        const contextParts = [];
        contextParts.push('<user_request>');
        contextParts.push(userRequest);
        contextParts.push('</user_request>');
        if (parentState.workflowJSON.nodes.length > 0) {
            contextParts.push('<existing_workflow_summary>');
            contextParts.push((0, context_builders_1.buildWorkflowSummary)(parentState.workflowJSON));
            contextParts.push('</existing_workflow_summary>');
        }
        const contextMessage = (0, context_builders_1.createContextMessage)(contextParts);
        return {
            userRequest,
            messages: [contextMessage],
        };
    }
    transformOutput(subgraphOutput, _parentState) {
        const nodesFound = subgraphOutput.nodesFound || [];
        const discoveryContext = {
            nodesFound,
            bestPractices: subgraphOutput.bestPractices,
        };
        const logEntry = {
            phase: 'discovery',
            status: 'completed',
            timestamp: Date.now(),
            summary: `Discovered ${nodesFound.length} nodes`,
            metadata: (0, coordination_1.createDiscoveryMetadata)({
                nodesFound: nodesFound.length,
                nodeTypes: nodesFound.map((n) => n.nodeName),
                hasBestPractices: !!subgraphOutput.bestPractices,
            }),
        };
        return {
            discoveryContext,
            coordinationLog: [logEntry],
        };
    }
}
exports.DiscoverySubgraph = DiscoverySubgraph;
//# sourceMappingURL=discovery.subgraph.js.map