import type { BaseChatModel } from '@langchain/core/language_models/chat_models';
import type { BaseMessage, AIMessage } from '@langchain/core/messages';
import type { Logger } from '@n8n/backend-common';
import type { INodeTypeDescription } from 'n8n-workflow';
import { BaseSubgraph } from './subgraph-interface';
import type { ParentGraphState } from '../parent-graph-state';
import type { CoordinationLogEntry } from '../types/coordination';
export declare const DiscoverySubgraphState: import("@langchain/langgraph").AnnotationRoot<{
    userRequest: import("@langchain/langgraph").BinaryOperatorAggregate<string, string>;
    messages: import("@langchain/langgraph").BinaryOperatorAggregate<BaseMessage<import("@langchain/core/messages").MessageStructure, import("@langchain/core/messages").MessageType>[], BaseMessage<import("@langchain/core/messages").MessageStructure, import("@langchain/core/messages").MessageType>[]>;
    nodesFound: import("@langchain/langgraph").BinaryOperatorAggregate<{
        nodeName: string;
        version: number;
        reasoning: string;
        connectionChangingParameters: Array<{
            name: string;
            possibleValues: Array<string | boolean | number>;
        }>;
    }[], {
        nodeName: string;
        version: number;
        reasoning: string;
        connectionChangingParameters: Array<{
            name: string;
            possibleValues: Array<string | boolean | number>;
        }>;
    }[]>;
    bestPractices: import("@langchain/langgraph").BinaryOperatorAggregate<string | undefined, string | undefined>;
}>;
export interface DiscoverySubgraphConfig {
    parsedNodeTypes: INodeTypeDescription[];
    llm: BaseChatModel;
    logger?: Logger;
}
export declare class DiscoverySubgraph extends BaseSubgraph<DiscoverySubgraphConfig, typeof DiscoverySubgraphState.State, typeof ParentGraphState.State> {
    name: string;
    description: string;
    private agent;
    private toolMap;
    private logger?;
    create(config: DiscoverySubgraphConfig): import("@langchain/langgraph").CompiledStateGraph<{
        userRequest: string;
        messages: BaseMessage<import("@langchain/core/messages").MessageStructure, import("@langchain/core/messages").MessageType>[];
        nodesFound: {
            nodeName: string;
            version: number;
            reasoning: string;
            connectionChangingParameters: Array<{
                name: string;
                possibleValues: Array<string | boolean | number>;
            }>;
        }[];
        bestPractices: string | undefined;
    }, {
        userRequest?: string | undefined;
        messages?: BaseMessage<import("@langchain/core/messages").MessageStructure, import("@langchain/core/messages").MessageType>[] | undefined;
        nodesFound?: {
            nodeName: string;
            version: number;
            reasoning: string;
            connectionChangingParameters: Array<{
                name: string;
                possibleValues: Array<string | boolean | number>;
            }>;
        }[] | undefined;
        bestPractices?: string | undefined;
    }, "agent" | "tools" | "__start__" | "format_output", {
        userRequest: import("@langchain/langgraph").BinaryOperatorAggregate<string, string>;
        messages: import("@langchain/langgraph").BinaryOperatorAggregate<BaseMessage<import("@langchain/core/messages").MessageStructure, import("@langchain/core/messages").MessageType>[], BaseMessage<import("@langchain/core/messages").MessageStructure, import("@langchain/core/messages").MessageType>[]>;
        nodesFound: import("@langchain/langgraph").BinaryOperatorAggregate<{
            nodeName: string;
            version: number;
            reasoning: string;
            connectionChangingParameters: Array<{
                name: string;
                possibleValues: Array<string | boolean | number>;
            }>;
        }[], {
            nodeName: string;
            version: number;
            reasoning: string;
            connectionChangingParameters: Array<{
                name: string;
                possibleValues: Array<string | boolean | number>;
            }>;
        }[]>;
        bestPractices: import("@langchain/langgraph").BinaryOperatorAggregate<string | undefined, string | undefined>;
    }, {
        userRequest: import("@langchain/langgraph").BinaryOperatorAggregate<string, string>;
        messages: import("@langchain/langgraph").BinaryOperatorAggregate<BaseMessage<import("@langchain/core/messages").MessageStructure, import("@langchain/core/messages").MessageType>[], BaseMessage<import("@langchain/core/messages").MessageStructure, import("@langchain/core/messages").MessageType>[]>;
        nodesFound: import("@langchain/langgraph").BinaryOperatorAggregate<{
            nodeName: string;
            version: number;
            reasoning: string;
            connectionChangingParameters: Array<{
                name: string;
                possibleValues: Array<string | boolean | number>;
            }>;
        }[], {
            nodeName: string;
            version: number;
            reasoning: string;
            connectionChangingParameters: Array<{
                name: string;
                possibleValues: Array<string | boolean | number>;
            }>;
        }[]>;
        bestPractices: import("@langchain/langgraph").BinaryOperatorAggregate<string | undefined, string | undefined>;
    }, import("@langchain/langgraph").StateDefinition, {
        agent: {
            messages: AIMessage<import("@langchain/core/messages").MessageStructure>[];
        };
        tools: {
            messages?: BaseMessage[];
            workflowOperations?: import("..").WorkflowOperation[] | null;
        };
    }, unknown, unknown>;
    private callAgent;
    private formatOutput;
    private shouldContinue;
    transformInput(parentState: typeof ParentGraphState.State): {
        userRequest: string;
        messages: import("@langchain/core/messages").HumanMessage<import("@langchain/core/messages").MessageStructure>[];
    };
    transformOutput(subgraphOutput: typeof DiscoverySubgraphState.State, _parentState: typeof ParentGraphState.State): {
        discoveryContext: {
            nodesFound: {
                nodeName: string;
                version: number;
                reasoning: string;
                connectionChangingParameters: Array<{
                    name: string;
                    possibleValues: Array<string | boolean | number>;
                }>;
            }[];
            bestPractices: string | undefined;
        };
        coordinationLog: CoordinationLogEntry[];
    };
}
