{"version":3,"sources":["../../../utils/agent-execution/createEngineRequests.ts"],"sourcesContent":["import type { DynamicStructuredTool, Tool } from '@langchain/classic/tools';\nimport { NodeConnectionTypes } from 'n8n-workflow';\nimport type { EngineRequest, IDataObject } from 'n8n-workflow';\n\nimport type { RequestResponseMetadata, ToolCallRequest } from './types';\n\n/**\n * Creates engine requests from tool calls.\n * Maps tool call information to the format expected by the n8n engine\n * for executing tool nodes.\n *\n * This is a generalized version that can be used across different agent types\n * (Tools Agent, OpenAI Functions Agent, etc.).\n *\n * @param toolCalls - Array of tool call requests to convert\n * @param itemIndex - The current item index\n * @param tools - Array of available tools\n * @returns Array of engine request objects (filtered to remove undefined entries)\n */\nexport async function createEngineRequests(\n\ttoolCalls: ToolCallRequest[],\n\titemIndex: number,\n\ttools: Array<DynamicStructuredTool | Tool>,\n): Promise<EngineRequest<RequestResponseMetadata>['actions']> {\n\treturn toolCalls\n\t\t.map((toolCall) => {\n\t\t\t// First try to get from metadata (for toolkit tools)\n\t\t\tconst foundTool = tools.find((tool) => tool.name === toolCall.tool);\n\n\t\t\tif (!foundTool) return undefined;\n\n\t\t\tconst nodeName = foundTool.metadata?.sourceNodeName as string | undefined;\n\n\t\t\t// Ensure nodeName is defined\n\t\t\tif (!nodeName) return undefined;\n\n\t\t\t// For toolkit tools, include the tool name so the node knows which tool to execute\n\t\t\tconst input = foundTool.metadata?.isFromToolkit\n\t\t\t\t? { ...toolCall.toolInput, tool: toolCall.tool }\n\t\t\t\t: toolCall.toolInput;\n\n\t\t\t// Extract thought_signature from the AIMessage in messageLog (for Gemini 3)\n\t\t\tlet thoughtSignature: string | undefined;\n\t\t\tif (toolCall.messageLog && Array.isArray(toolCall.messageLog)) {\n\t\t\t\tfor (const message of toolCall.messageLog) {\n\t\t\t\t\t// Check if message has content that could contain thought_signature\n\t\t\t\t\tif (message && typeof message === 'object' && 'content' in message) {\n\t\t\t\t\t\tconst content = message.content;\n\t\t\t\t\t\t// Content can be string or array of content blocks\n\t\t\t\t\t\tif (Array.isArray(content)) {\n\t\t\t\t\t\t\t// Look for thought_signature in content blocks\n\t\t\t\t\t\t\tfor (const block of content) {\n\t\t\t\t\t\t\t\tif (block && typeof block === 'object' && 'thoughtSignature' in block) {\n\t\t\t\t\t\t\t\t\tthoughtSignature = block.thoughtSignature as string;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (thoughtSignature) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tactionType: 'ExecutionNodeAction' as const,\n\t\t\t\tnodeName,\n\t\t\t\tinput: input as IDataObject,\n\t\t\t\ttype: NodeConnectionTypes.AiTool,\n\t\t\t\tid: toolCall.toolCallId,\n\t\t\t\tmetadata: {\n\t\t\t\t\titemIndex,\n\t\t\t\t\t...(thoughtSignature && { thoughtSignature }),\n\t\t\t\t},\n\t\t\t};\n\t\t})\n\t\t.filter((item): item is NonNullable<typeof item> => item !== undefined);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,0BAAoC;AAkBpC,eAAsB,qBACrB,WACA,WACA,OAC6D;AAC7D,SAAO,UACL,IAAI,CAAC,aAAa;AAElB,UAAM,YAAY,MAAM,KAAK,CAAC,SAAS,KAAK,SAAS,SAAS,IAAI;AAElE,QAAI,CAAC,UAAW,QAAO;AAEvB,UAAM,WAAW,UAAU,UAAU;AAGrC,QAAI,CAAC,SAAU,QAAO;AAGtB,UAAM,QAAQ,UAAU,UAAU,gBAC/B,EAAE,GAAG,SAAS,WAAW,MAAM,SAAS,KAAK,IAC7C,SAAS;AAGZ,QAAI;AACJ,QAAI,SAAS,cAAc,MAAM,QAAQ,SAAS,UAAU,GAAG;AAC9D,iBAAW,WAAW,SAAS,YAAY;AAE1C,YAAI,WAAW,OAAO,YAAY,YAAY,aAAa,SAAS;AACnE,gBAAM,UAAU,QAAQ;AAExB,cAAI,MAAM,QAAQ,OAAO,GAAG;AAE3B,uBAAW,SAAS,SAAS;AAC5B,kBAAI,SAAS,OAAO,UAAU,YAAY,sBAAsB,OAAO;AACtE,mCAAmB,MAAM;AACzB;AAAA,cACD;AAAA,YACD;AAAA,UACD;AACA,cAAI,iBAAkB;AAAA,QACvB;AAAA,MACD;AAAA,IACD;AAEA,WAAO;AAAA,MACN,YAAY;AAAA,MACZ;AAAA,MACA;AAAA,MACA,MAAM,wCAAoB;AAAA,MAC1B,IAAI,SAAS;AAAA,MACb,UAAU;AAAA,QACT;AAAA,QACA,GAAI,oBAAoB,EAAE,iBAAiB;AAAA,MAC5C;AAAA,IACD;AAAA,EACD,CAAC,EACA,OAAO,CAAC,SAA2C,SAAS,MAAS;AACxE;","names":[]}