"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var buildSteps_exports = {};
__export(buildSteps_exports, {
  buildSteps: () => buildSteps
});
module.exports = __toCommonJS(buildSteps_exports);
var import_messages = require("@langchain/core/messages");
var import_n8n_workflow = require("n8n-workflow");
function buildSteps(response, itemIndex) {
  const steps = [];
  if (response) {
    const responses = response?.actionResponses ?? [];
    if (response.metadata?.previousRequests) {
      steps.push.apply(steps, response.metadata.previousRequests);
    }
    for (const tool of responses) {
      if (tool.action?.metadata?.itemIndex !== itemIndex) continue;
      const toolInput = {
        ...tool.action.input,
        id: tool.action.id
      };
      if (!toolInput || !tool.data) {
        continue;
      }
      const step = steps.find((step2) => step2.action.toolCallId === toolInput.id);
      if (step) {
        continue;
      }
      const rawThoughtSignature = tool.action.metadata?.thoughtSignature;
      const thoughtSignature = typeof rawThoughtSignature === "string" ? rawThoughtSignature : void 0;
      const toolCall = {
        id: typeof toolInput?.id === "string" ? toolInput.id : "reconstructed_call",
        name: (0, import_n8n_workflow.nodeNameToToolName)(tool.action.nodeName),
        args: toolInput,
        type: "tool_call",
        additional_kwargs: {
          ...thoughtSignature && { thought_signature: thoughtSignature }
        }
      };
      const syntheticAIMessage = new import_messages.AIMessage({
        content: `Calling ${tool.action.nodeName} with input: ${JSON.stringify(toolInput)}`,
        tool_calls: [toolCall]
      });
      const toolResult = {
        action: {
          tool: (0, import_n8n_workflow.nodeNameToToolName)(tool.action.nodeName),
          toolInput: toolInput.input || {},
          log: toolInput.log || syntheticAIMessage.content,
          messageLog: [syntheticAIMessage],
          toolCallId: toolInput?.id,
          type: toolInput.type || "tool_call"
        },
        observation: JSON.stringify(tool.data?.data?.ai_tool?.[0]?.map((item) => item?.json) ?? "")
      };
      steps.push(toolResult);
    }
  }
  return steps;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  buildSteps
});
//# sourceMappingURL=buildSteps.js.map