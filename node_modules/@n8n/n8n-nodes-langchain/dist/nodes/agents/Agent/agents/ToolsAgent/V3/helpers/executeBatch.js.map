{"version":3,"sources":["../../../../../../../../nodes/agents/Agent/agents/ToolsAgent/V3/helpers/executeBatch.ts"],"sourcesContent":["import type { BaseChatModel } from '@langchain/core/language_models/chat_models';\nimport type { AgentRunnableSequence } from '@langchain/classic/agents';\nimport type { BaseChatMemory } from '@langchain/classic/memory';\nimport { NodeOperationError } from 'n8n-workflow';\nimport type {\n\tIExecuteFunctions,\n\tISupplyDataFunctions,\n\tINodeExecutionData,\n\tEngineResponse,\n\tEngineRequest,\n} from 'n8n-workflow';\n\nimport { getOptionalOutputParser } from '@utils/output_parsers/N8nOutputParser';\n\nimport type { RequestResponseMetadata, AgentResult } from '../types';\nimport { createAgentSequence } from './createAgentSequence';\nimport { finalizeResult } from './finalizeResult';\nimport { prepareItemContext } from './prepareItemContext';\nimport { runAgent } from './runAgent';\n\ntype BatchResult = AgentResult | EngineRequest<RequestResponseMetadata>;\n/**\n * Executes a batch of items, handling both successful execution and errors.\n * Applies continue-on-fail logic when errors occur.\n *\n * @param ctx - The execution context\n * @param batch - Array of items to process in this batch\n * @param startIndex - Starting index of the batch in the original items array (used to calculate itemIndex)\n * @param model - Primary chat model\n * @param fallbackModel - Optional fallback model\n * @param memory - Optional memory for conversation context\n * @param response - Optional engine response with previous tool calls\n * @returns Object containing execution data and optional requests\n */\nexport async function executeBatch(\n\tctx: IExecuteFunctions | ISupplyDataFunctions,\n\tbatch: INodeExecutionData[],\n\tstartIndex: number,\n\tmodel: BaseChatModel,\n\tfallbackModel: BaseChatModel | null,\n\tmemory: BaseChatMemory | undefined,\n\tresponse?: EngineResponse<RequestResponseMetadata>,\n): Promise<{\n\treturnData: INodeExecutionData[];\n\trequest: EngineRequest<RequestResponseMetadata> | undefined;\n}> {\n\tconst returnData: INodeExecutionData[] = [];\n\tlet request: EngineRequest<RequestResponseMetadata> | undefined = undefined;\n\n\tconst batchPromises = batch.map(async (_item, batchItemIndex) => {\n\t\tconst itemIndex = startIndex + batchItemIndex;\n\n\t\tconst itemContext = await prepareItemContext(ctx, itemIndex, response);\n\n\t\tconst { tools, prompt, options, outputParser } = itemContext;\n\n\t\t// Create executors for primary and fallback models\n\t\tconst executor: AgentRunnableSequence = createAgentSequence(\n\t\t\tmodel,\n\t\t\ttools,\n\t\t\tprompt,\n\t\t\toptions,\n\t\t\toutputParser,\n\t\t\tmemory,\n\t\t\tfallbackModel,\n\t\t);\n\n\t\t// Run the agent\n\t\treturn await runAgent(ctx, executor, itemContext, model, memory, response);\n\t});\n\n\tconst batchResults = await Promise.allSettled(batchPromises);\n\t// This is only used to check if the output parser is connected\n\t// so we can parse the output if needed. Actual output parsing is done in the loop above\n\tconst outputParser = await getOptionalOutputParser(ctx, 0);\n\n\tbatchResults.forEach((result, index) => {\n\t\tconst itemIndex = startIndex + index;\n\t\tif (result.status === 'rejected') {\n\t\t\tconst error = result.reason as Error;\n\t\t\tif (ctx.continueOnFail()) {\n\t\t\t\treturnData.push({\n\t\t\t\t\tjson: { error: error.message },\n\t\t\t\t\tpairedItem: { item: itemIndex },\n\t\t\t\t} as INodeExecutionData);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tthrow new NodeOperationError(ctx.getNode(), error);\n\t\t\t}\n\t\t}\n\t\tconst batchResult = result.value as BatchResult;\n\n\t\tif (!batchResult) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ('actions' in batchResult) {\n\t\t\tif (!request) {\n\t\t\t\trequest = {\n\t\t\t\t\tactions: batchResult.actions,\n\t\t\t\t\tmetadata: batchResult.metadata,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\trequest.actions.push.apply(request.actions, batchResult.actions);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Finalize the result\n\t\tconst itemResult = finalizeResult(batchResult, itemIndex, memory, outputParser);\n\t\treturnData.push(itemResult);\n\t});\n\n\treturn { returnData, request };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,0BAAmC;AASnC,6BAAwC;AAGxC,iCAAoC;AACpC,4BAA+B;AAC/B,gCAAmC;AACnC,sBAAyB;AAgBzB,eAAsB,aACrB,KACA,OACA,YACA,OACA,eACA,QACA,UAIE;AACF,QAAM,aAAmC,CAAC;AAC1C,MAAI,UAA8D;AAElE,QAAM,gBAAgB,MAAM,IAAI,OAAO,OAAO,mBAAmB;AAChE,UAAM,YAAY,aAAa;AAE/B,UAAM,cAAc,UAAM,8CAAmB,KAAK,WAAW,QAAQ;AAErE,UAAM,EAAE,OAAO,QAAQ,SAAS,cAAAA,cAAa,IAAI;AAGjD,UAAM,eAAkC;AAAA,MACvC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACAA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAGA,WAAO,UAAM,0BAAS,KAAK,UAAU,aAAa,OAAO,QAAQ,QAAQ;AAAA,EAC1E,CAAC;AAED,QAAM,eAAe,MAAM,QAAQ,WAAW,aAAa;AAG3D,QAAM,eAAe,UAAM,gDAAwB,KAAK,CAAC;AAEzD,eAAa,QAAQ,CAAC,QAAQ,UAAU;AACvC,UAAM,YAAY,aAAa;AAC/B,QAAI,OAAO,WAAW,YAAY;AACjC,YAAM,QAAQ,OAAO;AACrB,UAAI,IAAI,eAAe,GAAG;AACzB,mBAAW,KAAK;AAAA,UACf,MAAM,EAAE,OAAO,MAAM,QAAQ;AAAA,UAC7B,YAAY,EAAE,MAAM,UAAU;AAAA,QAC/B,CAAuB;AACvB;AAAA,MACD,OAAO;AACN,cAAM,IAAI,uCAAmB,IAAI,QAAQ,GAAG,KAAK;AAAA,MAClD;AAAA,IACD;AACA,UAAM,cAAc,OAAO;AAE3B,QAAI,CAAC,aAAa;AACjB;AAAA,IACD;AAEA,QAAI,aAAa,aAAa;AAC7B,UAAI,CAAC,SAAS;AACb,kBAAU;AAAA,UACT,SAAS,YAAY;AAAA,UACrB,UAAU,YAAY;AAAA,QACvB;AAAA,MACD,OAAO;AACN,gBAAQ,QAAQ,KAAK,MAAM,QAAQ,SAAS,YAAY,OAAO;AAAA,MAChE;AACA;AAAA,IACD;AAGA,UAAM,iBAAa,sCAAe,aAAa,WAAW,QAAQ,YAAY;AAC9E,eAAW,KAAK,UAAU;AAAA,EAC3B,CAAC;AAED,SAAO,EAAE,YAAY,QAAQ;AAC9B;","names":["outputParser"]}