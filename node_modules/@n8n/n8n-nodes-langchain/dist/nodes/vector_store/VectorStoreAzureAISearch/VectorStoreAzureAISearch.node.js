"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var VectorStoreAzureAISearch_node_exports = {};
__export(VectorStoreAzureAISearch_node_exports, {
  AZURE_AI_SEARCH_CREDENTIALS: () => AZURE_AI_SEARCH_CREDENTIALS,
  FILTER: () => FILTER,
  INDEX_NAME: () => INDEX_NAME,
  QUERY_TYPE: () => QUERY_TYPE,
  SEMANTIC_CONFIGURATION: () => SEMANTIC_CONFIGURATION,
  VectorStoreAzureAISearch: () => VectorStoreAzureAISearch,
  clearAzureSearchIndex: () => clearAzureSearchIndex,
  getIndexName: () => getIndexName
});
module.exports = __toCommonJS(VectorStoreAzureAISearch_node_exports);
var import_search_documents = require("@azure/search-documents");
var import_azure_aisearch = require("@langchain/community/vectorstores/azure_aisearch");
var import_n8n_workflow = require("n8n-workflow");
var import_createVectorStoreNode = require("../shared/createVectorStoreNode/createVectorStoreNode");
const USER_AGENT_PREFIX = "n8n-azure-ai-search";
const AZURE_AI_SEARCH_CREDENTIALS = "azureAiSearchApi";
const INDEX_NAME = "indexName";
const QUERY_TYPE = "queryType";
const FILTER = "filter";
const SEMANTIC_CONFIGURATION = "semanticConfiguration";
const indexNameField = {
  displayName: "Index Name",
  name: INDEX_NAME,
  type: "string",
  default: "n8n-vectorstore",
  description: "The name of the Azure AI Search index. Will be created automatically if it does not exist.",
  required: true
};
const queryTypeField = {
  displayName: "Query Type",
  name: QUERY_TYPE,
  type: "options",
  default: "hybrid",
  description: "The type of search query to perform",
  options: [
    {
      name: "Vector",
      value: "vector",
      description: "Vector similarity search only"
    },
    {
      name: "Hybrid",
      value: "hybrid",
      description: "Combines vector and keyword search (recommended)"
    },
    {
      name: "Semantic Hybrid",
      value: "semanticHybrid",
      description: "Hybrid search with semantic ranking (requires Basic tier or higher)"
    }
  ]
};
const filterField = {
  displayName: "Filter",
  name: FILTER,
  type: "string",
  default: "",
  description: 'Filter results using OData syntax. Use metadata/fieldName for metadata fields. <a href="https://learn.microsoft.com/en-us/azure/search/search-query-odata-filter" target="_blank">Learn more</a>.',
  placeholder: "metadata/category eq 'technology' and metadata/author eq 'John'"
};
const semanticConfigurationField = {
  displayName: "Semantic Configuration",
  name: SEMANTIC_CONFIGURATION,
  type: "string",
  default: "",
  description: "Name of the semantic configuration for semantic ranking (optional)",
  displayOptions: {
    show: {
      [QUERY_TYPE]: ["semanticHybrid"]
    }
  }
};
const sharedFields = [indexNameField];
const retrieveFields = [
  {
    displayName: "Options",
    name: "options",
    type: "collection",
    placeholder: "Add Option",
    default: {},
    options: [queryTypeField, filterField, semanticConfigurationField]
  }
];
const insertFields = [
  {
    displayName: "Options",
    name: "options",
    type: "collection",
    placeholder: "Add Option",
    default: {},
    options: [
      {
        displayName: "Clear Index",
        name: "clearIndex",
        type: "boolean",
        default: false,
        description: "Whether to delete and recreate the index before inserting new data. Warning: This will reset any custom index configuration (semantic ranking, analyzers, etc.) to defaults."
      }
    ]
  }
];
function isExecutionContext(context) {
  return "addInputData" in context;
}
function getParameter(key, context, itemIndex) {
  let value;
  if (isExecutionContext(context)) {
    value = context.getNodeParameter(key, itemIndex, "", { extractValue: true });
  } else {
    value = context.getNodeParameter(key, "", { extractValue: true });
  }
  if (typeof value !== "string") {
    throw new import_n8n_workflow.NodeOperationError(context.getNode(), `Parameter ${key} must be a string`);
  }
  return value;
}
const getIndexName = getParameter.bind(null, INDEX_NAME);
function getOptionValue(name, context, itemIndex, defaultValue) {
  const options = context.getNodeParameter("options", itemIndex, {});
  return options[name] !== void 0 ? options[name] : defaultValue;
}
async function getValidatedCredentials(context, itemIndex) {
  const credentials = await context.getCredentials(AZURE_AI_SEARCH_CREDENTIALS);
  if (!credentials.endpoint || typeof credentials.endpoint !== "string") {
    throw new import_n8n_workflow.NodeOperationError(
      context.getNode(),
      "Azure AI Search endpoint is missing or invalid",
      { itemIndex }
    );
  }
  if (!credentials.apiKey || typeof credentials.apiKey !== "string") {
    throw new import_n8n_workflow.NodeOperationError(context.getNode(), "API Key is required for authentication", {
      itemIndex
    });
  }
  return {
    endpoint: credentials.endpoint,
    apiKey: credentials.apiKey
  };
}
async function clearAzureSearchIndex(context, itemIndex) {
  const options = context.getNodeParameter("options", itemIndex, {});
  if (!options.clearIndex) {
    return false;
  }
  const credentials = await getValidatedCredentials(context, itemIndex);
  const indexName = getIndexName(context, itemIndex);
  try {
    const indexClient = new import_search_documents.SearchIndexClient(
      credentials.endpoint,
      new import_search_documents.AzureKeyCredential(credentials.apiKey)
    );
    await indexClient.deleteIndex(indexName);
    context.logger.debug(`Deleted Azure AI Search index: ${indexName}`);
    return true;
  } catch (deleteError) {
    context.logger.debug("Error deleting index (may not exist):", {
      message: deleteError instanceof Error ? deleteError.message : String(deleteError)
    });
    return false;
  }
}
async function getAzureAISearchClient(context, embeddings, itemIndex) {
  const credentials = await getValidatedCredentials(context, itemIndex);
  try {
    const indexName = getIndexName(context, itemIndex);
    const azureCredentials = new import_search_documents.AzureKeyCredential(credentials.apiKey);
    const config = {
      endpoint: credentials.endpoint,
      indexName,
      credentials: azureCredentials,
      search: {},
      // Add custom user agent for usage tracking
      clientOptions: {
        userAgentOptions: { userAgentPrefix: USER_AGENT_PREFIX }
      }
    };
    if (isExecutionContext(context)) {
      const queryType = getQueryType(context, itemIndex);
      const semanticConfiguration = getOptionValue(
        "semanticConfiguration",
        context,
        itemIndex
      );
      const filter = getOptionValue("filter", context, itemIndex);
      config.search.type = queryType;
      if (filter) {
        config.search.filter = filter;
      }
      if (queryType === import_azure_aisearch.AzureAISearchQueryType.SemanticHybrid && semanticConfiguration) {
        config.search.semanticConfigurationName = semanticConfiguration;
      }
    }
    return new import_azure_aisearch.AzureAISearchVectorStore(embeddings, config);
  } catch (error) {
    if (error instanceof import_n8n_workflow.NodeOperationError) {
      throw error;
    }
    context.logger.debug("Azure AI Search connection error:", {
      message: error instanceof Error ? error.message : String(error),
      code: error.code,
      statusCode: error.statusCode,
      details: error.details
    });
    if (error.message?.includes("401") || error.message?.includes("Unauthorized") || error.message?.includes("authentication failed")) {
      throw new import_n8n_workflow.NodeOperationError(
        context.getNode(),
        "Authentication failed - invalid API key or endpoint.",
        {
          itemIndex,
          description: "Please verify your API Key and Search Endpoint are correct in the credentials configuration."
        }
      );
    }
    if (error.message?.includes("403") || error.message?.includes("Forbidden")) {
      throw new import_n8n_workflow.NodeOperationError(
        context.getNode(),
        "Authorization failed - insufficient permissions.",
        {
          itemIndex,
          description: "The API Key does not have sufficient permissions. Ensure the key has the required access level for this operation."
        }
      );
    }
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new import_n8n_workflow.NodeOperationError(context.getNode(), `Error: ${errorMessage}`, {
      itemIndex,
      description: "Please check your Azure AI Search connection details"
    });
  }
}
function getQueryType(context, itemIndex) {
  const queryType = getOptionValue("queryType", context, itemIndex, "hybrid");
  switch (queryType) {
    case "vector":
      return import_azure_aisearch.AzureAISearchQueryType.Similarity;
    case "hybrid":
      return import_azure_aisearch.AzureAISearchQueryType.SimilarityHybrid;
    case "semanticHybrid":
      return import_azure_aisearch.AzureAISearchQueryType.SemanticHybrid;
    default:
      return import_azure_aisearch.AzureAISearchQueryType.SimilarityHybrid;
  }
}
class VectorStoreAzureAISearch extends (0, import_createVectorStoreNode.createVectorStoreNode)({
  meta: {
    displayName: "Azure AI Search Vector Store",
    name: "vectorStoreAzureAISearch",
    description: "Work with your data in Azure AI Search Vector Store",
    icon: { light: "file:azure-aisearch.svg", dark: "file:azure-aisearch.svg" },
    docsUrl: "https://docs.n8n.io/integrations/builtin/cluster-nodes/root-nodes/n8n-nodes-langchain.vectorstoreazureaisearch/",
    credentials: [
      {
        name: "azureAiSearchApi",
        required: true
      }
    ],
    operationModes: ["load", "insert", "retrieve", "update", "retrieve-as-tool"]
  },
  sharedFields,
  retrieveFields,
  loadFields: retrieveFields,
  insertFields,
  async getVectorStoreClient(context, _filter, embeddings, itemIndex) {
    const vectorStore = await getAzureAISearchClient(context, embeddings, itemIndex);
    if (isExecutionContext(context)) {
      const filter = getOptionValue("filter", context, itemIndex);
      if (filter) {
        const filterObject = { filterExpression: filter };
        const originalSearchVectorWithScore = vectorStore.similaritySearchVectorWithScore.bind(vectorStore);
        vectorStore.similaritySearchVectorWithScore = async (query, k, additionalFilter) => {
          const mergedFilter = additionalFilter ? { ...filterObject, ...additionalFilter } : filterObject;
          return await originalSearchVectorWithScore(query, k, mergedFilter);
        };
        const originalSearch = vectorStore.similaritySearch.bind(vectorStore);
        vectorStore.similaritySearch = async (query, k) => {
          return await originalSearch(query, k, filterObject);
        };
        const originalSearchWithScore = vectorStore.similaritySearchWithScore.bind(vectorStore);
        vectorStore.similaritySearchWithScore = async (query, k) => {
          return await originalSearchWithScore(query, k, filterObject);
        };
        const originalAsRetriever = vectorStore.asRetriever.bind(vectorStore);
        vectorStore.asRetriever = (kwargs) => {
          return originalAsRetriever({
            ...kwargs,
            filter: filterObject
          });
        };
      }
    }
    return vectorStore;
  },
  async populateVectorStore(context, embeddings, documents, itemIndex) {
    try {
      await clearAzureSearchIndex(context, itemIndex);
      const vectorStore = await getAzureAISearchClient(context, embeddings, itemIndex);
      await vectorStore.addDocuments(documents);
    } catch (error) {
      context.logger.debug("Azure AI Search error details:", {
        message: error instanceof Error ? error.message : String(error),
        code: error.code,
        statusCode: error.statusCode,
        details: error.details,
        stack: error instanceof Error ? error.stack : void 0
      });
      if (error.message?.includes("401") || error.message?.includes("Unauthorized") || error.message?.includes("authentication failed")) {
        throw new import_n8n_workflow.NodeOperationError(
          context.getNode(),
          "Authentication failed during document upload - invalid API key or endpoint.",
          {
            itemIndex,
            description: "Please verify your API Key and Search Endpoint are correct in the credentials configuration."
          }
        );
      }
      if (error.message?.includes("403") || error.message?.includes("Forbidden") || error.statusCode === 403) {
        throw new import_n8n_workflow.NodeOperationError(
          context.getNode(),
          "Authorization failed - insufficient permissions for document upload.",
          {
            itemIndex,
            description: "The API Key does not have sufficient permissions for write operations. Ensure the key has the required access level."
          }
        );
      }
      if (error.name === "RestError" || error.message?.includes("RestError")) {
        const statusCode = error.statusCode || "unknown";
        const errorCode = error.code || "unknown";
        const errorMessage2 = error instanceof Error ? error.message : String(error);
        throw new import_n8n_workflow.NodeOperationError(
          context.getNode(),
          `Azure AI Search API error (${statusCode}): ${errorMessage2}`,
          {
            itemIndex,
            description: `Error code: ${errorCode}

Common causes:
- Invalid endpoint URL
- Index doesn't exist
- Authentication/authorization issues
- API version mismatch

Check the console logs for detailed error information.`
          }
        );
      }
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new import_n8n_workflow.NodeOperationError(context.getNode(), `Error: ${errorMessage}`, {
        itemIndex,
        description: "Please check your Azure AI Search connection details and index configuration"
      });
    }
  }
}) {
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AZURE_AI_SEARCH_CREDENTIALS,
  FILTER,
  INDEX_NAME,
  QUERY_TYPE,
  SEMANTIC_CONFIGURATION,
  VectorStoreAzureAISearch,
  clearAzureSearchIndex,
  getIndexName
});
//# sourceMappingURL=VectorStoreAzureAISearch.node.js.map