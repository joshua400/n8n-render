{"version":3,"file":"caches.js","names":["redisClient: RedisClientType","prompt: string","llmKey: string","generations: Generation[]","value: Generation[]"],"sources":["../src/caches.ts"],"sourcesContent":["import type { createCluster, createClient } from \"redis\";\n\nimport {\n  BaseCache,\n  deserializeStoredGeneration,\n  serializeGeneration,\n} from \"@langchain/core/caches\";\nimport { Generation } from \"@langchain/core/outputs\";\n\n/**\n * Represents the type of the Redis client used to interact with the Redis\n * database.\n */\ntype RedisClientType =\n  | ReturnType<typeof createClient>\n  | ReturnType<typeof createCluster>;\n\n/**\n * @deprecated Import from \"@langchain/community/caches/ioredis\" instead.\n * Represents a specific implementation of a caching mechanism using Redis\n * as the underlying storage system. It extends the `BaseCache` class and\n * overrides its methods to provide the Redis-specific logic.\n *\n * @example\n * ```typescript\n * const model = new ChatOpenAI({\n *   model: \"gpt-4o-mini\",\n *   cache: new RedisCache(new Redis(), { ttl: 60 }),\n * });\n *\n * // Invoke the model to perform an action\n * const response = await model.invoke(\"Do something random!\");\n * console.log(response);\n * ```\n */\nexport class RedisCache extends BaseCache {\n  private redisClient: RedisClientType;\n\n  constructor(redisClient: RedisClientType) {\n    super();\n    this.redisClient = redisClient;\n  }\n\n  /**\n   * Retrieves data from the cache. It constructs a cache key from the given\n   * `prompt` and `llmKey`, and retrieves the corresponding value from the\n   * Redis database.\n   *\n   * @param prompt The prompt used to construct the cache key.\n   * @param llmKey The LLM key used to construct the cache key.\n   * @returns An array of Generations if found, null otherwise.\n   */\n  public async lookup(prompt: string, llmKey: string) {\n    let idx = 0;\n    let key = this.keyEncoder(prompt, llmKey, String(idx));\n    let value = await this.redisClient.get(key);\n    const generations: Generation[] = [];\n\n    while (value) {\n      const storedGeneration = JSON.parse(value);\n      generations.push(deserializeStoredGeneration(storedGeneration));\n      idx += 1;\n      key = this.keyEncoder(prompt, llmKey, String(idx));\n      value = await this.redisClient.get(key);\n    }\n\n    return generations.length > 0 ? generations : null;\n  }\n\n  /**\n   * Updates the cache with new data. It constructs a cache key from the\n   * given `prompt` and `llmKey`, and stores the `value` in the Redis\n   * database.\n   * @param prompt The prompt used to construct the cache key.\n   * @param llmKey The LLM key used to construct the cache key.\n   * @param value The value to be stored in the cache.\n   */\n  public async update(prompt: string, llmKey: string, value: Generation[]) {\n    for (let i = 0; i < value.length; i += 1) {\n      const key = this.keyEncoder(prompt, llmKey, String(i));\n      await this.redisClient.set(\n        key,\n        JSON.stringify(serializeGeneration(value[i]))\n      );\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAmCA,IAAa,aAAb,cAAgC,UAAU;CACxC,AAAQ;CAER,YAAYA,aAA8B;EACxC,OAAO;EACP,KAAK,cAAc;CACpB;;;;;;;;;;CAWD,MAAa,OAAOC,QAAgBC,QAAgB;EAClD,IAAI,MAAM;EACV,IAAI,MAAM,KAAK,WAAW,QAAQ,QAAQ,OAAO,IAAI,CAAC;EACtD,IAAI,QAAQ,MAAM,KAAK,YAAY,IAAI,IAAI;EAC3C,MAAMC,cAA4B,CAAE;AAEpC,SAAO,OAAO;GACZ,MAAM,mBAAmB,KAAK,MAAM,MAAM;GAC1C,YAAY,KAAK,4BAA4B,iBAAiB,CAAC;GAC/D,OAAO;GACP,MAAM,KAAK,WAAW,QAAQ,QAAQ,OAAO,IAAI,CAAC;GAClD,QAAQ,MAAM,KAAK,YAAY,IAAI,IAAI;EACxC;AAED,SAAO,YAAY,SAAS,IAAI,cAAc;CAC/C;;;;;;;;;CAUD,MAAa,OAAOF,QAAgBC,QAAgBE,OAAqB;AACvE,OAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG;GACxC,MAAM,MAAM,KAAK,WAAW,QAAQ,QAAQ,OAAO,EAAE,CAAC;GACtD,MAAM,KAAK,YAAY,IACrB,KACA,KAAK,UAAU,oBAAoB,MAAM,GAAG,CAAC,CAC9C;EACF;CACF;AACF"}