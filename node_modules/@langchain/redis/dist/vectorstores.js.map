{"version":3,"file":"vectorstores.js","names":["metadata: Record<string, unknown>","embeddings: EmbeddingsInterface","_dbConfig: RedisVectorStoreConfig","documents: Document[]","options?: RedisAddOptions","vectors: number[][]","hashFields: Record<string, string | Buffer>","query: number[]","k: number","filter?: RedisVectorStoreFilterType","result: [Document, number][]","metadataFilter?: Record<string, unknown>","texts: string[]","metadatas: object[] | object","dbConfig: RedisVectorStoreConfig","docsOptions?: RedisAddOptions","docs: Document[]","schema: RediSearchSchema","deleteDocuments?: boolean","params: { deleteAll: boolean } | { ids: string[] }","options: SearchOptions","filterClauses: string[]","filter: RedisVectorStoreFilterType","str: string","vector: number[]"],"sources":["../src/vectorstores.ts"],"sourcesContent":["import { Document } from \"@langchain/core/documents\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { VectorStore } from \"@langchain/core/vectorstores\";\nimport type {\n  createClient,\n  createCluster,\n  RediSearchSchema,\n  SearchOptions,\n} from \"redis\";\nimport { SchemaFieldTypes, VectorAlgorithms } from \"redis\";\n\n// Adapated from internal redis types which aren't exported\n/**\n * Type for creating a schema vector field. It includes the algorithm,\n * distance metric, and initial capacity.\n */\nexport type CreateSchemaVectorField<\n  T extends VectorAlgorithms,\n  A extends Record<string, unknown>\n> = {\n  ALGORITHM: T;\n  DISTANCE_METRIC: \"L2\" | \"IP\" | \"COSINE\";\n  INITIAL_CAP?: number;\n} & A;\n/**\n * Type for creating a flat schema vector field. It extends\n * CreateSchemaVectorField with a block size property.\n */\nexport type CreateSchemaFlatVectorField = CreateSchemaVectorField<\n  VectorAlgorithms.FLAT,\n  {\n    BLOCK_SIZE?: number;\n  }\n>;\n/**\n * Type for creating a HNSW schema vector field. It extends\n * CreateSchemaVectorField with M, EF_CONSTRUCTION, and EF_RUNTIME\n * properties.\n */\nexport type CreateSchemaHNSWVectorField = CreateSchemaVectorField<\n  VectorAlgorithms.HNSW,\n  {\n    M?: number;\n    EF_CONSTRUCTION?: number;\n    EF_RUNTIME?: number;\n  }\n>;\n\ntype CreateIndexOptions = NonNullable<\n  Parameters<ReturnType<typeof createClient>[\"ft\"][\"create\"]>[3]\n>;\n\nexport type RedisSearchLanguages = `${NonNullable<\n  CreateIndexOptions[\"LANGUAGE\"]\n>}`;\n\nexport type RedisVectorStoreIndexOptions = Omit<\n  CreateIndexOptions,\n  \"LANGUAGE\"\n> & {\n  LANGUAGE?: RedisSearchLanguages;\n};\n\n/**\n * Interface for custom schema field definitions\n */\nexport interface CustomSchemaField {\n  type: SchemaFieldTypes;\n  required?: boolean;\n  SORTABLE?: boolean | \"UNF\";\n  NOINDEX?: boolean;\n  SEPARATOR?: string; // For TAG fields\n  CASESENSITIVE?: true; // For TAG fields (Redis expects true, not boolean)\n  NOSTEM?: true; // For TEXT fields (Redis expects true, not boolean)\n  WEIGHT?: number; // For TEXT fields\n}\n\n/**\n * Interface for the configuration of the RedisVectorStore. It includes\n * the Redis client, index name, index options, key prefix, content key,\n * metadata key, vector key, filter and ttl.\n */\nexport interface RedisVectorStoreConfig {\n  redisClient:\n    | ReturnType<typeof createClient>\n    | ReturnType<typeof createCluster>;\n  indexName: string;\n  indexOptions?: CreateSchemaFlatVectorField | CreateSchemaHNSWVectorField;\n  createIndexOptions?: Omit<RedisVectorStoreIndexOptions, \"PREFIX\">; // PREFIX must be set with keyPrefix\n  keyPrefix?: string;\n  contentKey?: string;\n  metadataKey?: string;\n  vectorKey?: string;\n  filter?: RedisVectorStoreFilterType;\n  ttl?: number; // ttl in second\n  customSchema?: Record<string, CustomSchemaField>; // Custom schema fields for metadata\n}\n\n/**\n * Interface for the options when adding documents to the\n * RedisVectorStore. It includes keys and batch size.\n */\nexport interface RedisAddOptions {\n  keys?: string[];\n  batchSize?: number;\n}\n\n/**\n * Type for the filter used in the RedisVectorStore. It is an array of\n * strings.\n * If a string is passed instead of an array the value is used directly, this\n * allows custom filters to be passed.\n */\nexport type RedisVectorStoreFilterType = string[] | string;\n\n/**\n * Class representing a RedisVectorStore. It extends the VectorStore class\n * and includes methods for adding documents and vectors, performing\n * similarity searches, managing the index, and more.\n */\nexport class RedisVectorStore extends VectorStore {\n  declare FilterType: RedisVectorStoreFilterType;\n\n  private redisClient:\n    | ReturnType<typeof createClient>\n    | ReturnType<typeof createCluster>;\n\n  indexName: string;\n\n  indexOptions: CreateSchemaFlatVectorField | CreateSchemaHNSWVectorField;\n\n  createIndexOptions: CreateIndexOptions;\n\n  keyPrefix: string;\n\n  contentKey: string;\n\n  metadataKey: string;\n\n  vectorKey: string;\n\n  filter?: RedisVectorStoreFilterType;\n\n  ttl?: number;\n\n  customSchema?: Record<string, CustomSchemaField>;\n\n  _vectorstoreType(): string {\n    return \"redis\";\n  }\n\n  /**\n   * Validates metadata against the custom schema if defined\n   * @param metadata The metadata object to validate\n   * @throws Error if validation fails\n   */\n  private validateMetadata(metadata: Record<string, unknown>): void {\n    if (!this.customSchema) {\n      return; // No schema defined, skip validation\n    }\n\n    for (const [fieldName, fieldConfig] of Object.entries(this.customSchema)) {\n      const value = metadata[fieldName];\n\n      // Check if required field is missing\n      if (fieldConfig.required && (value === undefined || value === null)) {\n        throw new Error(`Required metadata field '${fieldName}' is missing`);\n      }\n\n      // Skip validation for optional fields that are not provided\n      if (value === undefined || value === null) {\n        continue;\n      }\n\n      // Basic type validation based on schema field type\n      switch (fieldConfig.type) {\n        case SchemaFieldTypes.NUMERIC:\n          if (typeof value !== \"number\") {\n            throw new Error(\n              `Metadata field '${fieldName}' must be a number, got ${typeof value}`\n            );\n          }\n          break;\n        case SchemaFieldTypes.TAG:\n          if (typeof value !== \"string\" && !Array.isArray(value)) {\n            throw new Error(\n              `Metadata field '${fieldName}' must be a string or array, got ${typeof value}`\n            );\n          }\n          break;\n        case SchemaFieldTypes.TEXT:\n          if (typeof value !== \"string\") {\n            throw new Error(\n              `Metadata field '${fieldName}' must be a string, got ${typeof value}`\n            );\n          }\n          break;\n        default:\n          // For other field types, skip validation\n          break;\n      }\n    }\n  }\n\n  constructor(\n    embeddings: EmbeddingsInterface,\n    _dbConfig: RedisVectorStoreConfig\n  ) {\n    super(embeddings, _dbConfig);\n\n    this.redisClient = _dbConfig.redisClient;\n    this.indexName = _dbConfig.indexName;\n    this.indexOptions = _dbConfig.indexOptions ?? {\n      ALGORITHM: VectorAlgorithms.HNSW,\n      DISTANCE_METRIC: \"COSINE\",\n    };\n    this.keyPrefix = _dbConfig.keyPrefix ?? `doc:${this.indexName}:`;\n    this.contentKey = _dbConfig.contentKey ?? \"content\";\n    this.metadataKey = _dbConfig.metadataKey ?? \"metadata\";\n    this.vectorKey = _dbConfig.vectorKey ?? \"content_vector\";\n    this.filter = _dbConfig.filter;\n    this.ttl = _dbConfig.ttl;\n    this.customSchema = _dbConfig.customSchema;\n    this.createIndexOptions = {\n      ON: \"HASH\",\n      PREFIX: this.keyPrefix,\n      ...(_dbConfig.createIndexOptions as CreateIndexOptions),\n    };\n  }\n\n  /**\n   * Method for adding documents to the RedisVectorStore. It first converts\n   * the documents to texts and then adds them as vectors.\n   * @param documents The documents to add.\n   * @param options Optional parameters for adding the documents.\n   * @returns A promise that resolves when the documents have been added.\n   */\n  async addDocuments(documents: Document[], options?: RedisAddOptions) {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    return this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents,\n      options\n    );\n  }\n\n  /**\n   * Method for adding vectors to the RedisVectorStore. It checks if the\n   * index exists and creates it if it doesn't, then adds the vectors in\n   * batches.\n   * @param vectors The vectors to add.\n   * @param documents The documents associated with the vectors.\n   * @param keys Optional keys for the vectors.\n   * @param batchSize The size of the batches in which to add the vectors. Defaults to 1000.\n   * @returns A promise that resolves when the vectors have been added.\n   */\n  async addVectors(\n    vectors: number[][],\n    documents: Document[],\n    { keys, batchSize = 1000 }: RedisAddOptions = {}\n  ) {\n    if (!vectors.length || !vectors[0].length) {\n      throw new Error(\"No vectors provided\");\n    }\n    // check if the index exists and create it if it doesn't\n    await this.createIndex(vectors[0].length);\n\n    const info = await this.redisClient.ft.info(this.indexName);\n    const lastKeyCount =\n      parseInt(\n        info.numDocs ||\n          // @ts-expect-error - num_docs is not typed as not used by all redis connectors\n          info.num_docs,\n        10\n      ) || 0;\n\n    // Validate all metadata against custom schema first\n    if (this.customSchema) {\n      for (let idx = 0; idx < documents.length; idx += 1) {\n        const metadata =\n          documents[idx] && documents[idx].metadata\n            ? documents[idx].metadata\n            : {};\n        this.validateMetadata(metadata);\n      }\n    }\n\n    const multi = this.redisClient.multi();\n\n    await Promise.all(\n      vectors.map(async (vector, idx) => {\n        const key =\n          keys && keys.length\n            ? keys[idx]\n            : `${this.keyPrefix}${idx + lastKeyCount}`;\n        const metadata =\n          documents[idx] && documents[idx].metadata\n            ? documents[idx].metadata\n            : {};\n\n        // Prepare hash fields\n        const hashFields: Record<string, string | Buffer> = {\n          [this.vectorKey]: this.getFloat32Buffer(vector),\n          [this.contentKey]: documents[idx].pageContent,\n          [this.metadataKey]: this.escapeSpecialChars(JSON.stringify(metadata)),\n        };\n\n        // Add individual metadata fields for indexing if custom schema is defined\n        if (this.customSchema) {\n          for (const [fieldName, fieldConfig] of Object.entries(\n            this.customSchema\n          )) {\n            const fieldValue = metadata[fieldName];\n            if (fieldValue !== undefined && fieldValue !== null) {\n              const indexedFieldName = `${this.metadataKey}.${fieldName}`;\n\n              // Handle different field types appropriately\n              if (\n                fieldConfig.type === SchemaFieldTypes.TAG &&\n                Array.isArray(fieldValue)\n              ) {\n                // For TAG arrays, join with separator (default comma)\n                const separator = fieldConfig.SEPARATOR || \",\";\n                hashFields[indexedFieldName] = fieldValue.join(separator);\n              } else {\n                // For other types, store as-is\n                hashFields[indexedFieldName] = fieldValue;\n              }\n            }\n          }\n        }\n\n        multi.hSet(key, hashFields);\n\n        if (this.ttl) {\n          multi.expire(key, this.ttl);\n        }\n\n        // write batch\n        if (idx % batchSize === 0) {\n          await multi.exec();\n        }\n      })\n    );\n\n    // insert final batch\n    await multi.exec();\n  }\n\n  /**\n   * Method for performing a similarity search in the RedisVectorStore. It\n   * returns the documents and their scores.\n   * @param query The query vector.\n   * @param k The number of nearest neighbors to return.\n   * @param filter Optional filter to apply to the search.\n   * @returns A promise that resolves to an array of documents and their scores.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: RedisVectorStoreFilterType\n  ): Promise<[Document, number][]> {\n    if (filter && this.filter) {\n      throw new Error(\"cannot provide both `filter` and `this.filter`\");\n    }\n\n    const _filter = filter ?? this.filter;\n    const results = await this.redisClient.ft.search(\n      this.indexName,\n      ...this.buildQuery(query, k, _filter)\n    );\n    const result: [Document, number][] = [];\n\n    if (results.total) {\n      for (const res of results.documents) {\n        if (res.value) {\n          const document = res.value;\n          if (document.vector_score) {\n            result.push([\n              new Document({\n                pageContent: (document[this.contentKey] ?? \"\") as string,\n                metadata: JSON.parse(\n                  this.unEscapeSpecialChars(\n                    (document.metadata ?? \"{}\") as string\n                  )\n                ),\n              }),\n              Number(document.vector_score),\n            ]);\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Method for performing a similarity search with custom metadata filtering.\n   * Uses the custom schema fields for efficient filtering.\n   * @param query The query vector.\n   * @param k The number of nearest neighbors to return.\n   * @param metadataFilter Object with metadata field filters using custom schema.\n   * @returns A promise that resolves to an array of documents and their scores.\n   */\n  async similaritySearchVectorWithScoreAndMetadata(\n    query: number[],\n    k: number,\n    metadataFilter?: Record<string, unknown>\n  ): Promise<[Document, number][]> {\n    const results = await this.redisClient.ft.search(\n      this.indexName,\n      ...this.buildCustomQuery(query, k, metadataFilter)\n    );\n    const result: [Document, number][] = [];\n\n    if (results.total) {\n      for (const res of results.documents) {\n        if (res.value) {\n          const document = res.value;\n          if (document.vector_score) {\n            // Reconstruct metadata from both the JSON field and individual fields\n            let metadata: Record<string, unknown> = {};\n            try {\n              metadata = JSON.parse(\n                this.unEscapeSpecialChars((document.metadata ?? \"{}\") as string)\n              );\n            } catch {\n              // If JSON parsing fails, construct from individual fields\n              metadata = {};\n            }\n\n            // Add individual schema fields to metadata if they exist\n            if (this.customSchema) {\n              for (const fieldName of Object.keys(this.customSchema)) {\n                const fieldKey = `${this.metadataKey}.${fieldName}`;\n                if (document[fieldKey] !== undefined) {\n                  metadata[fieldName] = document[fieldKey] as unknown;\n                }\n              }\n            }\n\n            result.push([\n              new Document({\n                pageContent: (document[this.contentKey] ?? \"\") as string,\n                metadata,\n              }),\n              Number(document.vector_score),\n            ]);\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Static method for creating a new instance of RedisVectorStore from\n   * texts. It creates documents from the texts and metadata, then adds them\n   * to the RedisVectorStore.\n   * @param texts The texts to add.\n   * @param metadatas The metadata associated with the texts.\n   * @param embeddings The embeddings to use.\n   * @param dbConfig The configuration for the RedisVectorStore.\n   * @param docsOptions The document options to use.\n   * @returns A promise that resolves to a new instance of RedisVectorStore.\n   */\n  static fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig: RedisVectorStoreConfig,\n    docsOptions?: RedisAddOptions\n  ): Promise<RedisVectorStore> {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return RedisVectorStore.fromDocuments(\n      docs,\n      embeddings,\n      dbConfig,\n      docsOptions\n    );\n  }\n\n  /**\n   * Static method for creating a new instance of RedisVectorStore from\n   * documents. It adds the documents to the RedisVectorStore.\n   * @param docs The documents to add.\n   * @param embeddings The embeddings to use.\n   * @param dbConfig The configuration for the RedisVectorStore.\n   * @param docsOptions The document options to use.\n   * @returns A promise that resolves to a new instance of RedisVectorStore.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig: RedisVectorStoreConfig,\n    docsOptions?: RedisAddOptions\n  ): Promise<RedisVectorStore> {\n    const instance = new this(embeddings, dbConfig);\n    await instance.addDocuments(docs, docsOptions);\n    return instance;\n  }\n\n  /**\n   * Method for checking if an index exists in the RedisVectorStore.\n   * @returns A promise that resolves to a boolean indicating whether the index exists.\n   */\n  async checkIndexExists() {\n    try {\n      await this.redisClient.ft.info(this.indexName);\n    } catch (err) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if ((err as any)?.message.includes(\"unknown command\")) {\n        throw new Error(\n          \"Failed to run FT.INFO command. Please ensure that you are running a RediSearch-capable Redis instance: https://js.langchain.com/docs/integrations/vectorstores/redis/#setup\"\n        );\n      }\n      // index doesn't exist\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method for creating an index in the RedisVectorStore. If the index\n   * already exists, it does nothing.\n   * @param dimensions The dimensions of the index\n   * @returns A promise that resolves when the index has been created.\n   */\n  async createIndex(dimensions = 1536): Promise<void> {\n    if (await this.checkIndexExists()) {\n      return;\n    }\n\n    const schema: RediSearchSchema = {\n      [this.vectorKey]: {\n        type: SchemaFieldTypes.VECTOR,\n        TYPE: \"FLOAT32\",\n        DIM: dimensions,\n        ...this.indexOptions,\n      },\n      [this.contentKey]: SchemaFieldTypes.TEXT,\n      [this.metadataKey]: SchemaFieldTypes.TEXT,\n    };\n\n    // Add custom metadata schema fields for better filtering and searching\n    if (this.customSchema) {\n      for (const [fieldName, fieldConfig] of Object.entries(\n        this.customSchema\n      )) {\n        // Create field name with metadata prefix (e.g., metadata.userId)\n        const indexedFieldName = `${this.metadataKey}.${fieldName}`;\n\n        // Convert CustomSchemaField to proper Redis schema field\n        if (fieldConfig.type === SchemaFieldTypes.TAG) {\n          schema[indexedFieldName] = {\n            type: SchemaFieldTypes.TAG,\n            SORTABLE: fieldConfig.SORTABLE ? true : undefined,\n            SEPARATOR: (fieldConfig.SEPARATOR as string) || \",\",\n          };\n        } else if (fieldConfig.type === SchemaFieldTypes.NUMERIC) {\n          schema[indexedFieldName] = {\n            type: SchemaFieldTypes.NUMERIC,\n            SORTABLE: fieldConfig.SORTABLE ? true : undefined,\n          };\n        } else if (fieldConfig.type === SchemaFieldTypes.TEXT) {\n          schema[indexedFieldName] = {\n            type: SchemaFieldTypes.TEXT,\n            SORTABLE: fieldConfig.SORTABLE ? true : undefined,\n          };\n        } else {\n          // Fallback for other types - just use the field type directly\n          schema[indexedFieldName] = fieldConfig.type;\n        }\n      }\n    }\n\n    await this.redisClient.ft.create(\n      this.indexName,\n      schema,\n      this.createIndexOptions\n    );\n  }\n\n  /**\n   * Method for dropping an index from the RedisVectorStore.\n   * @param deleteDocuments Optional boolean indicating whether to drop the associated documents.\n   * @returns A promise that resolves to a boolean indicating whether the index was dropped.\n   */\n  async dropIndex(deleteDocuments?: boolean): Promise<boolean> {\n    try {\n      const options = deleteDocuments ? { DD: deleteDocuments } : undefined;\n      await this.redisClient.ft.dropIndex(this.indexName, options);\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Deletes vectors from the vector store.\n   *\n   * Supports two deletion modes:\n   * - Delete all documents by dropping the entire index and recreating it\n   * - Delete specific documents by their IDs using Redis DEL operation\n   *\n   * @param params - The deletion parameters. Must be one of:\n   *   - `{ deleteAll: boolean }` - If true, drops the entire index and all associated documents\n   *   - `{ ids: string[] }` - Array of document IDs to delete. IDs will be automatically prefixed with the configured keyPrefix\n   * @returns A promise that resolves when the deletion operation is complete\n   * @throws {Error} Throws an error if invalid parameters are provided (neither deleteAll nor ids specified)\n   *\n   * @example\n   * Delete all documents:\n   * ```typescript\n   * await vectorStore.delete({ deleteAll: true });\n   * ```\n   *\n   * @example\n   * Delete specific documents by ID:\n   * ```typescript\n   * await vectorStore.delete({ ids: ['doc1', 'doc2', 'doc3'] });\n   * ```\n   */\n  async delete(\n    params: { deleteAll: boolean } | { ids: string[] }\n  ): Promise<void> {\n    if (\"deleteAll\" in params && params.deleteAll) {\n      await this.dropIndex(true);\n    } else if (\"ids\" in params && params.ids && params.ids.length > 0) {\n      const keys = params.ids.map((id) => `${this.keyPrefix}${id}`);\n\n      await this.redisClient.del(keys);\n    } else {\n      throw new Error(`Invalid parameters passed to \"delete\".`);\n    }\n  }\n\n  private buildQuery(\n    query: number[],\n    k: number,\n    filter?: RedisVectorStoreFilterType\n  ): [string, SearchOptions] {\n    const vectorScoreField = \"vector_score\";\n\n    let hybridFields = \"*\";\n    // if a filter is set, modify the hybrid query\n    if (filter && filter.length) {\n      // `filter` is a list of strings, then it's applied using the OR operator in the metadata key\n      // for example: filter = ['foo', 'bar'] => this will filter all metadata containing either 'foo' OR 'bar'\n      hybridFields = `@${this.metadataKey}:(${this.prepareFilter(filter)})`;\n    }\n\n    const baseQuery = `${hybridFields} => [KNN ${k} @${this.vectorKey} $vector AS ${vectorScoreField}]`;\n\n    // Include custom schema fields in return fields for better access\n    const returnFields = [this.metadataKey, this.contentKey, vectorScoreField];\n    if (this.customSchema) {\n      for (const fieldName of Object.keys(this.customSchema)) {\n        returnFields.push(`${this.metadataKey}.${fieldName}`);\n      }\n    }\n\n    const options: SearchOptions = {\n      PARAMS: {\n        vector: this.getFloat32Buffer(query),\n      },\n      RETURN: returnFields,\n      SORTBY: vectorScoreField,\n      DIALECT: 2,\n      LIMIT: {\n        from: 0,\n        size: k,\n      },\n    };\n\n    return [baseQuery, options];\n  }\n\n  /**\n   * Builds a query with custom metadata field filtering\n   * @param query The query vector\n   * @param k Number of results to return\n   * @param metadataFilter Object with metadata field filters\n   * @returns Query string and search options\n   */\n  buildCustomQuery(\n    query: number[],\n    k: number,\n    metadataFilter?: Record<string, unknown>\n  ): [string, SearchOptions] {\n    const vectorScoreField = \"vector_score\";\n\n    let hybridFields = \"*\";\n\n    // Build filter using custom schema fields\n    if (metadataFilter && this.customSchema) {\n      const filterClauses: string[] = [];\n\n      for (const [fieldName, value] of Object.entries(metadataFilter)) {\n        if (this.customSchema[fieldName]) {\n          const fieldConfig = this.customSchema[fieldName];\n          const indexedFieldName = `${this.metadataKey}.${fieldName}`;\n\n          if (fieldConfig.type === SchemaFieldTypes.NUMERIC) {\n            // Handle numeric range queries\n            if (typeof value === \"object\" && value !== null) {\n              if (\"min\" in value && \"max\" in value) {\n                filterClauses.push(\n                  `@${indexedFieldName}:[${value.min} ${value.max}]`\n                );\n              } else if (\"min\" in value) {\n                filterClauses.push(`@${indexedFieldName}:[${value.min} +inf]`);\n              } else if (\"max\" in value) {\n                filterClauses.push(`@${indexedFieldName}:[-inf ${value.max}]`);\n              }\n            } else {\n              // Exact numeric match\n              filterClauses.push(`@${indexedFieldName}:[${value} ${value}]`);\n            }\n          } else if (fieldConfig.type === SchemaFieldTypes.TAG) {\n            // Handle tag filtering\n            if (Array.isArray(value)) {\n              const tagFilter = value.map((v) => `{${v}}`).join(\"|\");\n              filterClauses.push(`@${indexedFieldName}:(${tagFilter})`);\n            } else {\n              filterClauses.push(`@${indexedFieldName}:{${value}}`);\n            }\n          } else if (fieldConfig.type === SchemaFieldTypes.TEXT) {\n            // Handle text search\n            filterClauses.push(`@${indexedFieldName}:(${value})`);\n          }\n        }\n      }\n\n      if (filterClauses.length > 0) {\n        hybridFields = filterClauses.join(\" \");\n      }\n    }\n\n    const baseQuery = `${hybridFields} => [KNN ${k} @${this.vectorKey} $vector AS ${vectorScoreField}]`;\n\n    // Include custom schema fields in return fields\n    const returnFields = [this.metadataKey, this.contentKey, vectorScoreField];\n    if (this.customSchema) {\n      for (const fieldName of Object.keys(this.customSchema)) {\n        returnFields.push(`${this.metadataKey}.${fieldName}`);\n      }\n    }\n\n    const options: SearchOptions = {\n      PARAMS: {\n        vector: this.getFloat32Buffer(query),\n      },\n      RETURN: returnFields,\n      SORTBY: vectorScoreField,\n      DIALECT: 2,\n      LIMIT: {\n        from: 0,\n        size: k,\n      },\n    };\n\n    return [baseQuery, options];\n  }\n\n  private prepareFilter(filter: RedisVectorStoreFilterType) {\n    if (Array.isArray(filter)) {\n      return filter.map(this.escapeSpecialChars).join(\"|\");\n    }\n    return filter;\n  }\n\n  /**\n   * Escapes all '-', ':', and '\"' characters.\n   * RediSearch considers these all as special characters, so we need\n   * to escape them\n   * @see https://redis.io/docs/stack/search/reference/query_syntax\n   *\n   * @param str\n   * @returns\n   */\n  private escapeSpecialChars(str: string) {\n    return str\n      .replaceAll(\"-\", \"\\\\-\")\n      .replaceAll(\":\", \"\\\\:\")\n      .replaceAll(`\"`, `\\\\\"`);\n  }\n\n  /**\n   * Unescapes all '-', ':', and '\"' characters, returning the original string\n   *\n   * @param str\n   * @returns\n   */\n  private unEscapeSpecialChars(str: string) {\n    return str\n      .replaceAll(\"\\\\-\", \"-\")\n      .replaceAll(\"\\\\:\", \":\")\n      .replaceAll(`\\\\\"`, `\"`);\n  }\n\n  /**\n   * Converts the vector to the buffer Redis needs to\n   * correctly store an embedding\n   *\n   * @param vector\n   * @returns Buffer\n   */\n  private getFloat32Buffer(vector: number[]) {\n    return Buffer.from(new Float32Array(vector).buffer);\n  }\n}\n"],"mappings":";;;;;;;;;;AAwHA,IAAa,mBAAb,MAAa,yBAAyB,YAAY;CAGhD,AAAQ;CAIR;CAEA;CAEA;CAEA;CAEA;CAEA;CAEA;CAEA;CAEA;CAEA;CAEA,mBAA2B;AACzB,SAAO;CACR;;;;;;CAOD,AAAQ,iBAAiBA,UAAyC;AAChE,MAAI,CAAC,KAAK,aACR;AAGF,OAAK,MAAM,CAAC,WAAW,YAAY,IAAI,OAAO,QAAQ,KAAK,aAAa,EAAE;GACxE,MAAM,QAAQ,SAAS;AAGvB,OAAI,YAAY,aAAa,UAAU,UAAa,UAAU,MAC5D,OAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,UAAU,YAAY,CAAC;AAIrE,OAAI,UAAU,UAAa,UAAU,KACnC;AAIF,WAAQ,YAAY,MAApB;IACE,KAAK,iBAAiB;AACpB,SAAI,OAAO,UAAU,SACnB,OAAM,IAAI,MACR,CAAC,gBAAgB,EAAE,UAAU,wBAAwB,EAAE,OAAO,OAAO;AAGzE;IACF,KAAK,iBAAiB;AACpB,SAAI,OAAO,UAAU,YAAY,CAAC,MAAM,QAAQ,MAAM,CACpD,OAAM,IAAI,MACR,CAAC,gBAAgB,EAAE,UAAU,iCAAiC,EAAE,OAAO,OAAO;AAGlF;IACF,KAAK,iBAAiB;AACpB,SAAI,OAAO,UAAU,SACnB,OAAM,IAAI,MACR,CAAC,gBAAgB,EAAE,UAAU,wBAAwB,EAAE,OAAO,OAAO;AAGzE;IACF,QAEE;GACH;EACF;CACF;CAED,YACEC,YACAC,WACA;EACA,MAAM,YAAY,UAAU;EAE5B,KAAK,cAAc,UAAU;EAC7B,KAAK,YAAY,UAAU;EAC3B,KAAK,eAAe,UAAU,gBAAgB;GAC5C,WAAW,iBAAiB;GAC5B,iBAAiB;EAClB;EACD,KAAK,YAAY,UAAU,aAAa,CAAC,IAAI,EAAE,KAAK,UAAU,CAAC,CAAC;EAChE,KAAK,aAAa,UAAU,cAAc;EAC1C,KAAK,cAAc,UAAU,eAAe;EAC5C,KAAK,YAAY,UAAU,aAAa;EACxC,KAAK,SAAS,UAAU;EACxB,KAAK,MAAM,UAAU;EACrB,KAAK,eAAe,UAAU;EAC9B,KAAK,qBAAqB;GACxB,IAAI;GACJ,QAAQ,KAAK;GACb,GAAI,UAAU;EACf;CACF;;;;;;;;CASD,MAAM,aAAaC,WAAuBC,SAA2B;EACnE,MAAM,QAAQ,UAAU,IAAI,CAAC,EAAE,aAAa,KAAK,YAAY;AAC7D,SAAO,KAAK,WACV,MAAM,KAAK,WAAW,eAAe,MAAM,EAC3C,WACA,QACD;CACF;;;;;;;;;;;CAYD,MAAM,WACJC,SACAF,WACA,EAAE,MAAM,YAAY,KAAuB,GAAG,CAAE,GAChD;AACA,MAAI,CAAC,QAAQ,UAAU,CAAC,QAAQ,GAAG,OACjC,OAAM,IAAI,MAAM;EAGlB,MAAM,KAAK,YAAY,QAAQ,GAAG,OAAO;EAEzC,MAAM,OAAO,MAAM,KAAK,YAAY,GAAG,KAAK,KAAK,UAAU;EAC3D,MAAM,eACJ,SACE,KAAK,WAEH,KAAK,UACP,GACD,IAAI;AAGP,MAAI,KAAK,aACP,MAAK,IAAI,MAAM,GAAG,MAAM,UAAU,QAAQ,OAAO,GAAG;GAClD,MAAM,WACJ,UAAU,QAAQ,UAAU,KAAK,WAC7B,UAAU,KAAK,WACf,CAAE;GACR,KAAK,iBAAiB,SAAS;EAChC;EAGH,MAAM,QAAQ,KAAK,YAAY,OAAO;EAEtC,MAAM,QAAQ,IACZ,QAAQ,IAAI,OAAO,QAAQ,QAAQ;GACjC,MAAM,MACJ,QAAQ,KAAK,SACT,KAAK,OACL,GAAG,KAAK,YAAY,MAAM,cAAc;GAC9C,MAAM,WACJ,UAAU,QAAQ,UAAU,KAAK,WAC7B,UAAU,KAAK,WACf,CAAE;GAGR,MAAMG,aAA8C;KACjD,KAAK,YAAY,KAAK,iBAAiB,OAAO;KAC9C,KAAK,aAAa,UAAU,KAAK;KACjC,KAAK,cAAc,KAAK,mBAAmB,KAAK,UAAU,SAAS,CAAC;GACtE;AAGD,OAAI,KAAK,aACP,MAAK,MAAM,CAAC,WAAW,YAAY,IAAI,OAAO,QAC5C,KAAK,aACN,EAAE;IACD,MAAM,aAAa,SAAS;AAC5B,QAAI,eAAe,UAAa,eAAe,MAAM;KACnD,MAAM,mBAAmB,GAAG,KAAK,YAAY,CAAC,EAAE,WAAW;AAG3D,SACE,YAAY,SAAS,iBAAiB,OACtC,MAAM,QAAQ,WAAW,EACzB;MAEA,MAAM,YAAY,YAAY,aAAa;MAC3C,WAAW,oBAAoB,WAAW,KAAK,UAAU;KAC1D,OAEC,WAAW,oBAAoB;IAElC;GACF;GAGH,MAAM,KAAK,KAAK,WAAW;AAE3B,OAAI,KAAK,KACP,MAAM,OAAO,KAAK,KAAK,IAAI;AAI7B,OAAI,MAAM,cAAc,GACtB,MAAM,MAAM,MAAM;EAErB,EAAC,CACH;EAGD,MAAM,MAAM,MAAM;CACnB;;;;;;;;;CAUD,MAAM,gCACJC,OACAC,GACAC,QAC+B;AAC/B,MAAI,UAAU,KAAK,OACjB,OAAM,IAAI,MAAM;EAGlB,MAAM,UAAU,UAAU,KAAK;EAC/B,MAAM,UAAU,MAAM,KAAK,YAAY,GAAG,OACxC,KAAK,WACL,GAAG,KAAK,WAAW,OAAO,GAAG,QAAQ,CACtC;EACD,MAAMC,SAA+B,CAAE;AAEvC,MAAI,QAAQ,OACV;QAAK,MAAM,OAAO,QAAQ,UACxB,KAAI,IAAI,OAAO;IACb,MAAM,WAAW,IAAI;AACrB,QAAI,SAAS,cACX,OAAO,KAAK,CACV,IAAI,SAAS;KACX,aAAc,SAAS,KAAK,eAAe;KAC3C,UAAU,KAAK,MACb,KAAK,qBACF,SAAS,YAAY,KACvB,CACF;IACF,IACD,OAAO,SAAS,aAAa,AAC9B,EAAC;GAEL;EACF;AAGH,SAAO;CACR;;;;;;;;;CAUD,MAAM,2CACJH,OACAC,GACAG,gBAC+B;EAC/B,MAAM,UAAU,MAAM,KAAK,YAAY,GAAG,OACxC,KAAK,WACL,GAAG,KAAK,iBAAiB,OAAO,GAAG,eAAe,CACnD;EACD,MAAMD,SAA+B,CAAE;AAEvC,MAAI,QAAQ,OACV;QAAK,MAAM,OAAO,QAAQ,UACxB,KAAI,IAAI,OAAO;IACb,MAAM,WAAW,IAAI;AACrB,QAAI,SAAS,cAAc;KAEzB,IAAIV,WAAoC,CAAE;AAC1C,SAAI;MACF,WAAW,KAAK,MACd,KAAK,qBAAsB,SAAS,YAAY,KAAgB,CACjE;KACF,QAAO;MAEN,WAAW,CAAE;KACd;AAGD,SAAI,KAAK,aACP,MAAK,MAAM,aAAa,OAAO,KAAK,KAAK,aAAa,EAAE;MACtD,MAAM,WAAW,GAAG,KAAK,YAAY,CAAC,EAAE,WAAW;AACnD,UAAI,SAAS,cAAc,QACzB,SAAS,aAAa,SAAS;KAElC;KAGH,OAAO,KAAK,CACV,IAAI,SAAS;MACX,aAAc,SAAS,KAAK,eAAe;MAC3C;KACD,IACD,OAAO,SAAS,aAAa,AAC9B,EAAC;IACH;GACF;EACF;AAGH,SAAO;CACR;;;;;;;;;;;;CAaD,OAAO,UACLY,OACAC,WACAZ,YACAa,UACAC,aAC2B;EAC3B,MAAMC,OAAmB,CAAE;AAC3B,OAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG;GACxC,MAAM,WAAW,MAAM,QAAQ,UAAU,GAAG,UAAU,KAAK;GAC3D,MAAM,SAAS,IAAI,SAAS;IAC1B,aAAa,MAAM;IACnB;GACD;GACD,KAAK,KAAK,OAAO;EAClB;AACD,SAAO,iBAAiB,cACtB,MACA,YACA,UACA,YACD;CACF;;;;;;;;;;CAWD,aAAa,cACXA,MACAf,YACAa,UACAC,aAC2B;EAC3B,MAAM,WAAW,IAAI,KAAK,YAAY;EACtC,MAAM,SAAS,aAAa,MAAM,YAAY;AAC9C,SAAO;CACR;;;;;CAMD,MAAM,mBAAmB;AACvB,MAAI;GACF,MAAM,KAAK,YAAY,GAAG,KAAK,KAAK,UAAU;EAC/C,SAAQ,KAAK;AAEZ,OAAK,KAAa,QAAQ,SAAS,kBAAkB,CACnD,OAAM,IAAI,MACR;AAIJ,UAAO;EACR;AAED,SAAO;CACR;;;;;;;CAQD,MAAM,YAAY,aAAa,MAAqB;AAClD,MAAI,MAAM,KAAK,kBAAkB,CAC/B;EAGF,MAAME,SAA2B;IAC9B,KAAK,YAAY;IAChB,MAAM,iBAAiB;IACvB,MAAM;IACN,KAAK;IACL,GAAG,KAAK;GACT;IACA,KAAK,aAAa,iBAAiB;IACnC,KAAK,cAAc,iBAAiB;EACtC;AAGD,MAAI,KAAK,aACP,MAAK,MAAM,CAAC,WAAW,YAAY,IAAI,OAAO,QAC5C,KAAK,aACN,EAAE;GAED,MAAM,mBAAmB,GAAG,KAAK,YAAY,CAAC,EAAE,WAAW;AAG3D,OAAI,YAAY,SAAS,iBAAiB,KACxC,OAAO,oBAAoB;IACzB,MAAM,iBAAiB;IACvB,UAAU,YAAY,WAAW,OAAO;IACxC,WAAY,YAAY,aAAwB;GACjD;YACQ,YAAY,SAAS,iBAAiB,SAC/C,OAAO,oBAAoB;IACzB,MAAM,iBAAiB;IACvB,UAAU,YAAY,WAAW,OAAO;GACzC;YACQ,YAAY,SAAS,iBAAiB,MAC/C,OAAO,oBAAoB;IACzB,MAAM,iBAAiB;IACvB,UAAU,YAAY,WAAW,OAAO;GACzC;QAGD,OAAO,oBAAoB,YAAY;EAE1C;EAGH,MAAM,KAAK,YAAY,GAAG,OACxB,KAAK,WACL,QACA,KAAK,mBACN;CACF;;;;;;CAOD,MAAM,UAAUC,iBAA6C;AAC3D,MAAI;GACF,MAAM,UAAU,kBAAkB,EAAE,IAAI,gBAAiB,IAAG;GAC5D,MAAM,KAAK,YAAY,GAAG,UAAU,KAAK,WAAW,QAAQ;AAE5D,UAAO;EACR,QAAO;AACN,UAAO;EACR;CACF;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BD,MAAM,OACJC,QACe;AACf,MAAI,eAAe,UAAU,OAAO,WAClC,MAAM,KAAK,UAAU,KAAK;WACjB,SAAS,UAAU,OAAO,OAAO,OAAO,IAAI,SAAS,GAAG;GACjE,MAAM,OAAO,OAAO,IAAI,IAAI,CAAC,OAAO,GAAG,KAAK,YAAY,IAAI,CAAC;GAE7D,MAAM,KAAK,YAAY,IAAI,KAAK;EACjC,MACC,OAAM,IAAI,MAAM,CAAC,sCAAsC,CAAC;CAE3D;CAED,AAAQ,WACNZ,OACAC,GACAC,QACyB;EACzB,MAAM,mBAAmB;EAEzB,IAAI,eAAe;AAEnB,MAAI,UAAU,OAAO,QAGnB,eAAe,CAAC,CAAC,EAAE,KAAK,YAAY,EAAE,EAAE,KAAK,cAAc,OAAO,CAAC,CAAC,CAAC;EAGvE,MAAM,YAAY,GAAG,aAAa,SAAS,EAAE,EAAE,EAAE,EAAE,KAAK,UAAU,YAAY,EAAE,iBAAiB,CAAC,CAAC;EAGnG,MAAM,eAAe;GAAC,KAAK;GAAa,KAAK;GAAY;EAAiB;AAC1E,MAAI,KAAK,aACP,MAAK,MAAM,aAAa,OAAO,KAAK,KAAK,aAAa,EACpD,aAAa,KAAK,GAAG,KAAK,YAAY,CAAC,EAAE,WAAW,CAAC;EAIzD,MAAMW,UAAyB;GAC7B,QAAQ,EACN,QAAQ,KAAK,iBAAiB,MAAM,CACrC;GACD,QAAQ;GACR,QAAQ;GACR,SAAS;GACT,OAAO;IACL,MAAM;IACN,MAAM;GACP;EACF;AAED,SAAO,CAAC,WAAW,OAAQ;CAC5B;;;;;;;;CASD,iBACEb,OACAC,GACAG,gBACyB;EACzB,MAAM,mBAAmB;EAEzB,IAAI,eAAe;AAGnB,MAAI,kBAAkB,KAAK,cAAc;GACvC,MAAMU,gBAA0B,CAAE;AAElC,QAAK,MAAM,CAAC,WAAW,MAAM,IAAI,OAAO,QAAQ,eAAe,CAC7D,KAAI,KAAK,aAAa,YAAY;IAChC,MAAM,cAAc,KAAK,aAAa;IACtC,MAAM,mBAAmB,GAAG,KAAK,YAAY,CAAC,EAAE,WAAW;AAE3D,QAAI,YAAY,SAAS,iBAAiB,QAExC,KAAI,OAAO,UAAU,YAAY,UAAU,MACzC;SAAI,SAAS,SAAS,SAAS,OAC7B,cAAc,KACZ,CAAC,CAAC,EAAE,iBAAiB,EAAE,EAAE,MAAM,IAAI,CAAC,EAAE,MAAM,IAAI,CAAC,CAAC,CACnD;cACQ,SAAS,OAClB,cAAc,KAAK,CAAC,CAAC,EAAE,iBAAiB,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,CAAC;cACrD,SAAS,OAClB,cAAc,KAAK,CAAC,CAAC,EAAE,iBAAiB,OAAO,EAAE,MAAM,IAAI,CAAC,CAAC,CAAC;IAC/D,OAGD,cAAc,KAAK,CAAC,CAAC,EAAE,iBAAiB,EAAE,EAAE,MAAM,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;aAEvD,YAAY,SAAS,iBAAiB,IAE/C,KAAI,MAAM,QAAQ,MAAM,EAAE;KACxB,MAAM,YAAY,MAAM,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI;KACtD,cAAc,KAAK,CAAC,CAAC,EAAE,iBAAiB,EAAE,EAAE,UAAU,CAAC,CAAC,CAAC;IAC1D,OACC,cAAc,KAAK,CAAC,CAAC,EAAE,iBAAiB,EAAE,EAAE,MAAM,CAAC,CAAC,CAAC;aAE9C,YAAY,SAAS,iBAAiB,MAE/C,cAAc,KAAK,CAAC,CAAC,EAAE,iBAAiB,EAAE,EAAE,MAAM,CAAC,CAAC,CAAC;GAExD;AAGH,OAAI,cAAc,SAAS,GACzB,eAAe,cAAc,KAAK,IAAI;EAEzC;EAED,MAAM,YAAY,GAAG,aAAa,SAAS,EAAE,EAAE,EAAE,EAAE,KAAK,UAAU,YAAY,EAAE,iBAAiB,CAAC,CAAC;EAGnG,MAAM,eAAe;GAAC,KAAK;GAAa,KAAK;GAAY;EAAiB;AAC1E,MAAI,KAAK,aACP,MAAK,MAAM,aAAa,OAAO,KAAK,KAAK,aAAa,EACpD,aAAa,KAAK,GAAG,KAAK,YAAY,CAAC,EAAE,WAAW,CAAC;EAIzD,MAAMD,UAAyB;GAC7B,QAAQ,EACN,QAAQ,KAAK,iBAAiB,MAAM,CACrC;GACD,QAAQ;GACR,QAAQ;GACR,SAAS;GACT,OAAO;IACL,MAAM;IACN,MAAM;GACP;EACF;AAED,SAAO,CAAC,WAAW,OAAQ;CAC5B;CAED,AAAQ,cAAcE,QAAoC;AACxD,MAAI,MAAM,QAAQ,OAAO,CACvB,QAAO,OAAO,IAAI,KAAK,mBAAmB,CAAC,KAAK,IAAI;AAEtD,SAAO;CACR;;;;;;;;;;CAWD,AAAQ,mBAAmBC,KAAa;AACtC,SAAO,IACJ,WAAW,KAAK,MAAM,CACtB,WAAW,KAAK,MAAM,CACtB,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;CAC1B;;;;;;;CAQD,AAAQ,qBAAqBA,KAAa;AACxC,SAAO,IACJ,WAAW,OAAO,IAAI,CACtB,WAAW,OAAO,IAAI,CACtB,WAAW,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;CAC1B;;;;;;;;CASD,AAAQ,iBAAiBC,QAAkB;AACzC,SAAO,OAAO,KAAK,IAAI,aAAa,QAAQ,OAAO;CACpD;AACF"}