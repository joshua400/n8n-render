{"version":3,"file":"gemini.js","names":["settings?: DefaultGeminiSafetySettings","response: GoogleLLMResponse","data: GenerateContentResponseData","settings?: MessageGeminiSafetySettings","str: string","url: string","mimeTypeMap: Record<string, string>","config: GoogleSpeechConfig | GoogleSpeechConfigSimplified | undefined","config: GoogleSpeechConfig | GoogleSpeechConfigSimplified","config","config: GoogleSpeechConfigSimplified","config: GoogleSpeechSimplifiedLanguage","languageCode: string | undefined","voice: GoogleSpeechVoice","ret: GoogleSpeechConfig","voices: GoogleSpeechSpeakerName[]","speakerVoiceConfigs: GoogleSpeakerVoiceConfig[]","v: GoogleSpeechSpeakerName","config?: GeminiAPIConfig","content: MessageContentText","content: MessageContentImageUrl","blob: MediaBlob","uri: string","content: Record<string, any>","content: MessageContentImageUrl | Record<string, any>","ret: GeminiPartInlineData | GeminiPartFileData","content: MessageContentReasoning","standardContentBlockConverter: StandardContentBlockConverter<{\n    text: GeminiPartText;\n    image: GeminiPartFileData | GeminiPartInlineData;\n    audio: GeminiPartFileData | GeminiPartInlineData;\n    file: GeminiPartFileData | GeminiPartInlineData | GeminiPartText;\n  }>","content: MessageContentComplex","content: MessageContentComplex[]","content: MessageContent","messageContent: MessageContentComplex[]","parts: GeminiPart[]","acc: GeminiPart[]","val: GeminiPart | null | undefined","toolCalls: ToolCall[]","tool: ToolCall","kwargs: Record<string, unknown>","ret: GeminiPart[]","role: GeminiRole","message: BaseMessage","contentParts: GeminiPart[]","toolParts: GeminiPart[]","signatures: string[]","message: SystemMessage","message: ToolMessage","prevMessage: BaseMessage","acc: string","content: ContentBlock","prevMessage: BaseMessage | undefined","part: GeminiPartText","part: GeminiPartInlineData","part: GeminiPartFileData","part: GeminiPart","raw: ToolCallRaw","part: GeminiPartFunctionCall","uuidv4","raws: ToolCallRaw[]","acc: GenerateContentResponseData","val: GenerateContentResponseData","ret: string","responseTo: (response: GoogleLLMResponse) => RetType","result: GeminiLogprobsResultCandidate","candidate: GeminiResponseCandidate","logprobs: GeminiLogprobsResult","chosenTokens: GeminiLogprobsResultCandidate[]","topTokens: GeminiLogprobsTopCandidate[]","content: Logprob[]","logprob: Logprob","modalityTokenCounts: ModalityTokenCount[]","details: InputTokenDetails | OutputTokenDetails","modalityLc: keyof ModalitiesTokenDetails","input_token_details: InputTokenDetails","output_token_details: OutputTokenDetails","ret: UsageMetadata","ret: Record<string, any>","chunk: BaseMessageChunk","generationInfo: Record<string, any>","groundingSupports?: GeminiGroundingSupport[]","ret: GeminiGroundingSupport[][]","gen: ChatGeneration[]","forceComplex: boolean","ret: ContentBlock[]","item: ChatGeneration","message: AIMessageChunk","ret: Record<string, unknown>","generations: ChatGeneration[]","gen: GenerationTypes","combinedContent: MessageContent","_response: GoogleLLMResponse","content: ChatGeneration[]","reasoning: ChatGeneration[]","fields: AIMessageChunkFields","e: any","input: MessageContent | BaseMessage[]","firstItem: BaseMessage | MessageContentComplex","input: MessageContent","_parameters: GoogleAIModelParams","contents: GeminiContent[]","input: BaseMessage[]","inputPromises: Promise<GeminiContent[]>[]","parameters: GoogleAIModelRequestParams","ret: GeminiGenerationConfig","attribute: keyof GeminiGenerationConfig","tool: StructuredToolParams","tool: GeminiTool","tools: GoogleAIToolType[] | undefined","langChainTools: StructuredToolParams[]","otherTools: GeminiTool[]","result: GeminiTool[]","input: unknown","ret: GeminiRequest","params: GoogleAIModelParams","modelName: string"],"sources":["../../src/utils/gemini.ts"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport {\n  ContentBlock,\n  AIMessage,\n  AIMessageChunk,\n  AIMessageChunkFields,\n  BaseMessage,\n  BaseMessageChunk,\n  BaseMessageFields,\n  MessageContent,\n  MessageContentComplex,\n  MessageContentImageUrl,\n  MessageContentText,\n  type StandardContentBlockConverter,\n  SystemMessage,\n  ToolMessage,\n  UsageMetadata,\n  isAIMessage,\n  parseBase64DataUrl,\n  isDataContentBlock,\n  convertToProviderContentBlock,\n  InputTokenDetails,\n  OutputTokenDetails,\n  ModalitiesTokenDetails,\n  HumanMessage,\n} from \"@langchain/core/messages\";\nimport {\n  ChatGeneration,\n  ChatGenerationChunk,\n  ChatResult,\n} from \"@langchain/core/outputs\";\nimport { StructuredToolParams } from \"@langchain/core/tools\";\nimport { isLangChainTool } from \"@langchain/core/utils/function_calling\";\nimport { concat } from \"@langchain/core/utils/stream\";\nimport {\n  GoogleLLMResponse,\n  GoogleAIModelParams,\n  GeminiPartText,\n  GeminiPartInlineData,\n  GeminiPartFileData,\n  GeminiPart,\n  GeminiRole,\n  GeminiContent,\n  GenerateContentResponseData,\n  GoogleAISafetyHandler,\n  GeminiPartFunctionCall,\n  GoogleAIAPI,\n  GeminiAPIConfig,\n  GeminiGroundingSupport,\n  GeminiResponseCandidate,\n  GeminiLogprobsResult,\n  GeminiLogprobsResultCandidate,\n  GeminiLogprobsTopCandidate,\n  ModalityTokenCount,\n  GeminiUrlContextMetadata,\n  GoogleSpeechConfig,\n  GoogleSpeechConfigSimplified,\n  GoogleSpeechSimplifiedLanguage,\n  GoogleSpeechVoiceLanguage,\n  GoogleSpeechVoice,\n  GoogleSpeechSpeakerName,\n  GoogleSpeakerVoiceConfig,\n  GeminiFunctionDeclaration,\n  GeminiGenerationConfig,\n  GeminiRequest,\n  GeminiSafetySetting,\n  GeminiTool,\n  GoogleAIModelRequestParams,\n  GoogleAIToolType,\n  GeminiSearchToolAttributes,\n} from \"../types.js\";\nimport { GoogleAISafetyError } from \"./safety.js\";\nimport { MediaBlob } from \"../experimental/utils/media_core.js\";\nimport { schemaToGeminiParameters } from \"./zod_to_gemini_parameters.js\";\n\nexport interface FunctionCall {\n  name: string;\n  arguments: string;\n}\n\nexport interface ToolCall {\n  id: string;\n  type: \"function\";\n  function: FunctionCall;\n}\n\nexport interface FunctionCallRaw {\n  name: string;\n  arguments: object;\n}\n\nexport interface ToolCallRaw {\n  id: string;\n  type: \"function\";\n  function: FunctionCallRaw;\n}\n\nexport interface DefaultGeminiSafetySettings {\n  errorFinish?: string[];\n}\n\nexport class DefaultGeminiSafetyHandler implements GoogleAISafetyHandler {\n  errorFinish = [\"SAFETY\", \"RECITATION\", \"OTHER\"];\n\n  constructor(settings?: DefaultGeminiSafetySettings) {\n    this.errorFinish = settings?.errorFinish ?? this.errorFinish;\n  }\n\n  handleDataPromptFeedback(\n    response: GoogleLLMResponse,\n    data: GenerateContentResponseData\n  ): GenerateContentResponseData {\n    // Check to see if our prompt was blocked in the first place\n    const promptFeedback = data?.promptFeedback;\n    const blockReason = promptFeedback?.blockReason;\n    if (blockReason) {\n      throw new GoogleAISafetyError(response, `Prompt blocked: ${blockReason}`);\n    }\n    return data;\n  }\n\n  handleDataFinishReason(\n    response: GoogleLLMResponse,\n    data: GenerateContentResponseData\n  ): GenerateContentResponseData {\n    const firstCandidate = data?.candidates?.[0];\n    const finishReason = firstCandidate?.finishReason;\n    if (this.errorFinish.includes(finishReason)) {\n      throw new GoogleAISafetyError(response, `Finish reason: ${finishReason}`);\n    }\n    return data;\n  }\n\n  handleData(\n    response: GoogleLLMResponse,\n    data: GenerateContentResponseData\n  ): GenerateContentResponseData {\n    let ret = data;\n    ret = this.handleDataPromptFeedback(response, ret);\n    ret = this.handleDataFinishReason(response, ret);\n    return ret;\n  }\n\n  handle(response: GoogleLLMResponse): GoogleLLMResponse {\n    let newdata;\n\n    if (\"nextChunk\" in response.data) {\n      // TODO: This is a stream. How to handle?\n      newdata = response.data;\n    } else if (Array.isArray(response.data)) {\n      // If it is an array, try to handle every item in the array\n      try {\n        newdata = response.data.map((item) => this.handleData(response, item));\n      } catch (xx) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (xx instanceof GoogleAISafetyError) {\n          throw new GoogleAISafetyError(response, xx.message);\n        } else {\n          throw xx;\n        }\n      }\n    } else {\n      const data = response.data as GenerateContentResponseData;\n      newdata = this.handleData(response, data);\n    }\n\n    return {\n      ...response,\n      data: newdata,\n    };\n  }\n}\n\nexport interface MessageGeminiSafetySettings\n  extends DefaultGeminiSafetySettings {\n  msg?: string;\n  forceNewMessage?: boolean;\n}\n\nexport class MessageGeminiSafetyHandler extends DefaultGeminiSafetyHandler {\n  msg: string = \"\";\n\n  forceNewMessage = false;\n\n  constructor(settings?: MessageGeminiSafetySettings) {\n    super(settings);\n    this.msg = settings?.msg ?? this.msg;\n    this.forceNewMessage = settings?.forceNewMessage ?? this.forceNewMessage;\n  }\n\n  setMessage(data: GenerateContentResponseData): GenerateContentResponseData {\n    const ret = data;\n    if (\n      this.forceNewMessage ||\n      !data?.candidates?.[0]?.content?.parts?.length\n    ) {\n      ret.candidates = data.candidates ?? [];\n      ret.candidates[0] = data.candidates[0] ?? {};\n      ret.candidates[0].content = data.candidates[0].content ?? {};\n      ret.candidates[0].content = {\n        role: \"model\",\n        parts: [{ text: this.msg }],\n      };\n    }\n    return ret;\n  }\n\n  handleData(\n    response: GoogleLLMResponse,\n    data: GenerateContentResponseData\n  ): GenerateContentResponseData {\n    try {\n      return super.handleData(response, data);\n    } catch {\n      return this.setMessage(data);\n    }\n  }\n}\n\nconst extractMimeType = (\n  str: string\n): { mimeType: string; data: string } | null => {\n  if (str.startsWith(\"data:\")) {\n    return {\n      mimeType: str.split(\":\")[1].split(\";\")[0],\n      data: str.split(\",\")[1],\n    };\n  }\n  return null;\n};\n\n/**\n * Infers the MIME type from a URL based on its file extension.\n * This is used as a fallback when the MIME type is not provided.\n *\n * @param url - The URL to infer the MIME type from\n * @returns The inferred MIME type or undefined if it cannot be determined\n */\nfunction inferMimeTypeFromUrl(url: string): string | undefined {\n  const mimeTypeMap: Record<string, string> = {\n    jpg: \"image/jpeg\",\n    jpeg: \"image/jpeg\",\n    png: \"image/png\",\n    gif: \"image/gif\",\n    webp: \"image/webp\",\n    bmp: \"image/bmp\",\n    svg: \"image/svg+xml\",\n    ico: \"image/x-icon\",\n    tiff: \"image/tiff\",\n    tif: \"image/tiff\",\n  };\n\n  try {\n    // Extract the pathname from the URL\n    const pathname = new URL(url).pathname;\n    // Get the file extension (handle query params and fragments)\n    const extension = pathname.split(\".\").pop()?.toLowerCase().split(/[?#]/)[0];\n    return extension ? mimeTypeMap[extension] : undefined;\n  } catch {\n    // If URL parsing fails, try a simple extension extraction\n    const match = url.match(/\\.([a-zA-Z0-9]+)(?:[?#]|$)/);\n    if (match) {\n      const extension = match[1].toLowerCase();\n      return mimeTypeMap[extension];\n    }\n    return undefined;\n  }\n}\n\nexport function normalizeSpeechConfig(\n  config: GoogleSpeechConfig | GoogleSpeechConfigSimplified | undefined\n): GoogleSpeechConfig | undefined {\n  function isSpeechConfig(\n    config: GoogleSpeechConfig | GoogleSpeechConfigSimplified\n  ): config is GoogleSpeechConfig {\n    return (\n      typeof config === \"object\" &&\n      (Object.hasOwn(config, \"voiceConfig\") ||\n        Object.hasOwn(config, \"multiSpeakerVoiceConfig\"))\n    );\n  }\n\n  function hasLanguage(\n    config: GoogleSpeechConfigSimplified\n  ): config is GoogleSpeechSimplifiedLanguage {\n    return typeof config === \"object\" && Object.hasOwn(config, \"languageCode\");\n  }\n\n  function hasVoice(\n    config: GoogleSpeechSimplifiedLanguage\n  ): config is GoogleSpeechVoiceLanguage {\n    return Object.hasOwn(config, \"voice\");\n  }\n\n  if (typeof config === \"undefined\") {\n    return undefined;\n  }\n\n  // If this is already a GoogleSpeechConfig, just return it\n  if (isSpeechConfig(config)) {\n    return config;\n  }\n\n  let languageCode: string | undefined;\n  let voice: GoogleSpeechVoice;\n  if (hasLanguage(config)) {\n    languageCode = config.languageCode;\n    voice = hasVoice(config) ? config.voice : config.voices;\n  } else {\n    languageCode = undefined;\n    voice = config;\n  }\n\n  let ret: GoogleSpeechConfig;\n\n  if (typeof voice === \"string\") {\n    // They just provided the prebuilt voice configuration name. Use it.\n    ret = {\n      voiceConfig: {\n        prebuiltVoiceConfig: {\n          voiceName: voice,\n        },\n      },\n    };\n  } else {\n    // This is multi-speaker, so we have speaker/name pairs\n    // If we have just one (why?), turn it into an array for the moment\n    const voices: GoogleSpeechSpeakerName[] = Array.isArray(voice)\n      ? voice\n      : [voice];\n    // Go through all the speaker/name pairs and turn this into the voice config array\n    const speakerVoiceConfigs: GoogleSpeakerVoiceConfig[] = voices.map(\n      (v: GoogleSpeechSpeakerName): GoogleSpeakerVoiceConfig => ({\n        speaker: v.speaker,\n        voiceConfig: {\n          prebuiltVoiceConfig: {\n            voiceName: v.name,\n          },\n        },\n      })\n    );\n    // Create the multi-speaker voice configuration\n    ret = {\n      multiSpeakerVoiceConfig: {\n        speakerVoiceConfigs,\n      },\n    };\n  }\n\n  if (languageCode) {\n    ret.languageCode = languageCode;\n  }\n\n  return ret;\n}\n\nexport function getGeminiAPI(config?: GeminiAPIConfig): GoogleAIAPI {\n  function messageContentText(\n    content: MessageContentText\n  ): GeminiPartText | null {\n    if (content?.text && content?.text.length > 0) {\n      return {\n        text: content.text,\n      };\n    } else {\n      return null;\n    }\n  }\n\n  function messageContentImageUrlData(\n    content: MessageContentImageUrl\n  ): GeminiPartInlineData | GeminiPartFileData {\n    const url: string =\n      typeof content.image_url === \"string\"\n        ? content.image_url\n        : content.image_url.url;\n    if (!url) {\n      throw new Error(\"Missing Image URL\");\n    }\n\n    const mimeTypeAndData = extractMimeType(url);\n    if (mimeTypeAndData) {\n      return {\n        inlineData: mimeTypeAndData,\n      };\n    } else {\n      // Infer MIME type from URL extension\n      const mimeType = inferMimeTypeFromUrl(url) || \"image/png\";\n      return {\n        fileData: {\n          mimeType,\n          fileUri: url,\n        },\n      };\n    }\n  }\n\n  function messageContentImageUrl(\n    content: MessageContentImageUrl\n  ): GeminiPartInlineData | GeminiPartFileData {\n    const ret = messageContentImageUrlData(content);\n    supplementVideoMetadata(content, ret);\n    return ret;\n  }\n\n  async function blobToFileData(blob: MediaBlob): Promise<GeminiPartFileData> {\n    return {\n      fileData: {\n        fileUri: blob.path!,\n        mimeType: blob.mimetype,\n      },\n    };\n  }\n\n  async function fileUriContentToBlob(\n    uri: string\n  ): Promise<MediaBlob | undefined> {\n    return config?.mediaManager?.getMediaBlob(uri);\n  }\n\n  async function messageContentMediaData(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    content: Record<string, any>\n  ): Promise<GeminiPartInlineData | GeminiPartFileData> {\n    if (\"mimeType\" in content && \"data\" in content) {\n      return {\n        inlineData: {\n          mimeType: content.mimeType,\n          data: content.data,\n        },\n      };\n    } else if (\"mimeType\" in content && \"fileUri\" in content) {\n      return {\n        fileData: {\n          mimeType: content.mimeType,\n          fileUri: content.fileUri,\n        },\n      };\n    } else {\n      const uri = content.fileUri;\n      const blob = await fileUriContentToBlob(uri);\n      if (blob) {\n        return await blobToFileData(blob);\n      }\n    }\n\n    throw new Error(\n      `Invalid media content: ${JSON.stringify(content, null, 1)}`\n    );\n  }\n\n  function supplementVideoMetadata(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    content: MessageContentImageUrl | Record<string, any>,\n    ret: GeminiPartInlineData | GeminiPartFileData\n  ): GeminiPartInlineData | GeminiPartFileData {\n    // Add videoMetadata if defined\n    if (\"videoMetadata\" in content && typeof ret === \"object\") {\n      ret.videoMetadata = content.videoMetadata;\n    }\n    return ret;\n  }\n\n  async function messageContentMedia(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    content: Record<string, any>\n  ): Promise<GeminiPartInlineData | GeminiPartFileData> {\n    const ret = await messageContentMediaData(content);\n    supplementVideoMetadata(content, ret);\n    return ret;\n  }\n\n  function messageContentReasoning(\n    content: MessageContentReasoning\n  ): GeminiPartText | null {\n    if (content?.reasoning && content?.reasoning.length > 0) {\n      return {\n        text: content.reasoning,\n        thought: true,\n      };\n    } else {\n      return null;\n    }\n  }\n\n  const standardContentBlockConverter: StandardContentBlockConverter<{\n    text: GeminiPartText;\n    image: GeminiPartFileData | GeminiPartInlineData;\n    audio: GeminiPartFileData | GeminiPartInlineData;\n    file: GeminiPartFileData | GeminiPartInlineData | GeminiPartText;\n  }> = {\n    providerName: \"Google Gemini\",\n\n    fromStandardTextBlock(block) {\n      return {\n        text: block.text,\n      };\n    },\n\n    fromStandardImageBlock(block): GeminiPartFileData | GeminiPartInlineData {\n      if (block.source_type === \"url\") {\n        const data = parseBase64DataUrl({ dataUrl: block.url });\n        if (data) {\n          return {\n            inlineData: {\n              mimeType: data.mime_type,\n              data: data.data,\n            },\n          };\n        } else {\n          // Infer MIME type from URL if not provided\n          let mimeType = block.mime_type;\n          if (!mimeType || mimeType === \"\") {\n            mimeType = inferMimeTypeFromUrl(block.url) || \"image/png\";\n          }\n          return {\n            fileData: {\n              mimeType,\n              fileUri: block.url,\n            },\n          };\n        }\n      }\n\n      if (block.source_type === \"base64\") {\n        return {\n          inlineData: {\n            mimeType: block.mime_type || \"image/png\",\n            data: block.data,\n          },\n        };\n      }\n\n      throw new Error(`Unsupported source type: ${block.source_type}`);\n    },\n\n    fromStandardAudioBlock(block): GeminiPartFileData | GeminiPartInlineData {\n      if (block.source_type === \"url\") {\n        const data = parseBase64DataUrl({ dataUrl: block.url });\n        if (data) {\n          return {\n            inlineData: {\n              mimeType: data.mime_type,\n              data: data.data,\n            },\n          };\n        } else {\n          return {\n            fileData: {\n              mimeType: block.mime_type || \"audio/mpeg\",\n              fileUri: block.url,\n            },\n          };\n        }\n      }\n\n      if (block.source_type === \"base64\") {\n        return {\n          inlineData: {\n            mimeType: block.mime_type || \"audio/mpeg\",\n            data: block.data,\n          },\n        };\n      }\n\n      throw new Error(`Unsupported source type: ${block.source_type}`);\n    },\n\n    fromStandardFileBlock(\n      block\n    ): GeminiPartFileData | GeminiPartInlineData | GeminiPartText {\n      if (block.source_type === \"text\") {\n        return {\n          text: block.text,\n        };\n      }\n      if (block.source_type === \"url\") {\n        const data = parseBase64DataUrl({ dataUrl: block.url });\n        if (data) {\n          return {\n            inlineData: {\n              mimeType: data.mime_type,\n              data: data.data,\n            },\n          };\n        } else {\n          return {\n            fileData: {\n              mimeType: block.mime_type || \"application/octet-stream\",\n              fileUri: block.url,\n            },\n          };\n        }\n      }\n\n      if (block.source_type === \"base64\") {\n        return {\n          inlineData: {\n            mimeType: block.mime_type || \"application/octet-stream\",\n            data: block.data,\n          },\n        };\n      }\n      throw new Error(`Unsupported source type: ${block.source_type}`);\n    },\n  };\n\n  async function messageContentComplexToPart(\n    content: MessageContentComplex\n  ): Promise<GeminiPart | null> {\n    switch (content.type) {\n      case \"text\":\n        if (\"text\" in content) {\n          return messageContentText(content as MessageContentText);\n        }\n        break;\n      case \"image_url\":\n        if (\"image_url\" in content) {\n          // Type guard for MessageContentImageUrl\n          return messageContentImageUrl(content as MessageContentImageUrl);\n        }\n        break;\n      case \"media\":\n        return await messageContentMedia(content);\n      case \"reasoning\":\n        return messageContentReasoning(content as MessageContentReasoning);\n      default:\n        throw new Error(\n          `Unsupported type \"${\n            content.type\n          }\" received while converting message to message parts: ${JSON.stringify(\n            content\n          )}`\n        );\n    }\n    throw new Error(\n      `Cannot coerce \"${content.type}\" message part into a string.`\n    );\n  }\n\n  async function messageContentComplexToParts(\n    content: MessageContentComplex[]\n  ): Promise<(GeminiPart | null)[]> {\n    const contents = content.map((m) =>\n      isDataContentBlock(m)\n        ? convertToProviderContentBlock(m, standardContentBlockConverter)\n        : messageContentComplexToPart(m)\n    );\n    return Promise.all(contents);\n  }\n\n  async function messageContentToParts(\n    content: MessageContent\n  ): Promise<GeminiPart[]> {\n    // Convert a string to a text type MessageContent if needed\n    const messageContent: MessageContentComplex[] =\n      typeof content === \"string\"\n        ? [\n            {\n              type: \"text\",\n              text: content,\n            },\n          ]\n        : content;\n\n    // Get all of the parts, even those that don't correctly resolve\n    const allParts = await messageContentComplexToParts(messageContent);\n\n    // Remove any invalid parts\n    const parts: GeminiPart[] = allParts.reduce(\n      (acc: GeminiPart[], val: GeminiPart | null | undefined) => {\n        if (val) {\n          return [...acc, val];\n        } else {\n          return acc;\n        }\n      },\n      []\n    );\n\n    return parts;\n  }\n\n  function messageToolCallsToParts(toolCalls: ToolCall[]): GeminiPart[] {\n    if (!toolCalls || toolCalls.length === 0) {\n      return [];\n    }\n\n    return toolCalls.map((tool: ToolCall) => {\n      let args = {};\n      if (tool?.function?.arguments) {\n        const argStr = tool.function.arguments;\n        args = JSON.parse(argStr);\n      }\n      return {\n        functionCall: {\n          name: tool.function.name,\n          args,\n        },\n      };\n    });\n  }\n\n  function messageKwargsToParts(kwargs: Record<string, unknown>): GeminiPart[] {\n    const ret: GeminiPart[] = [];\n\n    if (kwargs?.tool_calls) {\n      ret.push(...messageToolCallsToParts(kwargs.tool_calls as ToolCall[]));\n    }\n\n    return ret;\n  }\n\n  async function roleMessageToContent(\n    role: GeminiRole,\n    message: BaseMessage\n  ): Promise<GeminiContent[]> {\n    const contentParts: GeminiPart[] = await messageContentToParts(\n      message.content\n    );\n    let toolParts: GeminiPart[];\n    if (isAIMessage(message) && !!message.tool_calls?.length) {\n      toolParts = message.tool_calls.map(\n        (toolCall): GeminiPart => ({\n          functionCall: {\n            name: toolCall.name,\n            args: toolCall.args,\n          },\n        })\n      );\n    } else {\n      toolParts = messageKwargsToParts(message.additional_kwargs);\n    }\n    const parts: GeminiPart[] = [...contentParts, ...toolParts];\n\n    const signatures: string[] =\n      (message?.additional_kwargs?.signatures as string[]) ?? [];\n    if (signatures.length === parts.length) {\n      for (let co = 0; co < signatures.length; co += 1) {\n        const signature = signatures[co];\n        if (signature && signature.length > 0) {\n          parts[co].thoughtSignature = signature;\n        }\n      }\n    }\n\n    return [\n      {\n        role,\n        parts,\n      },\n    ];\n  }\n\n  async function systemMessageToContent(\n    message: SystemMessage\n  ): Promise<GeminiContent[]> {\n    return config?.useSystemInstruction\n      ? roleMessageToContent(\"system\", message)\n      : [\n          ...(await roleMessageToContent(\"user\", message)),\n          ...(await roleMessageToContent(\"model\", new AIMessage(\"Ok\"))),\n        ];\n  }\n\n  function toolMessageToContent(\n    message: ToolMessage,\n    prevMessage: BaseMessage\n  ): GeminiContent[] {\n    const contentStr =\n      typeof message.content === \"string\"\n        ? message.content\n        : (message.content as ContentBlock[]).reduce(\n            (acc: string, content: ContentBlock) => {\n              if (content.type === \"text\") {\n                return acc + content.text;\n              } else {\n                return acc;\n              }\n            },\n            \"\"\n          );\n    // Hacky :(\n    const responseName =\n      (isAIMessage(prevMessage) && !!prevMessage.tool_calls?.length\n        ? prevMessage.tool_calls[0].name\n        : prevMessage.name) ?? message.tool_call_id;\n    try {\n      const content = JSON.parse(contentStr);\n      return [\n        {\n          role: \"function\",\n          parts: [\n            {\n              functionResponse: {\n                name: responseName,\n                response: { content },\n              },\n            },\n          ],\n        },\n      ];\n    } catch (_) {\n      return [\n        {\n          role: \"function\",\n          parts: [\n            {\n              functionResponse: {\n                name: responseName,\n                response: { content: contentStr },\n              },\n            },\n          ],\n        },\n      ];\n    }\n  }\n\n  async function baseMessageToContent(\n    message: BaseMessage,\n    prevMessage: BaseMessage | undefined\n  ): Promise<GeminiContent[]> {\n    if (SystemMessage.isInstance(message)) {\n      return systemMessageToContent(message);\n    } else if (HumanMessage.isInstance(message)) {\n      return roleMessageToContent(\"user\", message);\n    } else if (AIMessage.isInstance(message)) {\n      return roleMessageToContent(\"model\", message);\n    } else if (ToolMessage.isInstance(message)) {\n      if (!prevMessage) {\n        throw new Error(\n          \"Tool messages cannot be the first message passed to the model.\"\n        );\n      }\n      return toolMessageToContent(message, prevMessage);\n    } else {\n      console.log(`Unsupported message type: ${message.type}`);\n      return [];\n    }\n  }\n\n  type MessageContentReasoning = {\n    type: \"reasoning\";\n    reasoning: string;\n  };\n\n  function thoughtPartToMessageContent(\n    part: GeminiPartText\n  ): MessageContentReasoning {\n    return {\n      type: \"reasoning\",\n      reasoning: part.text,\n    };\n  }\n\n  function textPartToMessageContent(part: GeminiPartText): MessageContentText {\n    return {\n      type: \"text\",\n      text: part.text,\n    };\n  }\n\n  function inlineDataPartToMessageContentImage(\n    part: GeminiPartInlineData\n  ): MessageContentImageUrl {\n    return {\n      type: \"image_url\",\n      image_url: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`,\n    };\n  }\n\n  function inlineDataPartToMessageContentMedia(\n    part: GeminiPartInlineData\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Record<string, any> {\n    return {\n      type: \"media\",\n      mimeType: part.inlineData.mimeType,\n      data: part.inlineData.data,\n    };\n  }\n\n  function inlineDataPartToMessageContent(\n    part: GeminiPartInlineData\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): MessageContentImageUrl | Record<string, any> {\n    const mimeType = part?.inlineData?.mimeType ?? \"\";\n    if (mimeType.startsWith(\"image\")) {\n      return inlineDataPartToMessageContentImage(part);\n    } else {\n      return inlineDataPartToMessageContentMedia(part);\n    }\n  }\n\n  function fileDataPartToMessageContent(\n    part: GeminiPartFileData\n  ): MessageContentImageUrl {\n    return {\n      type: \"image_url\",\n      image_url: part.fileData.fileUri,\n    };\n  }\n\n  function partsToMessageContent(parts: GeminiPart[]): MessageContent {\n    return parts\n      .map((part: GeminiPart): ContentBlock | null => {\n        if (part === undefined || part === null) {\n          return null;\n        } else if (part.thought) {\n          return thoughtPartToMessageContent(part as GeminiPartText);\n        } else if (\"text\" in part) {\n          return textPartToMessageContent(part);\n        } else if (\"inlineData\" in part) {\n          return inlineDataPartToMessageContent(part) as ContentBlock;\n        } else if (\"fileData\" in part) {\n          return fileDataPartToMessageContent(part);\n        } else {\n          return null;\n        }\n      })\n      .reduce((acc, content) => {\n        if (content) {\n          acc.push(content);\n        }\n        return acc;\n      }, [] as ContentBlock[]);\n  }\n\n  function toolRawToTool(raw: ToolCallRaw): ToolCall {\n    return {\n      id: raw.id,\n      type: raw.type,\n      function: {\n        name: raw.function.name,\n        arguments: JSON.stringify(raw.function.arguments),\n      },\n    };\n  }\n\n  function functionCallPartToToolRaw(\n    part: GeminiPartFunctionCall\n  ): ToolCallRaw {\n    return {\n      id: uuidv4().replace(/-/g, \"\"),\n      type: \"function\",\n      function: {\n        name: part.functionCall.name,\n        arguments: part.functionCall.args ?? {},\n      },\n    };\n  }\n\n  function partsToToolsRaw(parts: GeminiPart[]): ToolCallRaw[] {\n    return parts\n      .map((part: GeminiPart) => {\n        if (part === undefined || part === null) {\n          return null;\n        } else if (\"functionCall\" in part) {\n          return functionCallPartToToolRaw(part);\n        } else {\n          return null;\n        }\n      })\n      .reduce((acc, content) => {\n        if (content) {\n          acc.push(content);\n        }\n        return acc;\n      }, [] as ToolCallRaw[]);\n  }\n\n  function toolsRawToTools(raws: ToolCallRaw[]): ToolCall[] {\n    return raws.map((raw) => toolRawToTool(raw));\n  }\n\n  function responseToGenerateContentResponseData(\n    response: GoogleLLMResponse\n  ): GenerateContentResponseData {\n    if (\"nextChunk\" in response.data) {\n      throw new Error(\"Cannot convert Stream to GenerateContentResponseData\");\n    } else if (Array.isArray(response.data)) {\n      // Collapse the array of response data as if it was a single one\n      return response.data.reduce(\n        (\n          acc: GenerateContentResponseData,\n          val: GenerateContentResponseData\n        ): GenerateContentResponseData => {\n          // Add all the parts\n          // FIXME: Handle other candidates?\n          const valParts = val?.candidates?.[0]?.content?.parts ?? [];\n          acc.candidates[0].content.parts.push(...valParts);\n\n          // FIXME: Merge promptFeedback and safety settings\n          acc.promptFeedback = val.promptFeedback;\n          return acc;\n        }\n      );\n    } else {\n      return response.data as GenerateContentResponseData;\n    }\n  }\n\n  function responseToParts(response: GoogleLLMResponse): GeminiPart[] {\n    const responseData = responseToGenerateContentResponseData(response);\n    const parts = responseData?.candidates?.[0]?.content?.parts ?? [];\n    return parts;\n  }\n\n  function partToText(part: GeminiPart): string {\n    return \"text\" in part ? part.text : \"\";\n  }\n\n  function responseToString(response: GoogleLLMResponse): string {\n    const parts = responseToParts(response);\n    const ret: string = parts.reduce((acc, part) => {\n      const val = partToText(part);\n      return acc + val;\n    }, \"\");\n    return ret;\n  }\n\n  function safeResponseTo<RetType>(\n    response: GoogleLLMResponse,\n    responseTo: (response: GoogleLLMResponse) => RetType\n  ): RetType {\n    const safetyHandler =\n      config?.safetyHandler ?? new DefaultGeminiSafetyHandler();\n    try {\n      const safeResponse = safetyHandler.handle(response);\n      return responseTo(safeResponse);\n    } catch (xx) {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (xx instanceof GoogleAISafetyError) {\n        const ret = responseTo(xx.response);\n        xx.reply = ret;\n      }\n      throw xx;\n    }\n  }\n\n  function safeResponseToString(response: GoogleLLMResponse): string {\n    return safeResponseTo(response, responseToString);\n  }\n\n  type Logprob = {\n    token: string;\n    logprob: number;\n    bytes: number[];\n    top_logprobs?: Omit<Logprob, \"top_logprobs\">[];\n  };\n\n  type LogprobContent = {\n    content: Logprob[];\n  };\n\n  function logprobResultToLogprob(\n    result: GeminiLogprobsResultCandidate\n  ): Omit<Logprob, \"top_logprobs\"> {\n    const token = result?.token;\n    const logprob = result?.logProbability;\n    const encoder = new TextEncoder();\n    const bytes = Array.from(encoder.encode(token));\n    return {\n      token,\n      logprob,\n      bytes,\n    };\n  }\n\n  function candidateToLogprobs(\n    candidate: GeminiResponseCandidate\n  ): LogprobContent | undefined {\n    const logprobs: GeminiLogprobsResult = candidate?.logprobsResult;\n    const chosenTokens: GeminiLogprobsResultCandidate[] =\n      logprobs?.chosenCandidates ?? [];\n    const topTokens: GeminiLogprobsTopCandidate[] =\n      logprobs?.topCandidates ?? [];\n    const content: Logprob[] = [];\n    for (let co = 0; co < chosenTokens.length; co += 1) {\n      const chosen = chosenTokens[co];\n      const top = topTokens[co]?.candidates ?? [];\n      const logprob: Logprob = logprobResultToLogprob(chosen);\n      logprob.top_logprobs = top.map((l) => logprobResultToLogprob(l));\n      content.push(logprob);\n    }\n    return {\n      content,\n    };\n  }\n\n  function candidateToUrlContextMetadata(\n    candidate: GeminiResponseCandidate\n  ): GeminiUrlContextMetadata | undefined {\n    const retrieval =\n      candidate?.urlRetrievalMetadata?.urlRetrievalContexts ?? [];\n    const context = candidate?.urlContextMetadata?.urlMetadata ?? [];\n    const all = [...retrieval, ...context];\n    if (all.length === 0) {\n      return undefined;\n    } else {\n      return {\n        urlMetadata: all,\n      };\n    }\n  }\n\n  function addModalityCounts(\n    modalityTokenCounts: ModalityTokenCount[],\n    details: InputTokenDetails | OutputTokenDetails\n  ): void {\n    modalityTokenCounts?.forEach((modalityTokenCount) => {\n      const { modality, tokenCount } = modalityTokenCount;\n      const modalityLc: keyof ModalitiesTokenDetails =\n        modality.toLowerCase() as keyof ModalitiesTokenDetails;\n      const currentCount = details[modalityLc] ?? 0;\n      details[modalityLc] = currentCount + tokenCount;\n    });\n  }\n\n  function responseToUsageMetadata(\n    response: GoogleLLMResponse\n  ): UsageMetadata | undefined {\n    if (\"usageMetadata\" in response.data) {\n      const data: GenerateContentResponseData = response?.data;\n      const usageMetadata = data?.usageMetadata;\n\n      const input_tokens = usageMetadata.promptTokenCount ?? 0;\n      const candidatesTokenCount = usageMetadata.candidatesTokenCount ?? 0;\n      const thoughtsTokenCount = usageMetadata.thoughtsTokenCount ?? 0;\n      const output_tokens = candidatesTokenCount + thoughtsTokenCount;\n      const total_tokens =\n        usageMetadata.totalTokenCount ?? input_tokens + output_tokens;\n\n      const input_token_details: InputTokenDetails = {};\n      addModalityCounts(usageMetadata.promptTokensDetails, input_token_details);\n      if (typeof usageMetadata?.cachedContentTokenCount === \"number\") {\n        input_token_details.cache_read = usageMetadata.cachedContentTokenCount;\n      }\n\n      const output_token_details: OutputTokenDetails = {};\n      addModalityCounts(\n        usageMetadata?.candidatesTokensDetails,\n        output_token_details\n      );\n      if (typeof usageMetadata?.thoughtsTokenCount === \"number\") {\n        output_token_details.reasoning = usageMetadata.thoughtsTokenCount;\n      }\n\n      const ret: UsageMetadata = {\n        input_tokens,\n        output_tokens,\n        total_tokens,\n        input_token_details,\n        output_token_details,\n      };\n      return ret;\n    }\n    return undefined;\n  }\n\n  function responseToGenerationInfo(response: GoogleLLMResponse) {\n    const data =\n      Array.isArray(response.data) && response.data[0]\n        ? response.data[0]\n        : response.data &&\n          (response.data as GenerateContentResponseData).candidates\n        ? (response.data as GenerateContentResponseData)\n        : undefined;\n    if (!data) {\n      return {};\n    }\n\n    const finish_reason = data.candidates[0]?.finishReason;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const ret: Record<string, any> = {\n      safety_ratings: data.candidates[0]?.safetyRatings?.map((rating) => ({\n        category: rating.category,\n        probability: rating.probability,\n        probability_score: rating.probabilityScore,\n        severity: rating.severity,\n        severity_score: rating.severityScore,\n      })),\n      citation_metadata: data.candidates[0]?.citationMetadata,\n      grounding_metadata: data.candidates[0]?.groundingMetadata,\n      finish_reason,\n      finish_message: data.candidates[0]?.finishMessage,\n      url_context_metadata: candidateToUrlContextMetadata(data.candidates[0]),\n      avgLogprobs: data.candidates[0]?.avgLogprobs,\n      logprobs: candidateToLogprobs(data.candidates[0]),\n    };\n\n    // Only add the usage_metadata on the last chunk\n    // sent while streaming (see issue 8102).\n    if (typeof finish_reason === \"string\") {\n      ret.usage_metadata = responseToUsageMetadata(response);\n    }\n\n    return ret;\n  }\n\n  function responseToChatGeneration(\n    response: GoogleLLMResponse\n  ): ChatGenerationChunk {\n    return new ChatGenerationChunk({\n      text: responseToString(response),\n      message: partToMessageChunk(responseToParts(response)[0]),\n      generationInfo: responseToGenerationInfo(response),\n    });\n  }\n\n  function safeResponseToChatGeneration(\n    response: GoogleLLMResponse\n  ): ChatGenerationChunk {\n    return safeResponseTo(response, responseToChatGeneration);\n  }\n\n  function chunkToString(chunk: BaseMessageChunk): string {\n    if (chunk === null) {\n      return \"\";\n    } else if (typeof chunk.content === \"string\") {\n      return chunk.content;\n    } else if (chunk.content.length === 0) {\n      return \"\";\n    } else if (chunk.content[0].type === \"text\") {\n      return chunk.content[0].text as string;\n    } else {\n      throw new Error(`Unexpected chunk: ${chunk}`);\n    }\n  }\n\n  function partToMessageChunk(part: GeminiPart): BaseMessageChunk {\n    const fields = partsToBaseMessageChunkFields([part]);\n    if (typeof fields.content === \"string\") {\n      return new AIMessageChunk(fields);\n    } else if (fields.content?.every((item) => item.type === \"text\")) {\n      const newContent = fields.content\n        .map((item) => (\"text\" in item ? item.text : \"\"))\n        .join(\"\");\n      return new AIMessageChunk({\n        ...fields,\n        content: newContent,\n        response_metadata: {\n          ...fields.response_metadata,\n          model_provider: \"google-vertexai\",\n        },\n      });\n    }\n    return new AIMessageChunk(fields);\n  }\n\n  function partToChatGeneration(part: GeminiPart): ChatGeneration {\n    const message = partToMessageChunk(part);\n    const text = partToText(part);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const generationInfo: Record<string, any> = {};\n\n    return new ChatGenerationChunk({\n      text,\n      message,\n      generationInfo,\n    });\n  }\n\n  function groundingSupportByPart(\n    groundingSupports?: GeminiGroundingSupport[]\n  ): GeminiGroundingSupport[][] {\n    const ret: GeminiGroundingSupport[][] = [];\n\n    if (!groundingSupports || groundingSupports.length === 0) {\n      return [];\n    }\n\n    groundingSupports?.forEach((groundingSupport) => {\n      const segment = groundingSupport?.segment;\n      const partIndex = segment?.partIndex ?? 0;\n      if (ret[partIndex]) {\n        ret[partIndex].push(groundingSupport);\n      } else {\n        ret[partIndex] = [groundingSupport];\n      }\n    });\n\n    return ret;\n  }\n\n  function responseToGroundedChatGenerations(\n    response: GoogleLLMResponse\n  ): ChatGeneration[] {\n    const parts = responseToParts(response);\n\n    if (parts.length === 0) {\n      return [];\n    }\n\n    // Citation and grounding information connected to each part / ChatGeneration\n    // to make sure they are available in downstream filters.\n    const candidate = (response?.data as GenerateContentResponseData)\n      ?.candidates?.[0];\n    const groundingMetadata = candidate?.groundingMetadata;\n    const citationMetadata = candidate?.citationMetadata;\n    const groundingParts = groundingSupportByPart(\n      groundingMetadata?.groundingSupports\n    );\n\n    const ret = parts.map((part, index) => {\n      const gen = partToChatGeneration(part);\n      if (!gen.generationInfo) {\n        gen.generationInfo = {};\n      }\n      if (groundingMetadata) {\n        gen.generationInfo.groundingMetadata = groundingMetadata;\n        const groundingPart = groundingParts[index];\n        if (groundingPart) {\n          gen.generationInfo.groundingSupport = groundingPart;\n        }\n      }\n      if (citationMetadata) {\n        gen.generationInfo.citationMetadata = citationMetadata;\n      }\n      return gen;\n    });\n\n    return ret;\n  }\n\n  type GenerationTypes = {\n    content: ChatGeneration[];\n    reasoning: ChatGeneration[];\n  };\n\n  function combineContent(\n    gen: ChatGeneration[],\n    forceComplex: boolean = false\n  ): MessageContent {\n    const allString = gen.every(\n      (item) => typeof item.message.content === \"string\"\n    );\n    if (allString && !forceComplex) {\n      // Everything is a string, and we don't want to force it to return\n      // MessageContentComplex[], so concatenate the content into one string\n      return gen.map((item) => item.message.content).join(\"\");\n    } else {\n      // We either have complex types, or we want to force them, so turn\n      // it into an array of complex types.\n      const ret: ContentBlock[] = [];\n      gen.forEach((item) => {\n        if (typeof item.message.content === \"string\") {\n          // If this is a string, turn it into a text type\n          ret.push({\n            type: \"text\",\n            text: item.message.content,\n          });\n        } else {\n          // Otherwise, add all the complex types to what we're returning\n          item.message.content.forEach((c) => {\n            ret.push(c);\n          });\n        }\n      });\n      return ret;\n    }\n  }\n\n  function combineText(gen: ChatGeneration[]): string {\n    return gen.map((item) => item.text ?? \"\").join(\"\");\n  }\n\n  /*\n   * We don't really need the entire AIMessageChunk here, but it is\n   * a conventient way to combine all the Tool Calling information.\n   */\n  function combineToolCalls(gen: ChatGeneration[]): AIMessageChunk {\n    let ret = new AIMessageChunk(\"\");\n\n    gen.forEach((item: ChatGeneration) => {\n      const message: AIMessageChunk = item?.message as AIMessageChunk;\n      ret = concat(ret, message);\n    });\n\n    return ret;\n  }\n\n  function combineAdditionalKwargs(\n    gen: ChatGeneration[]\n  ): Record<string, unknown> {\n    const ret: Record<string, unknown> = {};\n\n    gen.forEach((item: ChatGeneration) => {\n      const message: AIMessageChunk = item?.message as AIMessageChunk;\n      const kwargs = message?.additional_kwargs ?? {};\n      const keys = Object.keys(kwargs);\n      keys.forEach((key) => {\n        const value = kwargs[key];\n        if (\n          Object.hasOwn(ret, key) &&\n          Array.isArray(ret[key]) &&\n          Array.isArray(value)\n        ) {\n          (ret[key] as Array<unknown>).push(...value);\n        } else {\n          ret[key] = value;\n        }\n      });\n    });\n\n    return ret;\n  }\n\n  function combineGenerations(\n    generations: ChatGeneration[],\n    response: GoogleLLMResponse\n  ): ChatGeneration[] {\n    const gen: GenerationTypes = splitGenerationTypes(generations, response);\n    const combinedContent: MessageContent = combineContent(gen.content);\n    const combinedText = combineText(gen.content);\n    const combinedToolCalls = combineToolCalls(gen.content);\n    const kwargs = combineAdditionalKwargs(gen.content);\n    const lastContent = gen.content[gen.content.length - 1];\n\n    // Add usage metadata\n    const usage_metadata = responseToUsageMetadata(response);\n\n    // Add thinking / reasoning\n    // if (gen.reasoning && gen.reasoning.length > 0) {\n    //   kwargs.reasoning_content = combineContent(gen.reasoning, true);\n    // }\n\n    // Build the message and the generation chunk to return\n    const message = new AIMessageChunk({\n      content: combinedContent,\n      additional_kwargs: kwargs,\n      response_metadata: {\n        model_provider: \"google-vertexai\",\n      },\n      usage_metadata,\n      tool_calls: combinedToolCalls.tool_calls,\n      invalid_tool_calls: combinedToolCalls.invalid_tool_calls,\n    });\n    return [\n      new ChatGenerationChunk({\n        message,\n        text: combinedText,\n        generationInfo: lastContent.generationInfo,\n      }),\n    ];\n  }\n\n  function splitGenerationTypes(\n    generations: ChatGeneration[],\n    _response: GoogleLLMResponse\n  ): GenerationTypes {\n    const content: ChatGeneration[] = [];\n    const reasoning: ChatGeneration[] = [];\n\n    generations.forEach((gen) => {\n      if (gen?.generationInfo?.thought) {\n        reasoning.push(gen);\n      } else {\n        content.push(gen);\n      }\n    });\n\n    return {\n      content,\n      reasoning,\n    };\n  }\n\n  /**\n   * Although this returns an array, only the first (or maybe last)\n   * element in the array is used. So we need to combine them into\n   * just one element that contains everything we need.\n   * @param response\n   */\n  function responseToChatGenerations(\n    response: GoogleLLMResponse\n  ): ChatGeneration[] {\n    const generations = responseToGroundedChatGenerations(response);\n\n    if (generations.length === 0) {\n      return [];\n    }\n\n    const ret = combineGenerations(generations, response);\n\n    // Add logprobs information to the message\n    const candidate = (response?.data as GenerateContentResponseData)\n      ?.candidates?.[0];\n    const avgLogprobs = candidate?.avgLogprobs;\n    const logprobs = candidateToLogprobs(candidate);\n    if (logprobs) {\n      ret[0].message.response_metadata = {\n        model_provider: \"google-vertexai\",\n        ...ret[0].message.response_metadata,\n        logprobs,\n        avgLogprobs,\n      };\n    }\n\n    return ret;\n  }\n\n  function responseToBaseMessageFields(\n    response: GoogleLLMResponse\n  ): BaseMessageFields {\n    const parts = responseToParts(response);\n    return partsToBaseMessageChunkFields(parts);\n  }\n\n  function partsToSignatures(parts: GeminiPart[]): string[] {\n    return parts.map((part: GeminiPart) => part?.thoughtSignature ?? \"\");\n  }\n\n  function partsToBaseMessageChunkFields(\n    parts: GeminiPart[]\n  ): AIMessageChunkFields {\n    const fields: AIMessageChunkFields = {\n      content: partsToMessageContent(parts),\n      tool_call_chunks: [],\n      tool_calls: [],\n      invalid_tool_calls: [],\n      response_metadata: {\n        model_provider: \"google-vertexai\",\n      },\n    };\n    fields.additional_kwargs = {};\n\n    const rawTools = partsToToolsRaw(parts);\n    if (rawTools.length > 0) {\n      const tools = toolsRawToTools(rawTools);\n      for (const tool of tools) {\n        fields.tool_call_chunks?.push({\n          name: tool.function.name,\n          args: tool.function.arguments,\n          id: tool.id,\n          type: \"tool_call_chunk\",\n        });\n\n        try {\n          fields.tool_calls?.push({\n            name: tool.function.name,\n            args: JSON.parse(tool.function.arguments),\n            id: tool.id,\n          });\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e: any) {\n          fields.invalid_tool_calls?.push({\n            name: tool.function.name,\n            args: tool.function.arguments,\n            id: tool.id,\n            error: e.message,\n            type: \"invalid_tool_call\",\n          });\n        }\n      }\n      fields.additional_kwargs.tool_calls = tools;\n    }\n\n    fields.additional_kwargs.signatures = partsToSignatures(parts);\n\n    return fields;\n  }\n\n  function responseToBaseMessage(response: GoogleLLMResponse): BaseMessage {\n    const fields = responseToBaseMessageFields(response);\n    return new AIMessage(fields);\n  }\n\n  function safeResponseToBaseMessage(response: GoogleLLMResponse): BaseMessage {\n    return safeResponseTo(response, responseToBaseMessage);\n  }\n\n  function responseToChatResult(response: GoogleLLMResponse): ChatResult {\n    const generations = responseToChatGenerations(response);\n    return {\n      generations,\n      llmOutput: responseToGenerationInfo(response),\n    };\n  }\n\n  function safeResponseToChatResult(response: GoogleLLMResponse): ChatResult {\n    return safeResponseTo(response, responseToChatResult);\n  }\n\n  function inputType(\n    input: MessageContent | BaseMessage[]\n  ): \"MessageContent\" | \"BaseMessageArray\" {\n    if (typeof input === \"string\") {\n      return \"MessageContent\";\n    } else {\n      const firstItem: BaseMessage | MessageContentComplex = input[0];\n      if (Object.hasOwn(firstItem, \"content\")) {\n        return \"BaseMessageArray\";\n      } else {\n        return \"MessageContent\";\n      }\n    }\n  }\n\n  async function formatMessageContents(\n    input: MessageContent,\n    _parameters: GoogleAIModelParams\n  ): Promise<GeminiContent[]> {\n    const parts = await messageContentToParts!(input);\n    const contents: GeminiContent[] = [\n      {\n        role: \"user\", // Required by Vertex AI\n        parts,\n      },\n    ];\n    return contents;\n  }\n\n  async function formatBaseMessageContents(\n    input: BaseMessage[],\n    _parameters: GoogleAIModelParams\n  ): Promise<GeminiContent[]> {\n    const inputPromises: Promise<GeminiContent[]>[] = input.map((msg, i) =>\n      baseMessageToContent!(msg, input[i - 1])\n    );\n    const inputs = await Promise.all(inputPromises);\n\n    return inputs.reduce((acc, cur) => {\n      // Filter out the system content\n      if (cur.every((content) => content.role === \"system\")) {\n        return acc;\n      }\n\n      // Combine adjacent function messages\n      if (\n        cur[0]?.role === \"function\" &&\n        acc.length > 0 &&\n        acc[acc.length - 1].role === \"function\"\n      ) {\n        acc[acc.length - 1].parts = [\n          ...acc[acc.length - 1].parts,\n          ...cur[0].parts,\n        ];\n      } else {\n        acc.push(...cur);\n      }\n\n      return acc;\n    }, [] as GeminiContent[]);\n  }\n\n  async function formatContents(\n    input: MessageContent | BaseMessage[],\n    parameters: GoogleAIModelRequestParams\n  ): Promise<GeminiContent[]> {\n    const it = inputType(input);\n    switch (it) {\n      case \"MessageContent\":\n        return formatMessageContents(input as MessageContent, parameters);\n      case \"BaseMessageArray\":\n        return formatBaseMessageContents(input as BaseMessage[], parameters);\n      default:\n        throw new Error(`Unknown input type \"${it}\": ${input}`);\n    }\n  }\n\n  function formatGenerationConfig(\n    parameters: GoogleAIModelRequestParams\n  ): GeminiGenerationConfig {\n    const ret: GeminiGenerationConfig = {\n      temperature: parameters.temperature,\n      topK: parameters.topK,\n      topP: parameters.topP,\n      seed: parameters.seed,\n      presencePenalty: parameters.presencePenalty,\n      frequencyPenalty: parameters.frequencyPenalty,\n      maxOutputTokens: parameters.maxOutputTokens,\n      stopSequences: parameters.stopSequences,\n      responseMimeType: parameters.responseMimeType,\n      responseModalities: parameters.responseModalities,\n      speechConfig: normalizeSpeechConfig(parameters.speechConfig),\n    };\n\n    // Add the logprobs if explicitly set\n    if (typeof parameters.logprobs !== \"undefined\") {\n      ret.responseLogprobs = parameters.logprobs;\n      if (\n        parameters.logprobs &&\n        typeof parameters.topLogprobs !== \"undefined\"\n      ) {\n        ret.logprobs = parameters.topLogprobs;\n      }\n    }\n\n    // Add thinking configuration if explicitly set\n    // Note that you cannot have thinkingBudget set to 0 and includeThoughts true\n    if (typeof parameters.maxReasoningTokens !== \"undefined\") {\n      const includeThoughts = parameters.maxReasoningTokens !== 0;\n      ret.thinkingConfig = {\n        thinkingBudget: parameters.maxReasoningTokens,\n        includeThoughts,\n      };\n    }\n\n    // Remove any undefined properties, so we don't send them\n    let attribute: keyof GeminiGenerationConfig;\n    for (attribute in ret) {\n      if (ret[attribute] === undefined) {\n        delete ret[attribute];\n      }\n    }\n\n    return ret;\n  }\n\n  function formatSafetySettings(\n    parameters: GoogleAIModelRequestParams\n  ): GeminiSafetySetting[] {\n    return parameters.safetySettings ?? [];\n  }\n\n  async function formatBaseMessageSystemInstruction(\n    input: BaseMessage[]\n  ): Promise<GeminiContent> {\n    let ret = {} as GeminiContent;\n    for (let index = 0; index < input.length; index += 1) {\n      const message = input[index];\n      if (message.getType() === \"system\") {\n        // For system types, we only want it if it is the first message,\n        // if it appears anywhere else, it should be an error.\n        if (index === 0) {\n          ret = (await baseMessageToContent!(message, undefined))[0];\n        } else {\n          throw new Error(\n            \"System messages are only permitted as the first passed message.\"\n          );\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  async function formatSystemInstruction(\n    input: MessageContent | BaseMessage[]\n  ): Promise<GeminiContent> {\n    if (!config?.useSystemInstruction) {\n      return {} as GeminiContent;\n    }\n\n    const it = inputType(input);\n    switch (it) {\n      case \"BaseMessageArray\":\n        return formatBaseMessageSystemInstruction(input as BaseMessage[]);\n      default:\n        return {} as GeminiContent;\n    }\n  }\n\n  function structuredToolToFunctionDeclaration(\n    tool: StructuredToolParams\n  ): GeminiFunctionDeclaration {\n    const jsonSchema = schemaToGeminiParameters(tool.schema);\n    return {\n      name: tool.name,\n      description: tool.description ?? `A function available to call.`,\n      parameters: jsonSchema,\n    };\n  }\n\n  function searchToolName(tool: GeminiTool): string | undefined {\n    for (const name of GeminiSearchToolAttributes) {\n      if (name in tool) {\n        return name;\n      }\n    }\n    return undefined;\n  }\n\n  function cleanGeminiTool(tool: GeminiTool): GeminiTool {\n    const orig = searchToolName(tool);\n    const adj = config?.googleSearchToolAdjustment;\n    if (orig && adj && adj !== orig) {\n      return {\n        [adj as string]: {},\n      };\n    } else {\n      return tool;\n    }\n  }\n\n  function formatTools(parameters: GoogleAIModelRequestParams): GeminiTool[] {\n    const tools: GoogleAIToolType[] | undefined = parameters?.tools;\n    if (!tools || tools.length === 0) {\n      return [];\n    }\n\n    // Group all LangChain tools into a single functionDeclarations array.\n    // Gemini Tools may be normalized to different tool names\n    const langChainTools: StructuredToolParams[] = [];\n    const otherTools: GeminiTool[] = [];\n    tools.forEach((tool) => {\n      if (isLangChainTool(tool)) {\n        langChainTools.push(tool);\n      } else {\n        otherTools.push(cleanGeminiTool(tool as GeminiTool));\n      }\n    });\n\n    const result: GeminiTool[] = [...otherTools];\n\n    if (langChainTools.length > 0) {\n      result.push({\n        functionDeclarations: langChainTools.map(\n          structuredToolToFunctionDeclaration\n        ),\n      });\n    }\n\n    return result;\n  }\n\n  function formatToolConfig(\n    parameters: GoogleAIModelRequestParams\n  ): GeminiRequest[\"toolConfig\"] | undefined {\n    if (!parameters.tool_choice || typeof parameters.tool_choice !== \"string\") {\n      return undefined;\n    }\n\n    if ([\"auto\", \"any\", \"none\"].includes(parameters.tool_choice)) {\n      return {\n        functionCallingConfig: {\n          mode: parameters.tool_choice as \"auto\" | \"any\" | \"none\",\n          allowedFunctionNames: parameters.allowed_function_names,\n        },\n      };\n    }\n\n    // force tool choice to be a single function name in case of structured output\n    return {\n      functionCallingConfig: {\n        mode: \"any\",\n        allowedFunctionNames: [parameters.tool_choice],\n      },\n    };\n  }\n\n  async function formatData(\n    input: unknown,\n    parameters: GoogleAIModelRequestParams\n  ): Promise<GeminiRequest> {\n    const typedInput = input as MessageContent | BaseMessage[];\n    const contents = await formatContents(typedInput, parameters);\n    const generationConfig = formatGenerationConfig(parameters);\n    const tools = formatTools(parameters);\n    const toolConfig = formatToolConfig(parameters);\n    const safetySettings = formatSafetySettings(parameters);\n    const systemInstruction = await formatSystemInstruction(typedInput);\n\n    const ret: GeminiRequest = {\n      contents,\n      generationConfig,\n    };\n    if (tools && tools.length) {\n      ret.tools = tools;\n    }\n    if (toolConfig) {\n      ret.toolConfig = toolConfig;\n    }\n    if (safetySettings && safetySettings.length) {\n      ret.safetySettings = safetySettings;\n    }\n    if (\n      systemInstruction?.role &&\n      systemInstruction?.parts &&\n      systemInstruction?.parts?.length\n    ) {\n      ret.systemInstruction = systemInstruction;\n    }\n    if (parameters.cachedContent) {\n      ret.cachedContent = parameters.cachedContent;\n    }\n    if (parameters.labels && Object.keys(parameters.labels).length > 0) {\n      ret.labels = parameters.labels;\n    }\n    return ret;\n  }\n\n  return {\n    messageContentToParts,\n    baseMessageToContent,\n    responseToString: safeResponseToString,\n    responseToChatGeneration: safeResponseToChatGeneration,\n    chunkToString,\n    responseToBaseMessage: safeResponseToBaseMessage,\n    responseToChatResult: safeResponseToChatResult,\n    formatData,\n  };\n}\n\nexport function validateGeminiParams(params: GoogleAIModelParams): void {\n  if (params.maxOutputTokens && params.maxOutputTokens < 0) {\n    throw new Error(\"`maxOutputTokens` must be a positive integer\");\n  }\n  if (typeof params.maxReasoningTokens !== \"undefined\") {\n    if (typeof params.maxOutputTokens !== \"undefined\") {\n      if (params.maxReasoningTokens >= params.maxOutputTokens) {\n        throw new Error(\n          \"`maxOutputTokens` must be greater than `maxReasoningTokens`\"\n        );\n      }\n    }\n  }\n\n  if (\n    params.temperature &&\n    (params.temperature < 0 || params.temperature > 2)\n  ) {\n    throw new Error(\"`temperature` must be in the range of [0.0,2.0]\");\n  }\n\n  if (params.topP && (params.topP < 0 || params.topP > 1)) {\n    throw new Error(\"`topP` must be in the range of [0.0,1.0]\");\n  }\n\n  if (params.topK && params.topK < 0) {\n    throw new Error(\"`topK` must be a positive integer\");\n  }\n}\n\nexport function isModelGemini(modelName: string): boolean {\n  return modelName.toLowerCase().startsWith(\"gemini\");\n}\n\nexport function isModelGemma(modelName: string): boolean {\n  return modelName.toLowerCase().startsWith(\"gemma\");\n}\n"],"mappings":"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"}