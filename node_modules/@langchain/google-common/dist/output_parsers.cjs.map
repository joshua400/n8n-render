{"version":3,"file":"output_parsers.cjs","names":["BaseLLMOutputParser","generation: Generation | ChatGeneration","generations: Generations","content: MessageContent","text: string","grounding: GroundingInfo","support: GeminiGroundingSupport","index: number","_callbacks?: Callbacks","_grounding: GroundingInfo","_support: GeminiGroundingSupport","_index: number","indices: number[]","_text: string","chunk: GeminiGroundingChunk","chunks: GeminiGroundingChunk[]"],"sources":["../src/output_parsers.ts"],"sourcesContent":["import { BaseLLMOutputParser } from \"@langchain/core/output_parsers\";\nimport { Callbacks } from \"@langchain/core/callbacks/manager\";\nimport { ChatGeneration, Generation } from \"@langchain/core/outputs\";\nimport { MessageContent } from \"@langchain/core/messages\";\nimport {\n  GeminiGroundingChunk,\n  GeminiGroundingMetadata,\n  GeminiGroundingSupport,\n} from \"./types.js\";\n\ntype Generations = Generation[] | ChatGeneration[];\n\ntype GroundingInfo = {\n  metadata: GeminiGroundingMetadata;\n  supports: GeminiGroundingSupport[];\n};\n\nexport abstract class BaseGoogleSearchOutputParser extends BaseLLMOutputParser<string> {\n  lc_namespace: string[] = [\"google_common\", \"output_parsers\"];\n\n  protected generationToGroundingInfo(\n    generation: Generation | ChatGeneration\n  ): GroundingInfo | undefined {\n    if (\"message\" in generation) {\n      const responseMetadata = generation?.message?.response_metadata;\n      const metadata = responseMetadata?.groundingMetadata;\n      const supports =\n        responseMetadata?.groundingSupport ?? metadata?.groundingSupports ?? [];\n      if (metadata) {\n        return {\n          metadata,\n          supports,\n        };\n      }\n    }\n    return undefined;\n  }\n\n  protected generationsToGroundingInfo(\n    generations: Generations\n  ): GroundingInfo | undefined {\n    for (const generation of generations) {\n      const info = this.generationToGroundingInfo(generation);\n      if (info !== undefined) {\n        return info;\n      }\n    }\n    return undefined;\n  }\n\n  protected generationToString(\n    generation: Generation | ChatGeneration\n  ): string {\n    if (\"message\" in generation) {\n      const content: MessageContent = generation?.message?.content;\n      if (typeof content === \"string\") {\n        return content;\n      } else {\n        return content\n          .map((c) => {\n            if (c?.type === \"text\") {\n              return c?.text ?? \"\";\n            } else {\n              return \"\";\n            }\n          })\n          .reduce(\n            (previousValue, currentValue) => `${previousValue}${currentValue}`\n          );\n      }\n    }\n    return generation.text;\n  }\n\n  protected generationsToString(generations: Generations): string {\n    return generations\n      .map((generation) => this.generationToString(generation))\n      .reduce(\n        (previousValue, currentValue) => `${previousValue}${currentValue}`\n      );\n  }\n\n  protected abstract segmentPrefix(\n    grounding: GroundingInfo,\n    support: GeminiGroundingSupport,\n    index: number\n  ): string | undefined;\n\n  protected abstract segmentSuffix(\n    grounding: GroundingInfo,\n    support: GeminiGroundingSupport,\n    index: number\n  ): string | undefined;\n\n  protected annotateSegment(\n    text: string,\n    grounding: GroundingInfo,\n    support: GeminiGroundingSupport,\n    index: number\n  ): string {\n    const start = support.segment.startIndex ?? 0;\n    const end = support.segment.endIndex;\n\n    const textBefore = text.substring(0, start);\n    const textSegment = text.substring(start, end);\n    const textAfter = text.substring(end);\n\n    const textPrefix = this.segmentPrefix(grounding, support, index) ?? \"\";\n    const textSuffix = this.segmentSuffix(grounding, support, index) ?? \"\";\n\n    return `${textBefore}${textPrefix}${textSegment}${textSuffix}${textAfter}`;\n  }\n\n  protected annotateTextSegments(\n    text: string,\n    grounding: GroundingInfo\n  ): string {\n    // Go through each support info in reverse, since the segment info\n    // is sorted, and we won't need to adjust string indexes this way.\n    let ret = text;\n    for (let co = grounding.supports.length - 1; co >= 0; co -= 1) {\n      const support = grounding.supports[co];\n      ret = this.annotateSegment(ret, grounding, support, co);\n    }\n    return ret;\n  }\n\n  protected abstract textPrefix(\n    text: string,\n    grounding: GroundingInfo\n  ): string | undefined;\n\n  protected abstract textSuffix(\n    text: string,\n    grounding: GroundingInfo\n  ): string | undefined;\n\n  /**\n   * Google requires us to\n   * \"Display the Search Suggestion exactly as provided without any modifications\"\n   * So this will typically be called from the textSuffix() method to get\n   * a string that renders HTML.\n   * See https://ai.google.dev/gemini-api/docs/grounding/search-suggestions\n   * @param grounding\n   */\n  protected searchSuggestion(grounding: GroundingInfo): string {\n    return grounding?.metadata?.searchEntryPoint?.renderedContent ?? \"\";\n  }\n\n  protected annotateText(text: string, grounding: GroundingInfo): string {\n    const prefix = this.textPrefix(text, grounding) ?? \"\";\n    const suffix = this.textSuffix(text, grounding) ?? \"\";\n    const body = this.annotateTextSegments(text, grounding);\n    return `${prefix}${body}${suffix}`;\n  }\n\n  async parseResult(\n    generations: Generations,\n    _callbacks?: Callbacks\n  ): Promise<string> {\n    const text = this.generationsToString(generations);\n\n    const grounding = this.generationsToGroundingInfo(generations);\n    if (!grounding) {\n      return text;\n    }\n\n    return this.annotateText(text, grounding);\n  }\n}\n\nexport class SimpleGoogleSearchOutputParser extends BaseGoogleSearchOutputParser {\n  protected segmentPrefix(\n    _grounding: GroundingInfo,\n    _support: GeminiGroundingSupport,\n    _index: number\n  ): string | undefined {\n    return undefined;\n  }\n\n  protected segmentSuffix(\n    _grounding: GroundingInfo,\n    support: GeminiGroundingSupport,\n    _index: number\n  ): string | undefined {\n    const indices: number[] = support.groundingChunkIndices.map((i) => i + 1);\n    return ` [${indices.join(\", \")}]`;\n  }\n\n  protected textPrefix(_text: string, _grounding: GroundingInfo): string {\n    return \"Google Says:\\n\";\n  }\n\n  protected chunkToString(chunk: GeminiGroundingChunk, index: number): string {\n    const info = chunk.retrievedContext ?? chunk.web;\n    return `${index + 1}. ${info.title} - ${info.uri}`;\n  }\n\n  protected textSuffix(_text: string, grounding: GroundingInfo): string {\n    let ret = \"\\n\";\n    const chunks: GeminiGroundingChunk[] =\n      grounding?.metadata?.groundingChunks ?? [];\n    chunks.forEach((chunk, index) => {\n      ret = `${ret}${this.chunkToString(chunk, index)}\\n`;\n    });\n    return ret;\n  }\n}\n\nexport class MarkdownGoogleSearchOutputParser extends BaseGoogleSearchOutputParser {\n  protected segmentPrefix(\n    _grounding: GroundingInfo,\n    _support: GeminiGroundingSupport,\n    _index: number\n  ): string | undefined {\n    return undefined;\n  }\n\n  protected chunkLink(grounding: GroundingInfo, index: number): string {\n    const chunk = grounding.metadata.groundingChunks[index];\n    const url = chunk.retrievedContext?.uri ?? chunk.web?.uri;\n    const num = index + 1;\n    return `[[${num}](${url})]`;\n  }\n\n  protected segmentSuffix(\n    grounding: GroundingInfo,\n    support: GeminiGroundingSupport,\n    _index: number\n  ): string | undefined {\n    let ret = \"\";\n    support.groundingChunkIndices.forEach((chunkIndex) => {\n      const link = this.chunkLink(grounding, chunkIndex);\n      ret = `${ret}${link}`;\n    });\n    return ret;\n  }\n\n  protected textPrefix(\n    _text: string,\n    _grounding: GroundingInfo\n  ): string | undefined {\n    return undefined;\n  }\n\n  protected chunkSuffixLink(\n    chunk: GeminiGroundingChunk,\n    index: number\n  ): string {\n    const num = index + 1;\n    const info = chunk.retrievedContext ?? chunk.web;\n    const url = info.uri;\n    const site = info.title;\n    return `${num}. [${site}](${url})`;\n  }\n\n  protected textSuffix(\n    _text: string,\n    grounding: GroundingInfo\n  ): string | undefined {\n    let ret = \"\\n**Search Sources**\\n\";\n    const chunks: GeminiGroundingChunk[] = grounding.metadata.groundingChunks;\n    chunks.forEach((chunk, index) => {\n      ret = `${ret}${this.chunkSuffixLink(chunk, index)}\\n`;\n    });\n\n    const search = this.searchSuggestion(grounding);\n    ret = `${ret}\\n${search}`;\n\n    return ret;\n  }\n}\n"],"mappings":";;;;AAiBA,IAAsB,+BAAtB,cAA2DA,oDAA4B;CACrF,eAAyB,CAAC,iBAAiB,gBAAiB;CAE5D,AAAU,0BACRC,YAC2B;AAC3B,MAAI,aAAa,YAAY;GAC3B,MAAM,mBAAmB,YAAY,SAAS;GAC9C,MAAM,WAAW,kBAAkB;GACnC,MAAM,WACJ,kBAAkB,oBAAoB,UAAU,qBAAqB,CAAE;AACzE,OAAI,SACF,QAAO;IACL;IACA;GACD;EAEJ;AACD,SAAO;CACR;CAED,AAAU,2BACRC,aAC2B;AAC3B,OAAK,MAAM,cAAc,aAAa;GACpC,MAAM,OAAO,KAAK,0BAA0B,WAAW;AACvD,OAAI,SAAS,OACX,QAAO;EAEV;AACD,SAAO;CACR;CAED,AAAU,mBACRD,YACQ;AACR,MAAI,aAAa,YAAY;GAC3B,MAAME,UAA0B,YAAY,SAAS;AACrD,OAAI,OAAO,YAAY,SACrB,QAAO;OAEP,QAAO,QACJ,IAAI,CAAC,MAAM;AACV,QAAI,GAAG,SAAS,OACd,QAAO,GAAG,QAAQ;QAElB,QAAO;GAEV,EAAC,CACD,OACC,CAAC,eAAe,iBAAiB,GAAG,gBAAgB,cAAc,CACnE;EAEN;AACD,SAAO,WAAW;CACnB;CAED,AAAU,oBAAoBD,aAAkC;AAC9D,SAAO,YACJ,IAAI,CAAC,eAAe,KAAK,mBAAmB,WAAW,CAAC,CACxD,OACC,CAAC,eAAe,iBAAiB,GAAG,gBAAgB,cAAc,CACnE;CACJ;CAcD,AAAU,gBACRE,MACAC,WACAC,SACAC,OACQ;EACR,MAAM,QAAQ,QAAQ,QAAQ,cAAc;EAC5C,MAAM,MAAM,QAAQ,QAAQ;EAE5B,MAAM,aAAa,KAAK,UAAU,GAAG,MAAM;EAC3C,MAAM,cAAc,KAAK,UAAU,OAAO,IAAI;EAC9C,MAAM,YAAY,KAAK,UAAU,IAAI;EAErC,MAAM,aAAa,KAAK,cAAc,WAAW,SAAS,MAAM,IAAI;EACpE,MAAM,aAAa,KAAK,cAAc,WAAW,SAAS,MAAM,IAAI;AAEpE,SAAO,GAAG,aAAa,aAAa,cAAc,aAAa,WAAW;CAC3E;CAED,AAAU,qBACRH,MACAC,WACQ;EAGR,IAAI,MAAM;AACV,OAAK,IAAI,KAAK,UAAU,SAAS,SAAS,GAAG,MAAM,GAAG,MAAM,GAAG;GAC7D,MAAM,UAAU,UAAU,SAAS;GACnC,MAAM,KAAK,gBAAgB,KAAK,WAAW,SAAS,GAAG;EACxD;AACD,SAAO;CACR;;;;;;;;;CAoBD,AAAU,iBAAiBA,WAAkC;AAC3D,SAAO,WAAW,UAAU,kBAAkB,mBAAmB;CAClE;CAED,AAAU,aAAaD,MAAcC,WAAkC;EACrE,MAAM,SAAS,KAAK,WAAW,MAAM,UAAU,IAAI;EACnD,MAAM,SAAS,KAAK,WAAW,MAAM,UAAU,IAAI;EACnD,MAAM,OAAO,KAAK,qBAAqB,MAAM,UAAU;AACvD,SAAO,GAAG,SAAS,OAAO,QAAQ;CACnC;CAED,MAAM,YACJH,aACAM,YACiB;EACjB,MAAM,OAAO,KAAK,oBAAoB,YAAY;EAElD,MAAM,YAAY,KAAK,2BAA2B,YAAY;AAC9D,MAAI,CAAC,UACH,QAAO;AAGT,SAAO,KAAK,aAAa,MAAM,UAAU;CAC1C;AACF;AAED,IAAa,iCAAb,cAAoD,6BAA6B;CAC/E,AAAU,cACRC,YACAC,UACAC,QACoB;AACpB,SAAO;CACR;CAED,AAAU,cACRF,YACAH,SACAK,QACoB;EACpB,MAAMC,UAAoB,QAAQ,sBAAsB,IAAI,CAAC,MAAM,IAAI,EAAE;AACzE,SAAO,CAAC,EAAE,EAAE,QAAQ,KAAK,KAAK,CAAC,CAAC,CAAC;CAClC;CAED,AAAU,WAAWC,OAAeJ,YAAmC;AACrE,SAAO;CACR;CAED,AAAU,cAAcK,OAA6BP,OAAuB;EAC1E,MAAM,OAAO,MAAM,oBAAoB,MAAM;AAC7C,SAAO,GAAG,QAAQ,EAAE,EAAE,EAAE,KAAK,MAAM,GAAG,EAAE,KAAK,KAAK;CACnD;CAED,AAAU,WAAWM,OAAeR,WAAkC;EACpE,IAAI,MAAM;EACV,MAAMU,SACJ,WAAW,UAAU,mBAAmB,CAAE;EAC5C,OAAO,QAAQ,CAAC,OAAO,UAAU;GAC/B,MAAM,GAAG,MAAM,KAAK,cAAc,OAAO,MAAM,CAAC,EAAE,CAAC;EACpD,EAAC;AACF,SAAO;CACR;AACF;AAED,IAAa,mCAAb,cAAsD,6BAA6B;CACjF,AAAU,cACRN,YACAC,UACAC,QACoB;AACpB,SAAO;CACR;CAED,AAAU,UAAUN,WAA0BE,OAAuB;EACnE,MAAM,QAAQ,UAAU,SAAS,gBAAgB;EACjD,MAAM,MAAM,MAAM,kBAAkB,OAAO,MAAM,KAAK;EACtD,MAAM,MAAM,QAAQ;AACpB,SAAO,CAAC,EAAE,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,CAAC;CAC5B;CAED,AAAU,cACRF,WACAC,SACAK,QACoB;EACpB,IAAI,MAAM;EACV,QAAQ,sBAAsB,QAAQ,CAAC,eAAe;GACpD,MAAM,OAAO,KAAK,UAAU,WAAW,WAAW;GAClD,MAAM,GAAG,MAAM,MAAM;EACtB,EAAC;AACF,SAAO;CACR;CAED,AAAU,WACRE,OACAJ,YACoB;AACpB,SAAO;CACR;CAED,AAAU,gBACRK,OACAP,OACQ;EACR,MAAM,MAAM,QAAQ;EACpB,MAAM,OAAO,MAAM,oBAAoB,MAAM;EAC7C,MAAM,MAAM,KAAK;EACjB,MAAM,OAAO,KAAK;AAClB,SAAO,GAAG,IAAI,GAAG,EAAE,KAAK,EAAE,EAAE,IAAI,CAAC,CAAC;CACnC;CAED,AAAU,WACRM,OACAR,WACoB;EACpB,IAAI,MAAM;EACV,MAAMU,SAAiC,UAAU,SAAS;EAC1D,OAAO,QAAQ,CAAC,OAAO,UAAU;GAC/B,MAAM,GAAG,MAAM,KAAK,gBAAgB,OAAO,MAAM,CAAC,EAAE,CAAC;EACtD,EAAC;EAEF,MAAM,SAAS,KAAK,iBAAiB,UAAU;EAC/C,MAAM,GAAG,IAAI,EAAE,EAAE,QAAQ;AAEzB,SAAO;CACR;AACF"}