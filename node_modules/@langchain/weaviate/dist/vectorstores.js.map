{"version":3,"file":"vectorstores.js","names":["obj: Record<string, unknown>","flattenedObject: Record<string, unknown>","el: unknown","embeddings: EmbeddingsInterface","args: WeaviateLibArgs","config: WeaviateLibArgs & { dimensions?: number }","vectors: number[][]","documents: Document[]","options?: { ids?: string[] }","batch: DataObject<undefined>[]","params: {\n    ids?: string[];\n    filter?: FilterValue;\n  }","query: string","options?: HybridOptions<undefined>","query_vector: number[] | undefined","generate: GenerateOptions<undefined, GenerativeConfigRuntime | undefined>","options?: BaseHybridOptions<undefined>","query: number[]","k: number","filter?: FilterValue","documents: [Document, number, number, number[]][]","options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>","_callbacks?: undefined","queryEmbedding: number[]","allResults: [Document, number, number, number[]][]","texts: string[]","metadatas: object | object[]","docs: Document[]"],"sources":["../src/vectorstores.ts"],"sourcesContent":["import * as uuid from \"uuid\";\nimport {\n  HybridOptions,\n  CollectionConfigCreate,\n  configure,\n  type DataObject,\n  type FilterValue,\n  GenerateOptions,\n  GenerativeConfigRuntime,\n  Metadata,\n  Vectors,\n  WeaviateClient,\n  type WeaviateField,\n  BaseHybridOptions,\n  MetadataKeys,\n} from \"weaviate-client\";\nimport {\n  type MaxMarginalRelevanceSearchOptions,\n  VectorStore,\n} from \"@langchain/core/vectorstores\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { Document } from \"@langchain/core/documents\";\nimport { maximalMarginalRelevance } from \"@langchain/core/utils/math\";\n\n// Note this function is not generic, it is designed specifically for Weaviate\n// https://weaviate.io/developers/weaviate/config-refs/datatypes#introduction\nexport const flattenObjectForWeaviate = (obj: Record<string, unknown>) => {\n  const flattenedObject: Record<string, unknown> = {};\n  for (const key in obj) {\n    if (!Object.hasOwn(obj, key)) {\n      continue;\n    }\n\n    // Replace any character that is not a letter, a number, or an underscore with '_'\n    const newKey = key.replace(/[^a-zA-Z0-9_]/g, \"_\");\n\n    const value = obj[key];\n    if (typeof value === \"object\" && !Array.isArray(value)) {\n      const recursiveResult = flattenObjectForWeaviate(\n        value as Record<string, unknown>\n      );\n      for (const deepKey in recursiveResult) {\n        if (Object.hasOwn(recursiveResult, deepKey)) {\n          // Replace any character in the deepKey that is not a letter, a number, or an underscore with '_'\n          const newDeepKey = deepKey.replace(/[^a-zA-Z0-9_]/g, \"_\");\n          flattenedObject[`${newKey}_${newDeepKey}`] = recursiveResult[deepKey];\n        }\n      }\n    } else if (Array.isArray(value)) {\n      if (value.length === 0) {\n        flattenedObject[newKey] = value;\n      } else if (\n        typeof value[0] !== \"object\" &&\n        value.every((el: unknown) => typeof el === typeof value[0])\n      ) {\n        // Weaviate only supports arrays of primitive types,\n        // where all elements are of the same type\n        flattenedObject[newKey] = value;\n      }\n    } else {\n      flattenedObject[newKey] = value;\n    }\n  }\n  return flattenedObject;\n};\n\n/**\n * Interface that defines the arguments required to create a new instance\n * of the `WeaviateStore` class. It includes the Weaviate client, the name\n * of the class in Weaviate, and optional keys for text and metadata.\n */\nexport interface WeaviateLibArgs {\n  client: WeaviateClient;\n  /**\n   * The name of the class in Weaviate. Must start with a capital letter.\n   */\n  indexName?: string;\n  textKey?: string;\n  metadataKeys?: string[];\n  tenant?: string;\n  schema?: CollectionConfigCreate;\n}\n\nexport class WeaviateDocument extends Document {\n  generated?: string;\n\n  additional: Partial<Metadata>;\n\n  vectors: Vectors;\n}\n\n/**\n * Class that extends the `VectorStore` base class. It provides methods to\n * interact with a Weaviate index, including adding vectors and documents,\n * deleting data, and performing similarity searches.\n */\nexport class WeaviateStore extends VectorStore {\n  declare FilterType: FilterValue;\n\n  private client: WeaviateClient;\n\n  private indexName: string;\n\n  private textKey: string;\n\n  private queryAttrs: string[];\n\n  private tenant?: string;\n\n  private schema?: CollectionConfigCreate;\n\n  _vectorstoreType(): string {\n    return \"weaviate\";\n  }\n\n  constructor(public embeddings: EmbeddingsInterface, args: WeaviateLibArgs) {\n    super(embeddings, args);\n\n    this.client = args.client;\n    this.indexName = args.indexName || args.schema?.name || \"\";\n    this.textKey = args.textKey || \"text\";\n    this.queryAttrs = [this.textKey];\n    this.tenant = args.tenant;\n    this.schema = args.schema;\n\n    if (args.metadataKeys) {\n      this.queryAttrs = [\n        ...new Set([\n          ...this.queryAttrs,\n          ...args.metadataKeys.filter((k) => {\n            // https://spec.graphql.org/June2018/#sec-Names\n            // queryAttrs need to be valid GraphQL Names\n            const keyIsValid = /^[_A-Za-z][_0-9A-Za-z]*$/.test(k);\n            if (!keyIsValid) {\n              console.warn(\n                `Skipping metadata key ${k} as it is not a valid GraphQL Name`\n              );\n            }\n            return keyIsValid;\n          }),\n        ]),\n      ];\n    }\n  }\n\n  static async initialize(\n    embeddings: EmbeddingsInterface,\n    config: WeaviateLibArgs & { dimensions?: number }\n  ): Promise<WeaviateStore> {\n    const weaviateStore = new this(embeddings, config);\n    const collection = await weaviateStore.client.collections.exists(\n      weaviateStore.indexName\n    );\n    if (!collection) {\n      if (weaviateStore.schema) {\n        await weaviateStore.client.collections.create(weaviateStore.schema);\n      } else {\n        if (config.tenant) {\n          await weaviateStore.client.collections.create({\n            name: weaviateStore.indexName,\n            multiTenancy: configure.multiTenancy({\n              enabled: true,\n              autoTenantCreation: true,\n            }),\n          });\n        } else {\n          await weaviateStore.client.collections.create({\n            name: weaviateStore.indexName,\n          });\n        }\n      }\n    }\n    return weaviateStore;\n  }\n\n  /**\n   * Method to add vectors and corresponding documents to the Weaviate\n   * index.\n   * @param vectors Array of vectors to be added.\n   * @param documents Array of documents corresponding to the vectors.\n   * @param options Optional parameter that can include specific IDs for the documents.\n   * @returns An array of document IDs.\n   */\n  async addVectors(\n    vectors: number[][],\n    documents: Document[],\n    options?: { ids?: string[] }\n  ) {\n    const documentIds = options?.ids ?? documents.map((_) => uuid.v4());\n    const batch: DataObject<undefined>[] = documents.map((document, index) => {\n      if (Object.hasOwn(document.metadata, \"id\"))\n        throw new Error(\n          \"Document inserted to Weaviate vectorstore should not have `id` in their metadata.\"\n        );\n      const flattenedMetadata = flattenObjectForWeaviate(\n        document.metadata\n      ) as Record<string, WeaviateField>;\n      return {\n        id: documentIds[index],\n        vectors: vectors[index],\n        references: {},\n        properties: {\n          [this.textKey]: document.pageContent,\n          ...flattenedMetadata,\n        },\n      };\n    });\n\n    try {\n      const collection = this.client.collections.get(this.indexName);\n      let response;\n      if (this.tenant) {\n        response = await collection\n          .withTenant(this.tenant)\n          .data.insertMany(batch);\n      } else {\n        response = await collection.data.insertMany(batch);\n      }\n      console.log(\n        `Successfully imported batch of ${\n          Object.values(response.uuids).length\n        } items`\n      );\n      if (response.hasErrors) {\n        console.log(\"this the error\", response.errors);\n        throw new Error(\"Error in batch import!\");\n      }\n      return Object.values(response.uuids);\n    } catch (error) {\n      console.error(\"Error importing batch:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Method to add documents to the Weaviate index. It first generates\n   * vectors for the documents using the embeddings, then adds the vectors\n   * and documents to the index.\n   * @param documents Array of documents to be added.\n   * @param options Optional parameter that can include specific IDs for the documents.\n   * @returns An array of document IDs.\n   */\n  async addDocuments(documents: Document[], options?: { ids?: string[] }) {\n    return this.addVectors(\n      await this.embeddings.embedDocuments(documents.map((d) => d.pageContent)),\n      documents,\n      options\n    );\n  }\n\n  /**\n   * Method to delete data from the Weaviate index. It can delete data based\n   * on specific IDs or a filter.\n   * @param params Object that includes either an array of IDs or a filter for the data to be deleted.\n   * @returns Promise that resolves when the deletion is complete.\n   */\n  async delete(params: {\n    ids?: string[];\n    filter?: FilterValue;\n  }): Promise<void> {\n    const { ids, filter } = params;\n    const collection = this.client.collections.get(this.indexName);\n    if (ids && ids.length > 0) {\n      if (this.tenant) {\n        await collection\n          .withTenant(this.tenant)\n          .data.deleteMany(collection.filter.byId().containsAny(ids));\n      } else {\n        await collection.data.deleteMany(\n          collection.filter.byId().containsAny(ids)\n        );\n      }\n    } else if (filter) {\n      if (this.tenant) {\n        await collection.withTenant(this.tenant).data.deleteMany(filter);\n      } else {\n        await collection.data.deleteMany(filter);\n      }\n    } else {\n      throw new Error(\n        `This method requires either \"ids\" or \"filter\" to be set in the input object`\n      );\n    }\n  }\n\n  /**\n   * Hybrid search combines the results of a vector search and a\n   * keyword (BM25F) search by fusing the two result sets.\n   * @param query The query to search for.\n   * @param options available options for the search. Check docs for complete list\n   * @returns Promise that resolves the result of the search within the fetched collection.\n   */\n  async hybridSearch(\n    query: string,\n    options?: HybridOptions<undefined>\n  ): Promise<Document[]> {\n    const collection = this.client.collections.get(this.indexName);\n    let query_vector: number[] | undefined;\n    if (!options?.vector) {\n      query_vector = await this.embeddings.embedQuery(query);\n    }\n\n    const options_with_vector = {\n      ...options,\n      vector: options?.vector || query_vector,\n      returnMetadata: [\n        \"score\",\n        ...((options?.returnMetadata as MetadataKeys) || []),\n      ] as MetadataKeys,\n    };\n    let result;\n    if (this.tenant) {\n      result = await collection.withTenant(this.tenant).query.hybrid(query, {\n        ...options_with_vector,\n      });\n    } else {\n      result = await collection.query.hybrid(query, {\n        ...options_with_vector,\n      });\n    }\n    const documents: Document[] = [];\n\n    for (const data of result.objects) {\n      const { properties = {}, metadata = {} } = data ?? {};\n      const { [this.textKey]: text, ...rest } = properties;\n\n      documents.push(\n        new Document({\n          pageContent: String(text ?? \"\"),\n          metadata: {\n            ...rest,\n            ...metadata,\n          },\n          id: data.uuid,\n        })\n      );\n    }\n    return documents;\n  }\n\n  /**\n   * Weaviate's Retrieval Augmented Generation (RAG) combines information retrieval\n   * with generative AI models. It first performs the search, then passes both\n   * the search results and your prompt to a generative AI model before returning the generated response.\n   * @param query The query to search for.\n   * @param generate available options for the generation. Check docs for complete list\n   * @param options available options for performing the hybrid search\n   * @returns Promise that resolves the result of the search including the generated data.\n   */\n  async generate(\n    query: string,\n    generate: GenerateOptions<undefined, GenerativeConfigRuntime | undefined>,\n    options?: BaseHybridOptions<undefined>\n  ): Promise<WeaviateDocument[]> {\n    const collection = this.client.collections.get(this.indexName);\n    let result;\n    if (this.tenant) {\n      result = await collection\n        .withTenant(this.tenant)\n        .generate.hybrid(\n          query,\n          { ...(generate || {}) },\n          { ...(options || {}) }\n        );\n    } else {\n      result = await collection.generate.hybrid(\n        query,\n        { ...(generate || {}) },\n        { ...(options || {}) }\n      );\n    }\n    const documents = [];\n    for (const data of result.objects) {\n      const { properties = {} } = data ?? {};\n      const { [this.textKey]: text, ...rest } = properties;\n\n      const doc = new WeaviateDocument({\n        pageContent: String(text ?? \"\"),\n        metadata: {\n          ...rest,\n        },\n        id: data.uuid,\n      });\n\n      doc.generated = data.generative?.text;\n      doc.vectors = data.vectors;\n      doc.additional = data.metadata || {};\n\n      documents.push(doc);\n    }\n    return documents;\n  }\n\n  /**\n   * Method to perform a similarity search on the stored vectors in the\n   * Weaviate index. It returns the top k most similar documents and their\n   * similarity scores.\n   * @param query The query vector.\n   * @param k The number of most similar documents to return.\n   * @param filter Optional filter to apply to the search.\n   * @returns An array of tuples, where each tuple contains a document and its similarity score.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: FilterValue\n  ): Promise<[Document, number][]> {\n    const resultsWithEmbedding =\n      await this.similaritySearchVectorWithScoreAndEmbedding(query, k, filter);\n    return resultsWithEmbedding.map(([document, score, _embedding]) => [\n      document,\n      score,\n    ]);\n  }\n\n  /**\n   * Method to perform a similarity search on the stored vectors in the\n   * Weaviate index. It returns the top k most similar documents, their\n   * similarity scores and embedding vectors.\n   * @param query The query vector.\n   * @param k The number of most similar documents to return.\n   * @param filter Optional filter to apply to the search.\n   * @returns An array of tuples, where each tuple contains a document, its similarity score and its embedding vector.\n   */\n  async similaritySearchVectorWithScoreAndEmbedding(\n    query: number[],\n    k: number,\n    filter?: FilterValue\n  ): Promise<[Document, number, number, number[]][]> {\n    try {\n      const collection = this.client.collections.get(this.indexName);\n      // define query attributes to return\n      // if no queryAttrs, show all properties\n      const queryAttrs =\n        this.queryAttrs.length > 1 ? this.queryAttrs : undefined;\n      let result;\n      if (this.tenant) {\n        result = await collection\n          .withTenant(this.tenant)\n          .query.nearVector(query, {\n            filters: filter,\n            limit: k,\n            returnMetadata: [\"distance\", \"score\"],\n            returnProperties: queryAttrs,\n          });\n      } else {\n        result = await collection.query.nearVector(query, {\n          filters: filter,\n          limit: k,\n          includeVector: true,\n          returnMetadata: [\"distance\", \"score\"],\n          returnProperties: queryAttrs,\n        });\n      }\n\n      const documents: [Document, number, number, number[]][] = [];\n\n      for (const data of result.objects) {\n        const { properties = {}, metadata = {} } = data ?? {};\n        const { [this.textKey]: text, ...rest } = properties;\n\n        documents.push([\n          new Document({\n            pageContent: String(text ?? \"\"),\n            metadata: {\n              ...rest,\n            },\n            id: data.uuid,\n          }),\n          metadata?.distance ?? 0,\n          metadata?.score ?? 0,\n          Object.values(data.vectors)[0],\n        ]);\n      }\n      return documents;\n    } catch (e) {\n      throw Error(`Error in similaritySearch ${e}`);\n    }\n  }\n\n  /**\n   * Return documents selected using the maximal marginal relevance.\n   * Maximal marginal relevance optimizes for similarity to the query AND diversity\n   * among selected documents.\n   *\n   * @param {string} query - Text to look up documents similar to.\n   * @param {number} options.k - Number of documents to return.\n   * @param {number} options.fetchK - Number of documents to fetch before passing to the MMR algorithm.\n   * @param {number} options.lambda - Number between 0 and 1 that determines the degree of diversity among the results,\n   *                 where 0 corresponds to maximum diversity and 1 to minimum diversity.\n   * @param {this[\"FilterType\"]} options.filter - Optional filter\n   * @param _callbacks\n   *\n   * @returns {Promise<Document[]>} - List of documents selected by maximal marginal relevance.\n   */\n  override async maxMarginalRelevanceSearch(\n    query: string,\n    options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>,\n    _callbacks?: undefined\n  ): Promise<Document[]> {\n    const { k, fetchK = 20, lambda = 0.5, filter } = options;\n    const queryEmbedding: number[] = await this.embeddings.embedQuery(query);\n    const allResults: [Document, number, number, number[]][] =\n      await this.similaritySearchVectorWithScoreAndEmbedding(\n        queryEmbedding,\n        fetchK,\n        filter\n      );\n    const embeddingList = allResults.map(\n      ([_doc, _distance, _score, embedding]) => embedding\n    );\n    const mmrIndexes = maximalMarginalRelevance(\n      queryEmbedding,\n      embeddingList,\n      lambda,\n      k\n    );\n    return mmrIndexes\n      .filter((idx) => idx !== -1)\n      .map((idx) => allResults[idx][0]);\n  }\n\n  /**\n   * Static method to create a new `WeaviateStore` instance from a list of\n   * texts. It first creates documents from the texts and metadata, then\n   * adds the documents to the Weaviate index.\n   * @param texts Array of texts.\n   * @param metadatas Metadata for the texts. Can be a single object or an array of objects.\n   * @param embeddings Embeddings to be used for the texts.\n   * @param args Arguments required to create a new `WeaviateStore` instance.\n   * @returns A new `WeaviateStore` instance.\n   */\n  static fromTexts(\n    texts: string[],\n    metadatas: object | object[],\n    embeddings: EmbeddingsInterface,\n    args: WeaviateLibArgs\n  ): Promise<WeaviateStore> {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return WeaviateStore.fromDocuments(docs, embeddings, args);\n  }\n\n  /**\n   * Static method to create a new `WeaviateStore` instance from a list of\n   * documents. It adds the documents to the Weaviate index.\n   * @param docs Array of documents.\n   * @param embeddings Embeddings to be used for the documents.\n   * @param args Arguments required to create a new `WeaviateStore` instance.\n   * @returns A new `WeaviateStore` instance.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    args: WeaviateLibArgs\n  ): Promise<WeaviateStore> {\n    const instance = await this.initialize(embeddings, args);\n    await instance.addDocuments(docs);\n    return instance;\n  }\n\n  /**\n   * Static method to create a new `WeaviateStore` instance from an existing\n   * Weaviate index.\n   * @param embeddings Embeddings to be used for the Weaviate index.\n   * @param args Arguments required to create a new `WeaviateStore` instance.\n   * @returns A new `WeaviateStore` instance.\n   */\n  static async fromExistingIndex(\n    embeddings: EmbeddingsInterface,\n    args: WeaviateLibArgs\n  ): Promise<WeaviateStore> {\n    return new this(embeddings, args);\n  }\n}\n"],"mappings":"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"}