{"version":3,"file":"message_inputs.cjs","names":["block: unknown","base64: string","format: Bedrock.ImageFormat | undefined","standardContentBlockConverter: StandardContentBlockConverter<{\n  text: Bedrock.ContentBlock.TextMember;\n  image: Bedrock.ContentBlock.ImageMember;\n  file: Bedrock.ContentBlock.DocumentMember;\n}>","block: ContentBlock.Data.StandardTextBlock","block: ContentBlock.Data.StandardImageBlock","block: ContentBlock.Data.StandardFileBlock","name: string | undefined","format: Bedrock.DocumentFormat | undefined","msg: SystemMessage","contentBlocks: Bedrock.SystemContentBlock[]","msg: AIMessage","convertFromV1ToChatBedrockConverseMessage","assistantMsg: Bedrock.Message","contentBlocks: Bedrock.ContentBlock[]","msg: HumanMessage","content: Bedrock.ContentBlock[]","msg: ToolMessage","messages: BaseMessage[]","SystemMessage","converseMessages: Bedrock.Message[]","AIMessage","HumanMessage","ChatMessage","ToolMessage","content: MessageContentReasoningBlock","content: Array<MessageContentComplex | MessageContentReasoningBlock>","concatenatedBlocks: MessageContentComplex[]","concatenatedBlock: Partial<MessageContentReasoningBlock>"],"sources":["../../src/utils/message_inputs.ts"],"sourcesContent":["import {\n  MessageContentComplex,\n  BaseMessage,\n  SystemMessage,\n  HumanMessage,\n  StandardContentBlockConverter,\n  ContentBlock,\n  ChatMessage,\n} from \"@langchain/core/messages\";\nimport {\n  AIMessage,\n  ToolMessage,\n  parseBase64DataUrl,\n  parseMimeType,\n  convertToProviderContentBlock,\n  isDataContentBlock,\n} from \"@langchain/core/messages\";\nimport type * as Bedrock from \"@aws-sdk/client-bedrock-runtime\";\nimport type { DocumentType as __DocumentType } from \"@smithy/types\";\nimport {\n  MessageContentReasoningBlock,\n  MessageContentReasoningBlockReasoningText,\n  MessageContentReasoningBlockRedacted,\n} from \"../types.js\";\nimport { convertFromV1ToChatBedrockConverseMessage } from \"./compat.js\";\n\nfunction isDefaultCachePoint(block: unknown): boolean {\n  return Boolean(\n    typeof block === \"object\" &&\n      block !== null &&\n      \"cachePoint\" in block &&\n      block.cachePoint &&\n      typeof block.cachePoint === \"object\" &&\n      block.cachePoint !== null &&\n      \"type\" in block.cachePoint &&\n      block.cachePoint.type === \"default\"\n  );\n}\n\nexport function extractImageInfo(\n  base64: string\n): Bedrock.ContentBlock.ImageMember {\n  // Extract the format from the base64 string\n  const formatMatch = base64.match(/^data:image\\/(\\w+);base64,/);\n  let format: Bedrock.ImageFormat | undefined;\n  if (formatMatch) {\n    const extractedFormat = formatMatch[1].toLowerCase();\n    if ([\"gif\", \"jpeg\", \"png\", \"webp\"].includes(extractedFormat)) {\n      format = extractedFormat as Bedrock.ImageFormat;\n    }\n  }\n\n  // Remove the data URL prefix if present\n  const base64Data = base64.replace(/^data:image\\/\\w+;base64,/, \"\");\n\n  // Convert base64 to Uint8Array\n  const binaryString = atob(base64Data);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i += 1) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n\n  return {\n    image: {\n      format,\n      source: {\n        bytes,\n      },\n    },\n  };\n}\n\nconst standardContentBlockConverter: StandardContentBlockConverter<{\n  text: Bedrock.ContentBlock.TextMember;\n  image: Bedrock.ContentBlock.ImageMember;\n  file: Bedrock.ContentBlock.DocumentMember;\n}> = {\n  providerName: \"ChatBedrockConverse\",\n\n  fromStandardTextBlock(\n    block: ContentBlock.Data.StandardTextBlock\n  ): Bedrock.ContentBlock.TextMember {\n    return {\n      text: block.text,\n    };\n  },\n\n  fromStandardImageBlock(\n    block: ContentBlock.Data.StandardImageBlock\n  ): Bedrock.ContentBlock.ImageMember {\n    let format: Bedrock.ImageFormat | undefined;\n\n    if (block.source_type === \"url\") {\n      const parsedData = parseBase64DataUrl({\n        dataUrl: block.url,\n        asTypedArray: true,\n      });\n      if (parsedData) {\n        const parsedMimeType = parseMimeType(parsedData.mime_type);\n        format = parsedMimeType.type as Bedrock.ImageFormat;\n        return {\n          image: {\n            format,\n            source: {\n              bytes: parsedData.data,\n            },\n          },\n        };\n      } else {\n        throw new Error(\n          \"Only base64 data URLs are supported for image blocks with source type 'url' with ChatBedrockConverse.\"\n        );\n      }\n    } else if (block.source_type === \"base64\") {\n      if (block.mime_type) {\n        const parsedMimeType = parseMimeType(block.mime_type);\n        format = parsedMimeType.subtype as Bedrock.ImageFormat;\n      }\n\n      if (format && ![\"gif\", \"jpeg\", \"png\", \"webp\"].includes(format)) {\n        throw new Error(\n          `Unsupported image mime type: \"${block.mime_type}\" ChatBedrockConverse only supports \"image/gif\", \"image/jpeg\", \"image/png\", and \"image/webp\" formats.`\n        );\n      }\n      return {\n        image: {\n          format,\n          source: {\n            bytes: Uint8Array.from(atob(block.data), (c) => c.charCodeAt(0)),\n          },\n        },\n      };\n    } else if (block.source_type === \"id\") {\n      throw new Error(\n        \"Image source type 'id' not supported with ChatBedrockConverse.\"\n      );\n    } else {\n      throw new Error(\n        `Unsupported image source type: \"${\n          (block as { source_type: string }).source_type\n        }\" with ChatBedrockConverse.`\n      );\n    }\n  },\n\n  fromStandardFileBlock(\n    block: ContentBlock.Data.StandardFileBlock\n  ): Bedrock.ContentBlock.DocumentMember {\n    const mimeTypeToDocumentFormat = {\n      \"text/csv\": \"csv\",\n      \"application/msword\": \"doc\",\n      \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\":\n        \"docx\",\n      \"text/html\": \"html\",\n      \"text/markdown\": \"md\",\n      \"application/pdf\": \"pdf\",\n      \"text/plain\": \"txt\",\n      \"application/vnd.ms-excel\": \"xls\",\n      \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\":\n        \"xlsx\",\n    };\n    const name: string | undefined = (block.metadata?.name ??\n      block.metadata?.filename ??\n      block.metadata?.title) as string | undefined;\n\n    if (block.source_type === \"text\") {\n      return {\n        document: {\n          name,\n          format: \"txt\",\n          source: {\n            bytes: new TextEncoder().encode(block.text),\n          },\n        },\n      };\n    }\n\n    if (block.source_type === \"url\") {\n      const parsedData = parseBase64DataUrl({\n        dataUrl: block.url,\n        asTypedArray: true,\n      });\n\n      if (parsedData) {\n        const parsedMimeType = parseMimeType(\n          parsedData.mime_type ?? block.mime_type\n        );\n        const mimeType = `${parsedMimeType.type}/${parsedMimeType.subtype}`;\n        const format = mimeTypeToDocumentFormat[\n          mimeType as keyof typeof mimeTypeToDocumentFormat\n        ] as Bedrock.DocumentFormat | undefined;\n        return {\n          document: {\n            name,\n            format,\n            source: {\n              bytes: parsedData.data,\n            },\n          },\n        };\n      }\n      throw new Error(\n        \"Only base64 data URLs are supported for file blocks with source type 'url' with ChatBedrockConverse.\"\n      );\n    }\n\n    if (block.source_type === \"base64\") {\n      let format: Bedrock.DocumentFormat | undefined;\n\n      if (block.mime_type) {\n        const parsedMimeType = parseMimeType(block.mime_type);\n        const mimeType = `${parsedMimeType.type}/${parsedMimeType.subtype}`;\n        format = mimeTypeToDocumentFormat[\n          mimeType as keyof typeof mimeTypeToDocumentFormat\n        ] as Bedrock.DocumentFormat | undefined;\n        if (format === undefined) {\n          throw new Error(\n            `Unsupported file mime type: \"${\n              block.mime_type\n            }\" ChatBedrockConverse only supports ${Object.keys(\n              mimeTypeToDocumentFormat\n            ).join(\", \")} formats.`\n          );\n        }\n      }\n\n      return {\n        document: {\n          name,\n          format,\n          source: {\n            bytes: Uint8Array.from(atob(block.data), (c) => c.charCodeAt(0)),\n          },\n        },\n      };\n    }\n\n    if (block.source_type === \"id\") {\n      throw new Error(\n        \"File source type 'id' not supported with ChatBedrockConverse.\"\n      );\n    }\n\n    throw new Error(\n      `Unsupported file source type: \"${\n        (block as { source_type: string }).source_type\n      }\" with ChatBedrockConverse.`\n    );\n  },\n};\n\nfunction convertLangChainContentBlockToConverseContentBlock<\n  BlockT extends\n    | MessageContentComplex\n    | ContentBlock.Data.DataContentBlock\n    | string\n>({\n  block,\n  onUnknown,\n}: {\n  block: BlockT;\n  onUnknown?: \"returnUnmodified\";\n}): Bedrock.ContentBlock | BlockT;\n\nfunction convertLangChainContentBlockToConverseContentBlock<\n  BlockT extends\n    | MessageContentComplex\n    | ContentBlock.Data.DataContentBlock\n    | string\n>({\n  block,\n  onUnknown,\n}: {\n  block: BlockT;\n  onUnknown?: \"throw\";\n}): Bedrock.ContentBlock;\n\nfunction convertLangChainContentBlockToConverseContentBlock<\n  BlockT extends\n    | MessageContentComplex\n    | ContentBlock.Data.DataContentBlock\n    | string\n>({\n  block,\n  onUnknown = \"throw\",\n}: {\n  block: BlockT;\n  onUnknown?: \"throw\" | \"returnUnmodified\";\n}): Bedrock.ContentBlock | BlockT {\n  if (typeof block === \"string\") {\n    return { text: block };\n  }\n\n  if (isDataContentBlock(block)) {\n    return convertToProviderContentBlock(block, standardContentBlockConverter);\n  }\n\n  if (block.type === \"text\") {\n    return { text: block.text };\n  }\n\n  if (block.type === \"image_url\") {\n    return extractImageInfo(\n      typeof block.image_url === \"string\"\n        ? block.image_url\n        : block.image_url.url\n    );\n  }\n\n  if (block.type === \"document\" && block.document !== undefined) {\n    return {\n      document: block.document,\n    };\n  }\n\n  if (block.type === \"image\" && block.image !== undefined) {\n    return {\n      image: block.image,\n    };\n  }\n\n  if (isDefaultCachePoint(block)) {\n    return {\n      cachePoint: {\n        type: \"default\",\n      },\n    };\n  }\n\n  if (onUnknown === \"throw\") {\n    throw new Error(`Unsupported content block type: ${block.type}`);\n  } else {\n    return block;\n  }\n}\n\nfunction convertSystemMessageToConverseMessage(\n  msg: SystemMessage\n): Bedrock.SystemContentBlock[] {\n  if (typeof msg.content === \"string\") {\n    return [{ text: msg.content }];\n  } else if (Array.isArray(msg.content) && msg.content.length > 0) {\n    const contentBlocks: Bedrock.SystemContentBlock[] = [];\n    for (const block of msg.content) {\n      if (block.type === \"text\" && typeof block.text === \"string\") {\n        contentBlocks.push({\n          text: block.text,\n        });\n      } else if (isDefaultCachePoint(block)) {\n        contentBlocks.push({\n          cachePoint: {\n            type: \"default\",\n          },\n        });\n      } else break;\n    }\n    if (msg.content.length === contentBlocks.length) return contentBlocks;\n  }\n  throw new Error(\n    \"System message content must be either a string, or an array of text blocks, optionally including a cache point.\"\n  );\n}\n\nfunction convertAIMessageToConverseMessage(msg: AIMessage): Bedrock.Message {\n  if (msg.response_metadata.response_format === \"v1\") {\n    return {\n      role: \"assistant\",\n      content: convertFromV1ToChatBedrockConverseMessage(msg),\n    };\n  }\n\n  const assistantMsg: Bedrock.Message = {\n    role: \"assistant\",\n    content: [],\n  };\n\n  if (typeof msg.content === \"string\" && msg.content !== \"\") {\n    assistantMsg.content?.push({\n      text: msg.content,\n    });\n  } else if (Array.isArray(msg.content)) {\n    const concatenatedBlocks = concatenateLangchainReasoningBlocks(msg.content);\n    const contentBlocks: Bedrock.ContentBlock[] = [];\n    concatenatedBlocks.forEach((block) => {\n      if (block.type === \"text\" && block.text !== \"\") {\n        // Merge whitespace/newlines with previous text blocks to avoid validation errors.\n        const cleanedText = block.text?.replace(/\\n/g, \"\").trim();\n        if (cleanedText === \"\") {\n          if (contentBlocks.length > 0) {\n            const mergedTextContent = `${\n              contentBlocks[contentBlocks.length - 1].text\n            }${block.text}`;\n            contentBlocks[contentBlocks.length - 1].text = mergedTextContent;\n          }\n        } else {\n          contentBlocks.push({\n            text: block.text,\n          });\n        }\n      } else if (block.type === \"reasoning_content\") {\n        contentBlocks.push({\n          reasoningContent: langchainReasoningBlockToBedrockReasoningBlock(\n            block as MessageContentReasoningBlock\n          ),\n        });\n      } else if (isDefaultCachePoint(block)) {\n        contentBlocks.push({\n          cachePoint: {\n            type: \"default\",\n          },\n        });\n      } else {\n        const blockValues = Object.fromEntries(\n          Object.entries(block).filter(([key]) => key !== \"type\")\n        );\n        throw new Error(\n          `Unsupported content block type: ${\n            block.type\n          } with content of ${JSON.stringify(blockValues, null, 2)}`\n        );\n      }\n    });\n\n    assistantMsg.content = [\n      ...(assistantMsg.content ? assistantMsg.content : []),\n      ...contentBlocks,\n    ];\n  }\n\n  // Important: this must be placed after any reasoning content blocks, else claude models will return an error.\n  if (msg.tool_calls && msg.tool_calls.length) {\n    assistantMsg.content = [\n      ...(assistantMsg.content ? assistantMsg.content : []),\n      ...msg.tool_calls.map((tc) => ({\n        toolUse: {\n          toolUseId: tc.id,\n          name: tc.name,\n          input: tc.args,\n        },\n      })),\n    ];\n  }\n\n  return assistantMsg;\n}\n\nfunction convertHumanMessageToConverseMessage(\n  msg: HumanMessage\n): Bedrock.Message {\n  if (msg.content === \"\") {\n    throw new Error(\n      `Invalid message content: empty string. '${msg.type}' must contain non-empty content.`\n    );\n  }\n\n  const contentParts = Array.isArray(msg.content) ? msg.content : [msg.content];\n  const content: Bedrock.ContentBlock[] = contentParts.map((c) =>\n    convertLangChainContentBlockToConverseContentBlock({\n      block: c,\n      onUnknown: \"throw\",\n    })\n  );\n\n  return {\n    role: \"user\" as const,\n    content,\n  };\n}\n\nfunction convertToolMessageToConverseMessage(\n  msg: ToolMessage\n): Bedrock.Message {\n  const castMsg = msg as ToolMessage;\n  if (typeof castMsg.content === \"string\") {\n    return {\n      // Tool use messages are always from the user\n      role: \"user\" as const,\n      content: [\n        {\n          toolResult: {\n            toolUseId: castMsg.tool_call_id,\n            content: [\n              {\n                text: castMsg.content,\n              },\n            ],\n          },\n        },\n      ],\n    };\n  } else {\n    return {\n      // Tool use messages are always from the user\n      role: \"user\" as const,\n      content: [\n        {\n          toolResult: {\n            toolUseId: castMsg.tool_call_id,\n            content: (\n              msg.content as (\n                | MessageContentComplex\n                | ContentBlock.Data.DataContentBlock\n              )[]\n            ).map((c) => {\n              const converted =\n                convertLangChainContentBlockToConverseContentBlock({\n                  block: c,\n                  onUnknown: \"returnUnmodified\",\n                });\n              if (converted !== c) {\n                return converted as Bedrock.ToolResultContentBlock;\n              }\n              return { json: c } as Bedrock.ToolResultContentBlock.JsonMember;\n            }),\n          },\n        },\n      ],\n    };\n  }\n}\n\nexport function convertToConverseMessages(messages: BaseMessage[]): {\n  converseMessages: Bedrock.Message[];\n  converseSystem: Bedrock.SystemContentBlock[];\n} {\n  const converseSystem = messages.reduce((acc, msg) => {\n    if (SystemMessage.isInstance(msg)) {\n      acc.push(...convertSystemMessageToConverseMessage(msg));\n    }\n    return acc;\n  }, [] as Bedrock.SystemContentBlock[]);\n\n  const converseMessages: Bedrock.Message[] = messages\n    .filter((msg) => !SystemMessage.isInstance(msg))\n    .map((msg) => {\n      if (AIMessage.isInstance(msg)) {\n        return convertAIMessageToConverseMessage(msg as AIMessage);\n      } else if (HumanMessage.isInstance(msg) || ChatMessage.isInstance(msg)) {\n        return convertHumanMessageToConverseMessage(msg as HumanMessage);\n      } else if (ToolMessage.isInstance(msg)) {\n        return convertToolMessageToConverseMessage(msg as ToolMessage);\n      } else {\n        throw new Error(`Unsupported message type: ${msg.type}`);\n      }\n    });\n\n  // Combine consecutive user tool result messages into a single message\n  const combinedConverseMessages = converseMessages.reduce<Bedrock.Message[]>(\n    (acc, curr) => {\n      const lastMessage = acc[acc.length - 1];\n\n      if (\n        lastMessage &&\n        lastMessage.role === \"user\" &&\n        lastMessage.content?.some((c) => \"toolResult\" in c) &&\n        curr.role === \"user\" &&\n        curr.content?.some((c) => \"toolResult\" in c)\n      ) {\n        lastMessage.content = lastMessage.content.concat(curr.content);\n      } else {\n        acc.push(curr);\n      }\n\n      return acc;\n    },\n    []\n  );\n\n  return { converseMessages: combinedConverseMessages, converseSystem };\n}\n\nexport function langchainReasoningBlockToBedrockReasoningBlock(\n  content: MessageContentReasoningBlock\n): Bedrock.ReasoningContentBlock {\n  if (content.type !== \"reasoning_content\") {\n    throw new Error(\"Invalid reasoning content\");\n  }\n  if (\"reasoningText\" in content) {\n    return {\n      reasoningText: content.reasoningText as Bedrock.ReasoningTextBlock,\n    };\n  }\n  if (\"redactedContent\" in content) {\n    return {\n      redactedContent: Buffer.from(content.redactedContent, \"base64\"),\n    };\n  }\n  throw new Error(\"Invalid reasoning content\");\n}\n\nexport function concatenateLangchainReasoningBlocks(\n  content: Array<MessageContentComplex | MessageContentReasoningBlock>\n): MessageContentComplex[] {\n  const concatenatedBlocks: MessageContentComplex[] = [];\n  let concatenatedBlock: Partial<MessageContentReasoningBlock> = {};\n\n  for (const block of content) {\n    if (block.type !== \"reasoning_content\") {\n      // if it's some other block type, end the current block, but keep it so we preserve order\n      if (Object.keys(concatenatedBlock).length > 0) {\n        concatenatedBlocks.push(\n          concatenatedBlock as MessageContentReasoningBlock\n        );\n        concatenatedBlock = {};\n      }\n      concatenatedBlocks.push(block);\n      continue;\n    }\n\n    // non-redacted block\n    if (\"reasoningText\" in block && typeof block.reasoningText === \"object\") {\n      if (\"redactedContent\" in concatenatedBlock) {\n        // new type of block, so end the previous one\n        concatenatedBlocks.push(\n          concatenatedBlock as MessageContentReasoningBlock\n        );\n        concatenatedBlock = {};\n      }\n      const { text, signature } = block.reasoningText as Partial<\n        MessageContentReasoningBlockReasoningText[\"reasoningText\"]\n      >;\n      const { text: prevText, signature: prevSignature } = (\n        \"reasoningText\" in concatenatedBlock\n          ? concatenatedBlock.reasoningText\n          : {}\n      ) as Partial<MessageContentReasoningBlockReasoningText[\"reasoningText\"]>;\n\n      concatenatedBlock = {\n        type: \"reasoning_content\",\n        reasoningText: {\n          ...((concatenatedBlock as MessageContentReasoningBlockReasoningText)\n            .reasoningText ?? {}),\n          ...(prevText !== undefined || text !== undefined\n            ? { text: (prevText ?? \"\") + (text ?? \"\") }\n            : {}),\n          ...(prevSignature !== undefined || signature !== undefined\n            ? { signature: (prevSignature ?? \"\") + (signature ?? \"\") }\n            : {}),\n        },\n      };\n      // if a partial block chunk has a signature, the next one will begin a new reasoning block.\n      // full blocks always have signatures, so we start one now, anyway\n      if (\"signature\" in block.reasoningText) {\n        concatenatedBlocks.push(\n          concatenatedBlock as MessageContentReasoningBlock\n        );\n        concatenatedBlock = {};\n      }\n    }\n\n    if (\"redactedContent\" in block) {\n      if (\"reasoningText\" in concatenatedBlock) {\n        // New type of block, so end the previous one. We should't really hit\n        // this, as we'll have created a new block upon encountering the\n        // signature above, but better safe than sorry.\n        concatenatedBlocks.push(\n          concatenatedBlock as MessageContentReasoningBlock\n        );\n        concatenatedBlock = {};\n      }\n      const { redactedContent } = block;\n      const prevRedactedContent = (\n        \"redactedContent\" in concatenatedBlock\n          ? concatenatedBlock.redactedContent!\n          : \"\"\n      ) as Partial<MessageContentReasoningBlockRedacted[\"redactedContent\"]>;\n      concatenatedBlock = {\n        type: \"reasoning_content\",\n        redactedContent: prevRedactedContent + redactedContent,\n      };\n    }\n  }\n  if (Object.keys(concatenatedBlock).length > 0) {\n    concatenatedBlocks.push(concatenatedBlock as MessageContentReasoningBlock);\n  }\n  return concatenatedBlocks;\n}\n"],"mappings":"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"}