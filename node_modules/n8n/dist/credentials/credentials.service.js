"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialsService = void 0;
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const typedi_1 = require("typedi");
const typeorm_1 = require("typeorm");
const Db = __importStar(require("../Db"));
const CredentialsHelper_1 = require("../CredentialsHelper");
const constants_1 = require("../constants");
const CredentialsEntity_1 = require("../databases/entities/CredentialsEntity");
const SharedCredentials_1 = require("../databases/entities/SharedCredentials");
const GenericHelpers_1 = require("../GenericHelpers");
const ExternalHooks_1 = require("../ExternalHooks");
const CredentialTypes_1 = require("../CredentialTypes");
const role_service_1 = require("../services/role.service");
const ownership_service_1 = require("../services/ownership.service");
const Logger_1 = require("../Logger");
const credentials_repository_1 = require("../databases/repositories/credentials.repository");
const sharedCredentials_repository_1 = require("../databases/repositories/sharedCredentials.repository");
class CredentialsService {
    static async get(where, options) {
        return typedi_1.Container.get(credentials_repository_1.CredentialsRepository).findOne({
            relations: options === null || options === void 0 ? void 0 : options.relations,
            where,
        });
    }
    static toFindManyOptions(listQueryOptions) {
        const findManyOptions = {};
        const defaultRelations = ['shared', 'shared.role', 'shared.user'];
        const defaultSelect = ['id', 'name', 'type', 'nodesAccess', 'createdAt', 'updatedAt'];
        if (!listQueryOptions)
            return { select: defaultSelect, relations: defaultRelations };
        const { filter, select, take, skip } = listQueryOptions;
        if (typeof (filter === null || filter === void 0 ? void 0 : filter.name) === 'string' && (filter === null || filter === void 0 ? void 0 : filter.name) !== '') {
            filter.name = (0, typeorm_1.Like)(`%${filter.name}%`);
        }
        if (typeof (filter === null || filter === void 0 ? void 0 : filter.type) === 'string' && (filter === null || filter === void 0 ? void 0 : filter.type) !== '') {
            filter.type = (0, typeorm_1.Like)(`%${filter.type}%`);
        }
        if (filter)
            findManyOptions.where = filter;
        if (select)
            findManyOptions.select = select;
        if (take)
            findManyOptions.take = take;
        if (skip)
            findManyOptions.skip = skip;
        if (take && select && !(select === null || select === void 0 ? void 0 : select.id)) {
            findManyOptions.select = { ...findManyOptions.select, id: true };
        }
        if (!findManyOptions.select) {
            findManyOptions.select = defaultSelect;
            findManyOptions.relations = defaultRelations;
        }
        return findManyOptions;
    }
    static addOwnedByAndSharedWith(credentials) {
        return credentials.map((c) => typedi_1.Container.get(ownership_service_1.OwnershipService).addOwnedByAndSharedWith(c));
    }
    static async getMany(user, options = {}) {
        var _a;
        const findManyOptions = this.toFindManyOptions(options.listQueryOptions);
        const returnAll = user.globalRole.name === 'owner' && !options.onlyOwn;
        const isDefaultSelect = !((_a = options.listQueryOptions) === null || _a === void 0 ? void 0 : _a.select);
        if (returnAll) {
            const credentials = await typedi_1.Container.get(credentials_repository_1.CredentialsRepository).find(findManyOptions);
            return isDefaultSelect ? this.addOwnedByAndSharedWith(credentials) : credentials;
        }
        const ids = await this.getAccessibleCredentials(user.id);
        const credentials = await typedi_1.Container.get(credentials_repository_1.CredentialsRepository).find({
            ...findManyOptions,
            where: { ...findManyOptions.where, id: (0, typeorm_1.In)(ids) },
        });
        return isDefaultSelect ? this.addOwnedByAndSharedWith(credentials) : credentials;
    }
    static async getAccessibleCredentials(userId) {
        const sharings = await typedi_1.Container.get(sharedCredentials_repository_1.SharedCredentialsRepository).find({
            relations: ['role'],
            where: {
                userId,
                role: { name: (0, typeorm_1.In)(['owner', 'user']), scope: 'credential' },
            },
        });
        return sharings.map((s) => s.credentialsId);
    }
    static async getManyByIds(ids, { withSharings } = { withSharings: false }) {
        const options = { where: { id: (0, typeorm_1.In)(ids) } };
        if (withSharings) {
            options.relations = ['shared', 'shared.user', 'shared.role'];
        }
        return typedi_1.Container.get(credentials_repository_1.CredentialsRepository).find(options);
    }
    static async getSharing(user, credentialId, relations = ['credentials'], { allowGlobalOwner } = { allowGlobalOwner: true }) {
        const where = { credentialsId: credentialId };
        if (!allowGlobalOwner || user.globalRole.name !== 'owner') {
            Object.assign(where, {
                userId: user.id,
                role: { name: 'owner' },
            });
            if (!relations.includes('role')) {
                relations.push('role');
            }
        }
        return typedi_1.Container.get(sharedCredentials_repository_1.SharedCredentialsRepository).findOne({ where, relations });
    }
    static async prepareCreateData(data) {
        const { id, ...rest } = data;
        const newCredentials = typedi_1.Container.get(credentials_repository_1.CredentialsRepository).create(rest);
        await (0, GenericHelpers_1.validateEntity)(newCredentials);
        for (const nodeAccess of newCredentials.nodesAccess) {
            nodeAccess.date = new Date();
        }
        return newCredentials;
    }
    static async prepareUpdateData(data, decryptedData) {
        const mergedData = (0, n8n_workflow_1.deepCopy)(data);
        if (mergedData.data) {
            mergedData.data = this.unredact(mergedData.data, decryptedData);
        }
        const updateData = typedi_1.Container.get(credentials_repository_1.CredentialsRepository).create(mergedData);
        await (0, GenericHelpers_1.validateEntity)(updateData);
        for (const nodeAccess of updateData.nodesAccess) {
            if (!nodeAccess.date) {
                nodeAccess.date = new Date();
            }
        }
        if (decryptedData.oauthTokenData) {
            updateData.data.oauthTokenData = decryptedData.oauthTokenData;
        }
        return updateData;
    }
    static createEncryptedData(credentialId, data) {
        const credentials = new n8n_core_1.Credentials({ id: credentialId, name: data.name }, data.type, data.nodesAccess);
        credentials.setData(data.data);
        const newCredentialData = credentials.getDataToSave();
        newCredentialData.updatedAt = new Date();
        return newCredentialData;
    }
    static decrypt(credential) {
        const coreCredential = (0, CredentialsHelper_1.createCredentialsFromCredentialsEntity)(credential);
        return coreCredential.getData();
    }
    static async update(credentialId, newCredentialData) {
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('credentials.update', [newCredentialData]);
        await typedi_1.Container.get(credentials_repository_1.CredentialsRepository).update(credentialId, newCredentialData);
        return typedi_1.Container.get(credentials_repository_1.CredentialsRepository).findOneBy({ id: credentialId });
    }
    static async save(credential, encryptedData, user) {
        const newCredential = new CredentialsEntity_1.CredentialsEntity();
        Object.assign(newCredential, credential, encryptedData);
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('credentials.create', [encryptedData]);
        const role = await typedi_1.Container.get(role_service_1.RoleService).findCredentialOwnerRole();
        const result = await Db.transaction(async (transactionManager) => {
            const savedCredential = await transactionManager.save(newCredential);
            savedCredential.data = newCredential.data;
            const newSharedCredential = new SharedCredentials_1.SharedCredentials();
            Object.assign(newSharedCredential, {
                role,
                user,
                credentials: savedCredential,
            });
            await transactionManager.save(newSharedCredential);
            return savedCredential;
        });
        typedi_1.Container.get(Logger_1.Logger).verbose('New credential created', {
            credentialId: newCredential.id,
            ownerId: user.id,
        });
        return result;
    }
    static async delete(credentials) {
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('credentials.delete', [credentials.id]);
        await typedi_1.Container.get(credentials_repository_1.CredentialsRepository).remove(credentials);
    }
    static async test(user, credentials) {
        const helper = typedi_1.Container.get(CredentialsHelper_1.CredentialsHelper);
        return helper.testCredentials(user, credentials.type, credentials);
    }
    static redact(data, credential) {
        var _a;
        const copiedData = (0, n8n_workflow_1.deepCopy)(data);
        const credTypes = typedi_1.Container.get(CredentialTypes_1.CredentialTypes);
        let credType;
        try {
            credType = credTypes.getByName(credential.type);
        }
        catch {
            return data;
        }
        const getExtendedProps = (type) => {
            var _a;
            const props = [];
            for (const e of (_a = type.extends) !== null && _a !== void 0 ? _a : []) {
                const extendsType = credTypes.getByName(e);
                const extendedProps = getExtendedProps(extendsType);
                n8n_workflow_1.NodeHelpers.mergeNodeProperties(props, extendedProps);
            }
            n8n_workflow_1.NodeHelpers.mergeNodeProperties(props, type.properties);
            return props;
        };
        const properties = getExtendedProps(credType);
        for (const dataKey of Object.keys(copiedData)) {
            if (dataKey === 'oauthTokenData') {
                if (copiedData[dataKey].toString().length > 0) {
                    copiedData[dataKey] = constants_1.CREDENTIAL_BLANKING_VALUE;
                }
                else {
                    copiedData[dataKey] = n8n_workflow_1.CREDENTIAL_EMPTY_VALUE;
                }
                continue;
            }
            const prop = properties.find((v) => v.name === dataKey);
            if (!prop) {
                continue;
            }
            if (((_a = prop.typeOptions) === null || _a === void 0 ? void 0 : _a.password) &&
                (!copiedData[dataKey].startsWith('={{') || prop.noDataExpression)) {
                if (copiedData[dataKey].toString().length > 0) {
                    copiedData[dataKey] = constants_1.CREDENTIAL_BLANKING_VALUE;
                }
                else {
                    copiedData[dataKey] = n8n_workflow_1.CREDENTIAL_EMPTY_VALUE;
                }
            }
        }
        return copiedData;
    }
    static unredactRestoreValues(unmerged, replacement) {
        for (const [key, value] of Object.entries(unmerged)) {
            if (value === constants_1.CREDENTIAL_BLANKING_VALUE || value === n8n_workflow_1.CREDENTIAL_EMPTY_VALUE) {
                unmerged[key] = replacement[key];
            }
            else if (typeof value === 'object' &&
                value !== null &&
                key in replacement &&
                typeof replacement[key] === 'object' &&
                replacement[key] !== null) {
                this.unredactRestoreValues(value, replacement[key]);
            }
        }
    }
    static unredact(redactedData, savedData) {
        const mergedData = (0, n8n_workflow_1.deepCopy)(redactedData);
        this.unredactRestoreValues(mergedData, savedData);
        return mergedData;
    }
}
exports.CredentialsService = CredentialsService;
//# sourceMappingURL=credentials.service.js.map