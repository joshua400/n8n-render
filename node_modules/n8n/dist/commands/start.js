"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Start = void 0;
const typedi_1 = require("typedi");
const path_1 = __importDefault(require("path"));
const promises_1 = require("fs/promises");
const fs_1 = require("fs");
const localtunnel_1 = __importDefault(require("localtunnel"));
const command_1 = require("@oclif/command");
const stream_1 = __importDefault(require("stream"));
const replacestream_1 = __importDefault(require("replacestream"));
const util_1 = require("util");
const fast_glob_1 = __importDefault(require("fast-glob"));
const n8n_workflow_1 = require("n8n-workflow");
const config_1 = __importDefault(require("../config"));
const ActiveExecutions_1 = require("../ActiveExecutions");
const ActiveWorkflowRunner_1 = require("../ActiveWorkflowRunner");
const GenericHelpers = __importStar(require("../GenericHelpers"));
const Server_1 = require("../Server");
const constants_1 = require("../constants");
const eventbus_1 = require("../eventbus");
const BaseCommand_1 = require("./BaseCommand");
const InternalHooks_1 = require("../InternalHooks");
const License_1 = require("../License");
const SingleMainInstance_publisher_1 = require("../services/orchestration/main/SingleMainInstance.publisher");
const orchestration_handler_main_service_1 = require("../services/orchestration/main/orchestration.handler.main.service");
const pruning_service_1 = require("../services/pruning.service");
const settings_repository_1 = require("../databases/repositories/settings.repository");
const execution_repository_1 = require("../databases/repositories/execution.repository");
const open = require('open');
const pipeline = (0, util_1.promisify)(stream_1.default.pipeline);
class Start extends BaseCommand_1.BaseCommand {
    constructor(argv, cmdConfig) {
        super(argv, cmdConfig);
        this.server = new Server_1.Server();
        this.setInstanceType('main');
        this.setInstanceQueueModeId();
    }
    openBrowser() {
        const editorUrl = GenericHelpers.getBaseUrl();
        open(editorUrl, { wait: true }).catch((error) => {
            console.log(`\nWas not able to open URL in browser. Please open manually by visiting:\n${editorUrl}\n`);
        });
    }
    async stopProcess() {
        this.logger.info('\nStopping n8n...');
        try {
            this.activeWorkflowRunner.removeAllQueuedWorkflowActivations();
            await this.externalHooks.run('n8n.stop', []);
            setTimeout(async () => {
                console.log('process exited after 30s');
                await this.exitSuccessFully();
            }, 30000);
            await typedi_1.Container.get(License_1.License).shutdown();
            if (await this.pruningService.isPruningEnabled()) {
                await this.pruningService.stopPruning();
            }
            if (config_1.default.getEnv('leaderSelection.enabled')) {
                const { MultiMainInstancePublisher } = await Promise.resolve().then(() => __importStar(require('../services/orchestration/main/MultiMainInstance.publisher.ee')));
                await this.activeWorkflowRunner.removeAllTriggerAndPollerBasedWorkflows();
                await typedi_1.Container.get(MultiMainInstancePublisher).destroy();
            }
            await typedi_1.Container.get(InternalHooks_1.InternalHooks).onN8nStop();
            const activeExecutionsInstance = typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions);
            let executingWorkflows = activeExecutionsInstance.getActiveExecutions();
            let count = 0;
            while (executingWorkflows.length !== 0) {
                if (count++ % 4 === 0) {
                    console.log(`Waiting for ${executingWorkflows.length} active executions to finish...`);
                    executingWorkflows.map((execution) => {
                        console.log(` - Execution ID ${execution.id}, workflow ID: ${execution.workflowId}`);
                    });
                }
                await (0, n8n_workflow_1.sleep)(500);
                executingWorkflows = activeExecutionsInstance.getActiveExecutions();
            }
            await eventbus_1.eventBus.close();
        }
        catch (error) {
            await this.exitWithCrash('There was an error shutting down n8n.', error);
        }
        await this.exitSuccessFully();
    }
    async generateStaticAssets() {
        const n8nPath = config_1.default.getEnv('path');
        const restEndpoint = config_1.default.getEnv('endpoints.rest');
        const hooksUrls = config_1.default.getEnv('externalFrontendHooksUrls');
        let scriptsString = '';
        if (hooksUrls) {
            scriptsString = hooksUrls.split(';').reduce((acc, curr) => {
                return `${acc}<script src="${curr}"></script>`;
            }, '');
        }
        const closingTitleTag = '</title>';
        const { staticCacheDir } = this.instanceSettings;
        const compileFile = async (fileName) => {
            const filePath = path_1.default.join(constants_1.EDITOR_UI_DIST_DIR, fileName);
            if (/(index\.html)|.*\.(js|css)/.test(filePath) && (0, fs_1.existsSync)(filePath)) {
                const destFile = path_1.default.join(staticCacheDir, fileName);
                await (0, promises_1.mkdir)(path_1.default.dirname(destFile), { recursive: true });
                const streams = [
                    (0, fs_1.createReadStream)(filePath, 'utf-8'),
                    (0, replacestream_1.default)('/{{BASE_PATH}}/', n8nPath, { ignoreCase: false }),
                    (0, replacestream_1.default)('/%7B%7BBASE_PATH%7D%7D/', n8nPath, { ignoreCase: false }),
                    (0, replacestream_1.default)('/static/', n8nPath + 'static/', { ignoreCase: false }),
                ];
                if (filePath.endsWith('index.html')) {
                    streams.push((0, replacestream_1.default)('{{REST_ENDPOINT}}', restEndpoint, { ignoreCase: false }), (0, replacestream_1.default)(closingTitleTag, closingTitleTag + scriptsString, {
                        ignoreCase: false,
                    }));
                }
                streams.push((0, fs_1.createWriteStream)(destFile, 'utf-8'));
                return pipeline(streams);
            }
        };
        await compileFile('index.html');
        const files = await (0, fast_glob_1.default)('**/*.{css,js}', { cwd: constants_1.EDITOR_UI_DIST_DIR });
        await Promise.all(files.map(compileFile));
    }
    async init() {
        await this.initCrashJournal();
        this.logger.info('Initializing n8n process');
        if (config_1.default.getEnv('executions.mode') === 'queue') {
            this.logger.debug('Main Instance running in queue mode');
            this.logger.debug(`Queue mode id: ${this.queueModeId}`);
        }
        await super.init();
        this.activeWorkflowRunner = typedi_1.Container.get(ActiveWorkflowRunner_1.ActiveWorkflowRunner);
        await this.initLicense();
        await this.initOrchestration();
        this.logger.debug('Orchestration init complete');
        await this.initBinaryDataService();
        this.logger.debug('Binary data service init complete');
        await this.initExternalHooks();
        this.logger.debug('External hooks init complete');
        await this.initExternalSecrets();
        this.logger.debug('External secrets init complete');
        this.initWorkflowHistory();
        this.logger.debug('Workflow history init complete');
        if (!config_1.default.getEnv('endpoints.disableUi')) {
            await this.generateStaticAssets();
        }
    }
    async initOrchestration() {
        if (config_1.default.get('executions.mode') !== 'queue')
            return;
        if (!config_1.default.get('leaderSelection.enabled')) {
            await typedi_1.Container.get(SingleMainInstance_publisher_1.SingleMainInstancePublisher).init();
            await typedi_1.Container.get(orchestration_handler_main_service_1.OrchestrationHandlerMainService).init();
            return;
        }
        const { MultiMainInstancePublisher } = await Promise.resolve().then(() => __importStar(require('../services/orchestration/main/MultiMainInstance.publisher.ee')));
        const multiMainInstancePublisher = typedi_1.Container.get(MultiMainInstancePublisher);
        await multiMainInstancePublisher.init();
        if (multiMainInstancePublisher.isLeader &&
            !typedi_1.Container.get(License_1.License).isMultipleMainInstancesLicensed()) {
            throw new License_1.FeatureNotLicensedError(constants_1.LICENSE_FEATURES.MULTIPLE_MAIN_INSTANCES);
        }
        await typedi_1.Container.get(orchestration_handler_main_service_1.OrchestrationHandlerMainService).init();
        multiMainInstancePublisher.on('leadershipChange', async () => {
            if (multiMainInstancePublisher.isLeader) {
                await this.activeWorkflowRunner.addAllTriggerAndPollerBasedWorkflows();
            }
            else {
                await this.activeWorkflowRunner.removeAllTriggerAndPollerBasedWorkflows();
            }
        });
    }
    async run() {
        var _a, _b;
        const { flags } = this.parse(Start);
        const databaseSettings = await typedi_1.Container.get(settings_repository_1.SettingsRepository).findBy({
            loadOnStartup: true,
        });
        databaseSettings.forEach((setting) => {
            config_1.default.set(setting.key, (0, n8n_workflow_1.jsonParse)(setting.value, { fallbackValue: setting.value }));
        });
        const areCommunityPackagesEnabled = config_1.default.getEnv('nodes.communityPackages.enabled');
        if (areCommunityPackagesEnabled) {
            const { CommunityPackagesService } = await Promise.resolve().then(() => __importStar(require('../services/communityPackages.service')));
            await typedi_1.Container.get(CommunityPackagesService).setMissingPackages({
                reinstallMissingPackages: flags.reinstallMissingPackages,
            });
        }
        const dbType = config_1.default.getEnv('database.type');
        if (dbType === 'sqlite') {
            const shouldRunVacuum = config_1.default.getEnv('database.sqlite.executeVacuumOnStartup');
            if (shouldRunVacuum) {
                await typedi_1.Container.get(execution_repository_1.ExecutionRepository).query('VACUUM;');
            }
        }
        if (flags.tunnel) {
            this.log('\nWaiting for tunnel ...');
            let tunnelSubdomain = (_b = (_a = process.env.N8N_TUNNEL_SUBDOMAIN) !== null && _a !== void 0 ? _a : this.instanceSettings.tunnelSubdomain) !== null && _b !== void 0 ? _b : '';
            if (tunnelSubdomain === '') {
                const availableCharacters = 'abcdefghijklmnopqrstuvwxyz0123456789';
                tunnelSubdomain = Array.from({ length: 24 })
                    .map(() => availableCharacters.charAt(Math.floor(Math.random() * availableCharacters.length)))
                    .join('');
                this.instanceSettings.update({ tunnelSubdomain });
            }
            const tunnelSettings = {
                host: 'https://hooks.n8n.cloud',
                subdomain: tunnelSubdomain,
            };
            const port = config_1.default.getEnv('port');
            const webhookTunnel = await (0, localtunnel_1.default)(port, tunnelSettings);
            process.env.WEBHOOK_URL = `${webhookTunnel.url}/`;
            this.log(`Tunnel URL: ${process.env.WEBHOOK_URL}\n`);
            this.log('IMPORTANT! Do not share with anybody as it would give people access to your n8n instance!');
        }
        await this.server.start();
        this.pruningService = typedi_1.Container.get(pruning_service_1.PruningService);
        if (await this.pruningService.isPruningEnabled()) {
            this.pruningService.startPruning();
        }
        await this.activeWorkflowRunner.init();
        const editorUrl = GenericHelpers.getBaseUrl();
        this.log(`\nEditor is now accessible via:\n${editorUrl}`);
        if (Boolean(process.stdout.isTTY) && process.stdin.setRawMode) {
            process.stdin.setRawMode(true);
            process.stdin.resume();
            process.stdin.setEncoding('utf8');
            if (flags.open) {
                this.openBrowser();
            }
            this.log('\nPress "o" to open in Browser.');
            process.stdin.on('data', (key) => {
                if (key === 'o') {
                    this.openBrowser();
                }
                else if (key.charCodeAt(0) === 3) {
                    void this.stopProcess();
                }
                else {
                    if (key.charCodeAt(0) === 13) {
                        process.stdout.write('\n');
                    }
                    else {
                        process.stdout.write(key);
                    }
                }
            });
        }
    }
    async catch(error) {
        console.log(error.stack);
        await this.exitWithCrash('Exiting due to an error.', error);
    }
}
exports.Start = Start;
Start.description = 'Starts n8n. Makes Web-UI available and starts active workflows';
Start.examples = [
    '$ n8n start',
    '$ n8n start --tunnel',
    '$ n8n start -o',
    '$ n8n start --tunnel -o',
];
Start.flags = {
    help: command_1.flags.help({ char: 'h' }),
    open: command_1.flags.boolean({
        char: 'o',
        description: 'opens the UI automatically in browser',
    }),
    tunnel: command_1.flags.boolean({
        description: 'runs the webhooks via a hooks.n8n.cloud tunnel server. Use only for testing and development!',
    }),
    reinstallMissingPackages: command_1.flags.boolean({
        description: 'Attempts to self heal n8n if packages with nodes are missing. Might drastically increase startup times.',
    }),
};
//# sourceMappingURL=start.js.map