"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Worker = void 0;
const express_1 = __importDefault(require("express"));
const http_1 = __importDefault(require("http"));
const typedi_1 = require("typedi");
const command_1 = require("@oclif/command");
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const Db = __importStar(require("../Db"));
const ResponseHelper = __importStar(require("../ResponseHelper"));
const WebhookHelpers = __importStar(require("../WebhookHelpers"));
const WorkflowExecuteAdditionalData = __importStar(require("../WorkflowExecuteAdditionalData"));
const PermissionChecker_1 = require("../UserManagement/PermissionChecker");
const config_1 = __importDefault(require("../config"));
const Queue_1 = require("../Queue");
const WorkflowHelpers_1 = require("../WorkflowHelpers");
const constants_1 = require("../constants");
const BaseCommand_1 = require("./BaseCommand");
const execution_repository_1 = require("../databases/repositories/execution.repository");
const workflow_repository_1 = require("../databases/repositories/workflow.repository");
const ownership_service_1 = require("../services/ownership.service");
const CredentialsOverwrites_1 = require("../CredentialsOverwrites");
const middlewares_1 = require("../middlewares");
const eventbus_1 = require("../eventbus");
const EventMessageGeneric_1 = require("../eventbus/EventMessageClasses/EventMessageGeneric");
const orchestration_handler_worker_service_1 = require("../services/orchestration/worker/orchestration.handler.worker.service");
const orchestration_worker_service_1 = require("../services/orchestration/worker/orchestration.worker.service");
class Worker extends BaseCommand_1.BaseCommand {
    async stopProcess() {
        this.logger.info('Stopping n8n...');
        await Worker.jobQueue.pause(true);
        try {
            await this.externalHooks.run('n8n.stop', []);
            const maxStopTime = config_1.default.getEnv('queue.bull.gracefulShutdownTimeout') * 1000;
            const stopTime = new Date().getTime() + maxStopTime;
            setTimeout(async () => {
                await this.exitSuccessFully();
            }, maxStopTime);
            let count = 0;
            while (Object.keys(Worker.runningJobs).length !== 0) {
                if (count++ % 4 === 0) {
                    const waitLeft = Math.ceil((stopTime - new Date().getTime()) / 1000);
                    this.logger.info(`Waiting for ${Object.keys(Worker.runningJobs).length} active executions to finish... (wait ${waitLeft} more seconds)`);
                }
                await (0, n8n_workflow_1.sleep)(500);
            }
        }
        catch (error) {
            await this.exitWithCrash('There was an error shutting down n8n.', error);
        }
        await this.exitSuccessFully();
    }
    async runJob(job, nodeTypes) {
        var _a, _b, _c, _d;
        const { executionId, loadStaticData } = job.data;
        const executionRepository = typedi_1.Container.get(execution_repository_1.ExecutionRepository);
        const fullExecutionData = await executionRepository.findSingleExecution(executionId, {
            includeData: true,
            unflattenData: true,
        });
        if (!fullExecutionData) {
            this.logger.error(`Worker failed to find data of execution "${executionId}" in database. Cannot continue.`, { executionId });
            throw new Error(`Unable to find data of execution "${executionId}" in database. Aborting execution.`);
        }
        const workflowId = fullExecutionData.workflowData.id;
        this.logger.info(`Start job: ${job.id} (Workflow ID: ${workflowId} | Execution: ${executionId})`);
        await executionRepository.updateStatus(executionId, 'running');
        const workflowOwner = await typedi_1.Container.get(ownership_service_1.OwnershipService).getWorkflowOwnerCached(workflowId);
        let { staticData } = fullExecutionData.workflowData;
        if (loadStaticData) {
            const workflowData = await typedi_1.Container.get(workflow_repository_1.WorkflowRepository).findOne({
                select: ['id', 'staticData'],
                where: {
                    id: workflowId,
                },
            });
            if (workflowData === null) {
                this.logger.error('Worker execution failed because workflow could not be found in database.', { workflowId, executionId });
                throw new Error(`The workflow with the ID "${workflowId}" could not be found`);
            }
            staticData = workflowData.staticData;
        }
        const workflowSettings = (_a = fullExecutionData.workflowData.settings) !== null && _a !== void 0 ? _a : {};
        let workflowTimeout = (_b = workflowSettings.executionTimeout) !== null && _b !== void 0 ? _b : config_1.default.getEnv('executions.timeout');
        let executionTimeoutTimestamp;
        if (workflowTimeout > 0) {
            workflowTimeout = Math.min(workflowTimeout, config_1.default.getEnv('executions.maxTimeout'));
            executionTimeoutTimestamp = Date.now() + workflowTimeout * 1000;
        }
        const workflow = new n8n_workflow_1.Workflow({
            id: workflowId,
            name: fullExecutionData.workflowData.name,
            nodes: fullExecutionData.workflowData.nodes,
            connections: fullExecutionData.workflowData.connections,
            active: fullExecutionData.workflowData.active,
            nodeTypes,
            staticData,
            settings: fullExecutionData.workflowData.settings,
        });
        const additionalData = await WorkflowExecuteAdditionalData.getBase(workflowOwner.id, undefined, executionTimeoutTimestamp);
        additionalData.hooks = WorkflowExecuteAdditionalData.getWorkflowHooksWorkerExecuter(fullExecutionData.mode, job.data.executionId, fullExecutionData.workflowData, {
            retryOf: fullExecutionData.retryOf,
        });
        try {
            await PermissionChecker_1.PermissionChecker.check(workflow, workflowOwner.id);
        }
        catch (error) {
            if (error instanceof n8n_workflow_1.NodeOperationError) {
                const failedExecution = (0, WorkflowHelpers_1.generateFailedExecutionFromError)(fullExecutionData.mode, error, error.node);
                await additionalData.hooks.executeHookFunctions('workflowExecuteAfter', [failedExecution]);
            }
            return { success: true, error: error };
        }
        additionalData.hooks.hookFunctions.sendResponse = [
            async (response) => {
                const progress = {
                    executionId,
                    response: WebhookHelpers.encodeWebhookResponse(response),
                };
                await job.progress(progress);
            },
        ];
        additionalData.executionId = executionId;
        additionalData.setExecutionStatus = (status) => {
            this.logger.debug(`Queued worker execution status for ${executionId} is "${status}"`);
        };
        let workflowExecute;
        let workflowRun;
        if (fullExecutionData.data !== undefined) {
            workflowExecute = new n8n_core_1.WorkflowExecute(additionalData, fullExecutionData.mode, fullExecutionData.data);
            workflowRun = workflowExecute.processRunExecutionData(workflow);
        }
        else {
            workflowExecute = new n8n_core_1.WorkflowExecute(additionalData, fullExecutionData.mode);
            workflowRun = workflowExecute.run(workflow);
        }
        Worker.runningJobs[job.id] = workflowRun;
        Worker.runningJobsSummary[job.id] = {
            jobId: job.id.toString(),
            executionId,
            workflowId: (_c = fullExecutionData.workflowId) !== null && _c !== void 0 ? _c : '',
            workflowName: fullExecutionData.workflowData.name,
            mode: fullExecutionData.mode,
            startedAt: fullExecutionData.startedAt,
            retryOf: (_d = fullExecutionData.retryOf) !== null && _d !== void 0 ? _d : '',
            status: fullExecutionData.status,
        };
        await workflowRun;
        delete Worker.runningJobs[job.id];
        delete Worker.runningJobsSummary[job.id];
        return {
            success: true,
        };
    }
    constructor(argv, cmdConfig) {
        super(argv, cmdConfig);
        this.setInstanceType('worker');
        this.setInstanceQueueModeId();
    }
    async init() {
        await this.initCrashJournal();
        this.logger.debug('Starting n8n worker...');
        this.logger.debug(`Queue mode id: ${this.queueModeId}`);
        await super.init();
        await this.initLicense();
        this.logger.debug('License init complete');
        await this.initBinaryDataService();
        this.logger.debug('Binary data service init complete');
        await this.initExternalHooks();
        this.logger.debug('External hooks init complete');
        await this.initExternalSecrets();
        this.logger.debug('External secrets init complete');
        await this.initEventBus();
        this.logger.debug('Event bus init complete');
        await this.initQueue();
        this.logger.debug('Queue init complete');
        await this.initOrchestration();
        this.logger.debug('Orchestration init complete');
        await this.initQueue();
        await typedi_1.Container.get(orchestration_worker_service_1.OrchestrationWorkerService).publishToEventLog(new EventMessageGeneric_1.EventMessageGeneric({
            eventName: 'n8n.worker.started',
            payload: {
                workerId: this.queueModeId,
            },
        }));
    }
    async initEventBus() {
        await eventbus_1.eventBus.initialize({
            workerId: this.queueModeId,
        });
    }
    async initOrchestration() {
        await typedi_1.Container.get(orchestration_worker_service_1.OrchestrationWorkerService).init();
        await typedi_1.Container.get(orchestration_handler_worker_service_1.OrchestrationHandlerWorkerService).initWithOptions({
            queueModeId: this.queueModeId,
            redisPublisher: typedi_1.Container.get(orchestration_worker_service_1.OrchestrationWorkerService).redisPublisher,
            getRunningJobIds: () => Object.keys(Worker.runningJobs),
            getRunningJobsSummary: () => Object.values(Worker.runningJobsSummary),
        });
    }
    async initQueue() {
        const { flags } = this.parse(Worker);
        const redisConnectionTimeoutLimit = config_1.default.getEnv('queue.bull.redis.timeoutThreshold');
        this.logger.debug(`Opening Redis connection to listen to messages with timeout ${redisConnectionTimeoutLimit}`);
        Worker.jobQueue = typedi_1.Container.get(Queue_1.Queue);
        await Worker.jobQueue.init();
        this.logger.debug('Queue singleton ready');
        void Worker.jobQueue.process(flags.concurrency, async (job) => this.runJob(job, this.nodeTypes));
        Worker.jobQueue.getBullObjectInstance().on('global:progress', (jobId, progress) => {
            if (progress === -1) {
                if (Worker.runningJobs[jobId] !== undefined) {
                    Worker.runningJobs[jobId].cancel();
                    delete Worker.runningJobs[jobId];
                }
            }
        });
        let lastTimer = 0;
        let cumulativeTimeout = 0;
        Worker.jobQueue.getBullObjectInstance().on('error', (error) => {
            if (error.toString().includes('ECONNREFUSED')) {
                const now = Date.now();
                if (now - lastTimer > 30000) {
                    lastTimer = now;
                    cumulativeTimeout = 0;
                }
                else {
                    cumulativeTimeout += now - lastTimer;
                    lastTimer = now;
                    if (cumulativeTimeout > redisConnectionTimeoutLimit) {
                        this.logger.error(`Unable to connect to Redis after ${redisConnectionTimeoutLimit}. Exiting process.`);
                        process.exit(1);
                    }
                }
                this.logger.warn('Redis unavailable - trying to reconnect...');
            }
            else if (error.toString().includes('Error initializing Lua scripts')) {
                this.logger.error('Error initializing worker.');
                process.exit(2);
            }
            else {
                this.logger.error('Error from queue: ', error);
                throw error;
            }
        });
    }
    async setupHealthMonitor() {
        const port = config_1.default.getEnv('queue.health.port');
        const app = (0, express_1.default)();
        app.disable('x-powered-by');
        const server = http_1.default.createServer(app);
        app.get('/healthz', async (req, res) => {
            this.logger.debug('Health check started!');
            const connection = Db.getConnection();
            try {
                if (!connection.isInitialized) {
                    throw new Error('No active database connection!');
                }
                await connection.query('SELECT 1');
            }
            catch (e) {
                this.logger.error('No Database connection!', e);
                const error = new ResponseHelper.ServiceUnavailableError('No Database connection!');
                return ResponseHelper.sendErrorResponse(res, error);
            }
            try {
                await Worker.jobQueue.ping();
            }
            catch (e) {
                this.logger.error('No Redis connection!', e);
                const error = new ResponseHelper.ServiceUnavailableError('No Redis connection!');
                return ResponseHelper.sendErrorResponse(res, error);
            }
            const responseData = {
                status: 'ok',
            };
            this.logger.debug('Health check completed successfully!');
            ResponseHelper.sendSuccessResponse(res, responseData, true, 200);
        });
        let presetCredentialsLoaded = false;
        const endpointPresetCredentials = config_1.default.getEnv('credentials.overwrite.endpoint');
        if (endpointPresetCredentials !== '') {
            app.post(`/${endpointPresetCredentials}`, middlewares_1.rawBodyReader, middlewares_1.bodyParser, async (req, res) => {
                if (!presetCredentialsLoaded) {
                    const body = req.body;
                    if (req.contentType !== 'application/json') {
                        ResponseHelper.sendErrorResponse(res, new Error('Body must be a valid JSON, make sure the content-type is application/json'));
                        return;
                    }
                    typedi_1.Container.get(CredentialsOverwrites_1.CredentialsOverwrites).setData(body);
                    presetCredentialsLoaded = true;
                    ResponseHelper.sendSuccessResponse(res, { success: true }, true, 200);
                }
                else {
                    ResponseHelper.sendErrorResponse(res, new Error('Preset credentials can be set once'));
                }
            });
        }
        server.on('error', (error) => {
            if (error.code === 'EADDRINUSE') {
                this.logger.error(`n8n's port ${port} is already in use. Do you have the n8n main process running on that port?`);
                process.exit(1);
            }
        });
        await new Promise((resolve) => server.listen(port, () => resolve()));
        await this.externalHooks.run('worker.ready');
        this.logger.info(`\nn8n worker health check via, port ${port}`);
    }
    async run() {
        const { flags } = this.parse(Worker);
        this.logger.info('\nn8n worker is now ready');
        this.logger.info(` * Version: ${constants_1.N8N_VERSION}`);
        this.logger.info(` * Concurrency: ${flags.concurrency}`);
        this.logger.info('');
        if (config_1.default.getEnv('queue.health.active')) {
            await this.setupHealthMonitor();
        }
        await new Promise(() => { });
    }
    async catch(error) {
        await this.exitWithCrash('Worker exiting due to an error.', error);
    }
}
exports.Worker = Worker;
Worker.description = '\nStarts a n8n worker';
Worker.examples = ['$ n8n worker --concurrency=5'];
Worker.flags = {
    help: command_1.flags.help({ char: 'h' }),
    concurrency: command_1.flags.integer({
        default: 10,
        description: 'How many jobs can run in parallel.',
    }),
};
Worker.runningJobs = {};
Worker.runningJobsSummary = {};
//# sourceMappingURL=worker.js.map