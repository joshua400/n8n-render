"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsersController = void 0;
const validator_1 = __importDefault(require("validator"));
const typeorm_1 = require("typeorm");
const n8n_workflow_1 = require("n8n-workflow");
const User_1 = require("../databases/entities/User");
const SharedCredentials_1 = require("../databases/entities/SharedCredentials");
const SharedWorkflow_1 = require("../databases/entities/SharedWorkflow");
const decorators_1 = require("../decorators");
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const jwt_1 = require("../auth/jwt");
const ResponseHelper_1 = require("../ResponseHelper");
const requests_1 = require("../requests");
const email_1 = require("../UserManagement/email");
const ActiveWorkflowRunner_1 = require("../ActiveWorkflowRunner");
const AuthIdentity_1 = require("../databases/entities/AuthIdentity");
const posthog_1 = require("../posthog");
const samlHelpers_1 = require("../sso/saml/samlHelpers");
const sharedCredentials_repository_1 = require("../databases/repositories/sharedCredentials.repository");
const sharedWorkflow_repository_1 = require("../databases/repositories/sharedWorkflow.repository");
const class_transformer_1 = require("class-transformer");
const License_1 = require("../License");
const typedi_1 = require("typedi");
const constants_1 = require("../constants");
const jwt_service_1 = require("../services/jwt.service");
const role_service_1 = require("../services/role.service");
const user_service_1 = require("../services/user.service");
const middlewares_1 = require("../middlewares");
const Logger_1 = require("../Logger");
let UsersController = class UsersController {
    constructor(config, logger, externalHooks, internalHooks, sharedCredentialsRepository, sharedWorkflowRepository, activeWorkflowRunner, mailer, jwtService, roleService, userService, postHog) {
        this.config = config;
        this.logger = logger;
        this.externalHooks = externalHooks;
        this.internalHooks = internalHooks;
        this.sharedCredentialsRepository = sharedCredentialsRepository;
        this.sharedWorkflowRepository = sharedWorkflowRepository;
        this.activeWorkflowRunner = activeWorkflowRunner;
        this.mailer = mailer;
        this.jwtService = jwtService;
        this.roleService = roleService;
        this.userService = userService;
        this.postHog = postHog;
    }
    async sendEmailInvites(req) {
        const isWithinUsersLimit = typedi_1.Container.get(License_1.License).isWithinUsersLimit();
        if ((0, samlHelpers_1.isSamlLicensedAndEnabled)()) {
            this.logger.debug('SAML is enabled, so users are managed by the Identity Provider and cannot be added through invites');
            throw new ResponseHelper_1.BadRequestError('SAML is enabled, so users are managed by the Identity Provider and cannot be added through invites');
        }
        if (!isWithinUsersLimit) {
            this.logger.debug('Request to send email invite(s) to user(s) failed because the user limit quota has been reached');
            throw new ResponseHelper_1.UnauthorizedError(constants_1.RESPONSE_ERROR_MESSAGES.USERS_QUOTA_REACHED);
        }
        if (!this.config.getEnv('userManagement.isInstanceOwnerSetUp')) {
            this.logger.debug('Request to send email invite(s) to user(s) failed because the owner account is not set up');
            throw new ResponseHelper_1.BadRequestError('You must set up your own account before inviting others');
        }
        if (!Array.isArray(req.body)) {
            this.logger.debug('Request to send email invite(s) to user(s) failed because the payload is not an array', {
                payload: req.body,
            });
            throw new ResponseHelper_1.BadRequestError('Invalid payload');
        }
        if (!req.body.length)
            return [];
        const createUsers = {};
        req.body.forEach((invite) => {
            if (typeof invite !== 'object' || !invite.email) {
                throw new ResponseHelper_1.BadRequestError('Request to send email invite(s) to user(s) failed because the payload is not an array shaped Array<{ email: string }>');
            }
            if (!validator_1.default.isEmail(invite.email)) {
                this.logger.debug('Invalid email in payload', { invalidEmail: invite.email });
                throw new ResponseHelper_1.BadRequestError(`Request to send email invite(s) to user(s) failed because of an invalid email address: ${invite.email}`);
            }
            createUsers[invite.email.toLowerCase()] = null;
        });
        const role = await this.roleService.findGlobalMemberRole();
        if (!role) {
            this.logger.error('Request to send email invite(s) to user(s) failed because no global member role was found in database');
            throw new ResponseHelper_1.InternalServerError('Members role not found in database - inconsistent state');
        }
        const existingUsers = await this.userService.findMany({
            where: { email: (0, typeorm_1.In)(Object.keys(createUsers)) },
            relations: ['globalRole'],
        });
        existingUsers.forEach((user) => {
            if (user.password) {
                delete createUsers[user.email];
                return;
            }
            createUsers[user.email] = user.id;
        });
        const usersToSetUp = Object.keys(createUsers).filter((email) => createUsers[email] === null);
        const total = usersToSetUp.length;
        this.logger.debug(total > 1 ? `Creating ${total} user shells...` : 'Creating 1 user shell...');
        try {
            await this.userService.getManager().transaction(async (transactionManager) => Promise.all(usersToSetUp.map(async (email) => {
                const newUser = Object.assign(new User_1.User(), {
                    email,
                    globalRole: role,
                });
                const savedUser = await transactionManager.save(newUser);
                createUsers[savedUser.email] = savedUser.id;
                return savedUser;
            })));
        }
        catch (error) {
            n8n_workflow_1.ErrorReporterProxy.error(error);
            this.logger.error('Failed to create user shells', { userShells: createUsers });
            throw new ResponseHelper_1.InternalServerError('An error occurred during user creation');
        }
        this.logger.debug('Created user shell(s) successfully', { userId: req.user.id });
        this.logger.verbose(total > 1 ? `${total} user shells created` : '1 user shell created', {
            userShells: createUsers,
        });
        const baseUrl = (0, UserManagementHelper_1.getInstanceBaseUrl)();
        const usersPendingSetup = Object.entries(createUsers).filter(([email, id]) => id && email);
        const emailingResults = await Promise.all(usersPendingSetup.map(async ([email, id]) => {
            if (!id) {
                throw new ResponseHelper_1.InternalServerError('User ID is missing for user with email address');
            }
            const inviteAcceptUrl = (0, UserManagementHelper_1.generateUserInviteUrl)(req.user.id, id);
            const resp = {
                user: {
                    id,
                    email,
                    inviteAcceptUrl,
                    emailSent: false,
                },
            };
            try {
                const result = await this.mailer.invite({
                    email,
                    inviteAcceptUrl,
                    domain: baseUrl,
                });
                if (result.emailSent) {
                    resp.user.emailSent = true;
                    delete resp.user.inviteAcceptUrl;
                    void this.internalHooks.onUserTransactionalEmail({
                        user_id: id,
                        message_type: 'New user invite',
                        public_api: false,
                    });
                }
                void this.internalHooks.onUserInvite({
                    user: req.user,
                    target_user_id: Object.values(createUsers),
                    public_api: false,
                    email_sent: result.emailSent,
                });
            }
            catch (error) {
                if (error instanceof Error) {
                    void this.internalHooks.onEmailFailed({
                        user: req.user,
                        message_type: 'New user invite',
                        public_api: false,
                    });
                    this.logger.error('Failed to send email', {
                        userId: req.user.id,
                        inviteAcceptUrl,
                        domain: baseUrl,
                        email,
                    });
                    resp.error = error.message;
                }
            }
            return resp;
        }));
        await this.externalHooks.run('user.invited', [usersToSetUp]);
        this.logger.debug(usersPendingSetup.length > 1
            ? `Sent ${usersPendingSetup.length} invite emails successfully`
            : 'Sent 1 invite email successfully', { userShells: createUsers });
        return emailingResults;
    }
    async updateUser(req, res) {
        const { id: inviteeId } = req.params;
        const { inviterId, firstName, lastName, password } = req.body;
        if (!inviterId || !inviteeId || !firstName || !lastName || !password) {
            this.logger.debug('Request to fill out a user shell failed because of missing properties in payload', { payload: req.body });
            throw new ResponseHelper_1.BadRequestError('Invalid payload');
        }
        const validPassword = (0, UserManagementHelper_1.validatePassword)(password);
        const users = await this.userService.findMany({
            where: { id: (0, typeorm_1.In)([inviterId, inviteeId]) },
            relations: ['globalRole'],
        });
        if (users.length !== 2) {
            this.logger.debug('Request to fill out a user shell failed because the inviter ID and/or invitee ID were not found in database', {
                inviterId,
                inviteeId,
            });
            throw new ResponseHelper_1.BadRequestError('Invalid payload or URL');
        }
        const invitee = users.find((user) => user.id === inviteeId);
        if (invitee.password) {
            this.logger.debug('Request to fill out a user shell failed because the invite had already been accepted', { inviteeId });
            throw new ResponseHelper_1.BadRequestError('This invite has been accepted already');
        }
        invitee.firstName = firstName;
        invitee.lastName = lastName;
        invitee.password = await (0, UserManagementHelper_1.hashPassword)(validPassword);
        const updatedUser = await this.userService.save(invitee);
        await (0, jwt_1.issueCookie)(res, updatedUser);
        void this.internalHooks.onUserSignup(updatedUser, {
            user_type: 'email',
            was_disabled_ldap_user: false,
        });
        const publicInvitee = await this.userService.toPublic(invitee);
        await this.externalHooks.run('user.profile.update', [invitee.email, publicInvitee]);
        await this.externalHooks.run('user.password.update', [invitee.email, invitee.password]);
        return this.userService.toPublic(updatedUser, { posthog: this.postHog });
    }
    async toFindManyOptions(listQueryOptions) {
        const findManyOptions = {};
        if (!listQueryOptions) {
            findManyOptions.relations = ['globalRole', 'authIdentities'];
            return findManyOptions;
        }
        const { filter, select, take, skip } = listQueryOptions;
        if (select)
            findManyOptions.select = select;
        if (take)
            findManyOptions.take = take;
        if (skip)
            findManyOptions.skip = skip;
        if (take && !select) {
            findManyOptions.relations = ['globalRole', 'authIdentities'];
        }
        if (take && select && !(select === null || select === void 0 ? void 0 : select.id)) {
            findManyOptions.select = { ...findManyOptions.select, id: true };
        }
        if (filter) {
            const { isOwner, ...otherFilters } = filter;
            findManyOptions.where = otherFilters;
            if (isOwner !== undefined) {
                const ownerRole = await this.roleService.findGlobalOwnerRole();
                findManyOptions.relations = ['globalRole'];
                findManyOptions.where.globalRole = { id: isOwner ? ownerRole.id : (0, typeorm_1.Not)(ownerRole.id) };
            }
        }
        return findManyOptions;
    }
    removeSupplementaryFields(publicUsers, listQueryOptions) {
        const { take, select, filter } = listQueryOptions;
        if (take && select && !(select === null || select === void 0 ? void 0 : select.id)) {
            for (const user of publicUsers)
                delete user.id;
        }
        if (filter === null || filter === void 0 ? void 0 : filter.isOwner) {
            for (const user of publicUsers)
                delete user.globalRole;
        }
        if (select) {
            for (const user of publicUsers) {
                delete user.isOwner;
                delete user.isPending;
                delete user.signInType;
                delete user.hasRecoveryCodesLeft;
            }
        }
        return publicUsers;
    }
    async listUsers(req) {
        const { listQueryOptions } = req;
        const findManyOptions = await this.toFindManyOptions(listQueryOptions);
        const users = await this.userService.findMany(findManyOptions);
        const publicUsers = await Promise.all(users.map(async (u) => this.userService.toPublic(u, { withInviteUrl: true })));
        return listQueryOptions
            ? this.removeSupplementaryFields(publicUsers, listQueryOptions)
            : publicUsers;
    }
    async getUserPasswordResetLink(req) {
        const user = await this.userService.findOneOrFail({
            where: { id: req.params.id },
        });
        if (!user) {
            throw new ResponseHelper_1.NotFoundError('User not found');
        }
        const link = this.userService.generatePasswordResetUrl(user);
        return { link };
    }
    async updateUserSettings(req) {
        const payload = (0, class_transformer_1.plainToInstance)(requests_1.UserSettingsUpdatePayload, req.body);
        const id = req.params.id;
        await this.userService.updateSettings(id, payload);
        const user = await this.userService.findOneOrFail({
            select: ['settings'],
            where: { id },
        });
        return user.settings;
    }
    async deleteUser(req) {
        const { id: idToDelete } = req.params;
        if (req.user.id === idToDelete) {
            this.logger.debug('Request to delete a user failed because it attempted to delete the requesting user', { userId: req.user.id });
            throw new ResponseHelper_1.BadRequestError('Cannot delete your own user');
        }
        const { transferId } = req.query;
        if (transferId === idToDelete) {
            throw new ResponseHelper_1.BadRequestError('Request to delete a user failed because the user to delete and the transferee are the same user');
        }
        const users = await this.userService.findMany({
            where: { id: (0, typeorm_1.In)([transferId, idToDelete]) },
            relations: ['globalRole'],
        });
        if (!users.length || (transferId && users.length !== 2)) {
            throw new ResponseHelper_1.NotFoundError('Request to delete a user failed because the ID of the user to delete and/or the ID of the transferee were not found in DB');
        }
        const userToDelete = users.find((user) => user.id === req.params.id);
        const telemetryData = {
            user_id: req.user.id,
            target_user_old_status: userToDelete.isPending ? 'invited' : 'active',
            target_user_id: idToDelete,
        };
        telemetryData.migration_strategy = transferId ? 'transfer_data' : 'delete_data';
        if (transferId) {
            telemetryData.migration_user_id = transferId;
        }
        const [workflowOwnerRole, credentialOwnerRole] = await Promise.all([
            this.roleService.findWorkflowOwnerRole(),
            this.roleService.findCredentialOwnerRole(),
        ]);
        if (transferId) {
            const transferee = users.find((user) => user.id === transferId);
            await this.userService.getManager().transaction(async (transactionManager) => {
                const sharedWorkflowIds = await transactionManager
                    .getRepository(SharedWorkflow_1.SharedWorkflow)
                    .find({
                    select: ['workflowId'],
                    where: { userId: userToDelete.id, roleId: workflowOwnerRole === null || workflowOwnerRole === void 0 ? void 0 : workflowOwnerRole.id },
                })
                    .then((sharedWorkflows) => sharedWorkflows.map(({ workflowId }) => workflowId));
                await transactionManager.delete(SharedWorkflow_1.SharedWorkflow, {
                    user: transferee,
                    workflowId: (0, typeorm_1.In)(sharedWorkflowIds),
                });
                await transactionManager.update(SharedWorkflow_1.SharedWorkflow, { user: userToDelete, role: workflowOwnerRole }, { user: transferee });
                const sharedCredentialIds = await transactionManager
                    .getRepository(SharedCredentials_1.SharedCredentials)
                    .find({
                    select: ['credentialsId'],
                    where: { userId: userToDelete.id, roleId: credentialOwnerRole === null || credentialOwnerRole === void 0 ? void 0 : credentialOwnerRole.id },
                })
                    .then((sharedCredentials) => sharedCredentials.map(({ credentialsId }) => credentialsId));
                await transactionManager.delete(SharedCredentials_1.SharedCredentials, {
                    user: transferee,
                    credentialsId: (0, typeorm_1.In)(sharedCredentialIds),
                });
                await transactionManager.update(SharedCredentials_1.SharedCredentials, { user: userToDelete, role: credentialOwnerRole }, { user: transferee });
                await transactionManager.delete(AuthIdentity_1.AuthIdentity, { userId: userToDelete.id });
                await transactionManager.delete(User_1.User, { id: userToDelete.id });
            });
            void this.internalHooks.onUserDeletion({
                user: req.user,
                telemetryData,
                publicApi: false,
            });
            await this.externalHooks.run('user.deleted', [await this.userService.toPublic(userToDelete)]);
            return { success: true };
        }
        const [ownedSharedWorkflows, ownedSharedCredentials] = await Promise.all([
            this.sharedWorkflowRepository.find({
                relations: ['workflow'],
                where: { userId: userToDelete.id, roleId: workflowOwnerRole === null || workflowOwnerRole === void 0 ? void 0 : workflowOwnerRole.id },
            }),
            this.sharedCredentialsRepository.find({
                relations: ['credentials'],
                where: { userId: userToDelete.id, roleId: credentialOwnerRole === null || credentialOwnerRole === void 0 ? void 0 : credentialOwnerRole.id },
            }),
        ]);
        await this.userService.getManager().transaction(async (transactionManager) => {
            const ownedWorkflows = await Promise.all(ownedSharedWorkflows.map(async ({ workflow }) => {
                if (workflow.active) {
                    await this.activeWorkflowRunner.remove(workflow.id);
                }
                return workflow;
            }));
            await transactionManager.remove(ownedWorkflows);
            await transactionManager.remove(ownedSharedCredentials.map(({ credentials }) => credentials));
            await transactionManager.delete(AuthIdentity_1.AuthIdentity, { userId: userToDelete.id });
            await transactionManager.delete(User_1.User, { id: userToDelete.id });
        });
        void this.internalHooks.onUserDeletion({
            user: req.user,
            telemetryData,
            publicApi: false,
        });
        await this.externalHooks.run('user.deleted', [await this.userService.toPublic(userToDelete)]);
        return { success: true };
    }
};
exports.UsersController = UsersController;
__decorate([
    (0, decorators_1.Post)('/'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "sendEmailInvites", null);
__decorate([
    (0, decorators_1.NoAuthRequired)(),
    (0, decorators_1.Post)('/:id'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "updateUser", null);
__decorate([
    (0, decorators_1.Authorized)('any'),
    (0, decorators_1.Get)('/', { middlewares: middlewares_1.listQueryMiddleware }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "listUsers", null);
__decorate([
    (0, decorators_1.Authorized)(['global', 'owner']),
    (0, decorators_1.Get)('/:id/password-reset-link'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "getUserPasswordResetLink", null);
__decorate([
    (0, decorators_1.Authorized)(['global', 'owner']),
    (0, decorators_1.Patch)('/:id/settings'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "updateUserSettings", null);
__decorate([
    (0, decorators_1.Delete)('/:id'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "deleteUser", null);
exports.UsersController = UsersController = __decorate([
    (0, decorators_1.Authorized)(['global', 'owner']),
    (0, decorators_1.RestController)('/users'),
    __metadata("design:paramtypes", [Object, Logger_1.Logger, Object, Object, sharedCredentials_repository_1.SharedCredentialsRepository,
        sharedWorkflow_repository_1.SharedWorkflowRepository,
        ActiveWorkflowRunner_1.ActiveWorkflowRunner,
        email_1.UserManagementMailer,
        jwt_service_1.JwtService,
        role_service_1.RoleService,
        user_service_1.UserService,
        posthog_1.PostHogClient])
], UsersController);
//# sourceMappingURL=users.controller.js.map