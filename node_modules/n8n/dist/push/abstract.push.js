"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractPush = void 0;
const events_1 = require("events");
const n8n_workflow_1 = require("n8n-workflow");
class AbstractPush extends events_1.EventEmitter {
    constructor(logger) {
        super();
        this.logger = logger;
        this.connections = {};
        this.userIdBySessionId = {};
    }
    add(sessionId, userId, connection) {
        const { connections, userIdBySessionId: userIdsBySessionId } = this;
        this.logger.debug('Add editor-UI session', { sessionId });
        const existingConnection = connections[sessionId];
        if (existingConnection) {
            this.close(existingConnection);
        }
        connections[sessionId] = connection;
        userIdsBySessionId[sessionId] = userId;
    }
    onMessageReceived(sessionId, msg) {
        this.logger.debug('Received message from editor-UI', { sessionId, msg });
        const userId = this.userIdBySessionId[sessionId];
        this.emit('message', {
            sessionId,
            userId,
            msg,
        });
    }
    remove(sessionId) {
        if (sessionId !== undefined) {
            this.logger.debug('Remove editor-UI session', { sessionId });
            delete this.connections[sessionId];
            delete this.userIdBySessionId[sessionId];
        }
    }
    sendToSessions(type, data, sessionIds) {
        this.logger.debug(`Send data of type "${type}" to editor-UI`, {
            dataType: type,
            sessionIds: sessionIds.join(', '),
        });
        const sendData = (0, n8n_workflow_1.jsonStringify)({ type, data }, { replaceCircularRefs: true });
        for (const sessionId of sessionIds) {
            const connection = this.connections[sessionId];
            (0, n8n_workflow_1.assert)(connection);
            this.sendToOne(connection, sendData);
        }
    }
    broadcast(type, data) {
        this.sendToSessions(type, data, Object.keys(this.connections));
    }
    send(type, data, sessionId) {
        const { connections } = this;
        if (connections[sessionId] === undefined) {
            this.logger.error(`The session "${sessionId}" is not registered.`, { sessionId });
            return;
        }
        this.sendToSessions(type, data, [sessionId]);
    }
    sendToUsers(type, data, userIds) {
        const { connections } = this;
        const userSessionIds = Object.keys(connections).filter((sessionId) => userIds.includes(this.userIdBySessionId[sessionId]));
        this.sendToSessions(type, data, userSessionIds);
    }
}
exports.AbstractPush = AbstractPush;
//# sourceMappingURL=abstract.push.js.map