"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserService = void 0;
const typedi_1 = require("typedi");
const typeorm_1 = require("typeorm");
const User_1 = require("../databases/entities/User");
const user_repository_1 = require("../databases/repositories/user.repository");
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const jwt_service_1 = require("./jwt.service");
const jsonwebtoken_1 = require("jsonwebtoken");
const Logger_1 = require("../Logger");
const jwt_1 = require("../auth/jwt");
let UserService = class UserService {
    constructor(logger, userRepository, jwtService) {
        this.logger = logger;
        this.userRepository = userRepository;
        this.jwtService = jwtService;
    }
    async findOne(options) {
        return this.userRepository.findOne({ relations: ['globalRole'], ...options });
    }
    async findOneOrFail(options) {
        return this.userRepository.findOneOrFail({ relations: ['globalRole'], ...options });
    }
    async findMany(options) {
        return this.userRepository.find(options);
    }
    async findOneBy(options) {
        return this.userRepository.findOneBy(options);
    }
    create(data) {
        return this.userRepository.create(data);
    }
    async save(user) {
        return this.userRepository.save(user);
    }
    async update(userId, data) {
        return this.userRepository.update(userId, data);
    }
    async getByIds(transaction, ids) {
        return transaction.find(User_1.User, { where: { id: (0, typeorm_1.In)(ids) } });
    }
    getManager() {
        return this.userRepository.manager;
    }
    async updateSettings(userId, newSettings) {
        const { settings } = await this.userRepository.findOneOrFail({ where: { id: userId } });
        return this.userRepository.update(userId, { settings: { ...settings, ...newSettings } });
    }
    generatePasswordResetToken(user, expiresIn = '20m') {
        return this.jwtService.sign({ sub: user.id, passwordSha: (0, jwt_1.createPasswordSha)(user) }, { expiresIn });
    }
    generatePasswordResetUrl(user) {
        const instanceBaseUrl = (0, UserManagementHelper_1.getInstanceBaseUrl)();
        const url = new URL(`${instanceBaseUrl}/change-password`);
        url.searchParams.append('token', this.generatePasswordResetToken(user));
        url.searchParams.append('mfaEnabled', user.mfaEnabled.toString());
        return url.toString();
    }
    async resolvePasswordResetToken(token) {
        let decodedToken;
        try {
            decodedToken = this.jwtService.verify(token);
        }
        catch (e) {
            if (e instanceof jsonwebtoken_1.TokenExpiredError) {
                this.logger.debug('Reset password token expired', { token });
            }
            else {
                this.logger.debug('Error verifying token', { token });
            }
            return;
        }
        const user = await this.userRepository.findOne({
            where: { id: decodedToken.sub },
            relations: ['authIdentities', 'globalRole'],
        });
        if (!user) {
            this.logger.debug('Request to resolve password token failed because no user was found for the provided user ID', { userId: decodedToken.sub, token });
            return;
        }
        if ((0, jwt_1.createPasswordSha)(user) !== decodedToken.passwordSha) {
            this.logger.debug('Password updated since this token was generated');
            return;
        }
        return user;
    }
    async toPublic(user, options) {
        var _a;
        const { password, updatedAt, apiKey, authIdentities, ...rest } = user;
        const ldapIdentity = authIdentities === null || authIdentities === void 0 ? void 0 : authIdentities.find((i) => i.providerType === 'ldap');
        let publicUser = {
            ...rest,
            signInType: ldapIdentity ? 'ldap' : 'email',
            hasRecoveryCodesLeft: !!((_a = user.mfaRecoveryCodes) === null || _a === void 0 ? void 0 : _a.length),
        };
        if ((options === null || options === void 0 ? void 0 : options.withInviteUrl) && publicUser.isPending) {
            publicUser = this.addInviteUrl(publicUser, user.id);
        }
        if (options === null || options === void 0 ? void 0 : options.posthog) {
            publicUser = await this.addFeatureFlags(publicUser, options.posthog);
        }
        return publicUser;
    }
    addInviteUrl(user, inviterId) {
        const url = new URL((0, UserManagementHelper_1.getInstanceBaseUrl)());
        url.pathname = '/signup';
        url.searchParams.set('inviterId', inviterId);
        url.searchParams.set('inviteeId', user.id);
        user.inviteAcceptUrl = url.toString();
        return user;
    }
    async addFeatureFlags(publicUser, posthog) {
        const timeoutPromise = new Promise((resolve) => {
            setTimeout(() => {
                resolve(publicUser);
            }, 1500);
        });
        const fetchPromise = new Promise(async (resolve) => {
            publicUser.featureFlags = await posthog.getFeatureFlags(publicUser);
            resolve(publicUser);
        });
        return Promise.race([fetchPromise, timeoutPromise]);
    }
};
exports.UserService = UserService;
exports.UserService = UserService = __decorate([
    (0, typedi_1.Service)(),
    __metadata("design:paramtypes", [Logger_1.Logger,
        user_repository_1.UserRepository,
        jwt_service_1.JwtService])
], UserService);
//# sourceMappingURL=user.service.js.map